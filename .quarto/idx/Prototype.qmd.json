{"title":"Prototype","markdown":{"yaml":{"title":"Prototype","format":{"html":{"theme":"journal","toc":true,"toc-depth":2,"code-fold":true,"code-summary":"Show the code","page-layout":"full"}},"execute":{"echo":true,"warning":false,"freeze":false},"editor":"visual"},"headingText":"**Prototyping our \"🌊Covert Reef🪸\" Project**","containsRefs":false,"markdown":"\n\n\nsus\n\n# **0) Visual Thematic Overview**\n\nStart off with wordclouds at the top of the webpage to serve as a precursor to key themes:\n\n-   Shows a visually prominent wordcloud immediately at the top of the page;\n-   Previews key terms from the dataset (as a “hook”) to engage users and provide a thematic overview;\n-   Shiny compatible\n\n```{r}\nlibrary(shiny)\nlibrary(wordcloud)\nlibrary(RColorBrewer)\n\n# Data and color palette\nword <- c(\"vessels\", \"mining\", \"funding\", \"music\", \"reef\", \"conservation\", \"turtles\",\n          \"fuel\", \"permit\", \"?\", \"suspicious\", \"tourism\", \"lighting\", \"meetings\",\n          \"council\", \"harbor\", \"relationships\", \"communications\", \"operation\", \"underwater\")\nfreq <- c(5, 8, 7, 8, 9, 5, 6, 10, 8, 4, 3, 3, 5, 2, 3, 2, 5, 8, 3, 4)\nword_data_wc <- data.frame(word = word, freq = freq)\n\nocean_colors_lp <- c(\n  \"#1B1B3A\", \"#0072B2\", \"#009E73\", \"#D55E00\", \"#CC79A7\",\n  \"#882255\", \"#AA4499\", \"#004D40\", \"#333333\"\n)\n\n# Define UI\nui <- fluidPage(\n  titlePanel(\" \"),\n  plotOutput(\"wordcloudPlot\", height = \"500px\")  # Increased height\n)\n\n# Define Server\nserver <- function(input, output, session) {\n  output$wordcloudPlot <- renderPlot({\n    par(bg = \"#f0f0fb\")  # Set background inside renderPlot\n\n    wordcloud(\n      words = word_data_wc$word,\n      freq = word_data_wc$freq,\n      min.freq = 1,\n      max.words = 200,\n      random.order = FALSE,\n      colors = ocean_colors_lp,\n      rot.per = 0.20,\n      scale = c(4, 0.8)\n    )\n  })\n}\n\n# Launch App\nshinyApp(ui, server)\n\n```\n\n# **1) Setup and Preparatory Work**\n\n## **1.1 Loading Packages to prepare for SHINY**\n\n## **Packages supported in R CRAN:**\n\n+----------------------------------------------------------------------------------------------------------------------------+------------------------------------------------------------------------------------------------------------------------------+\n| **Utility Tools**                                                                                                          | **Graphing Tools**                                                                                                           |\n+============================================================================================================================+==============================================================================================================================+\n| -   [jsonlite](https://cran.r-project.org/web/packages/jsonlite/index.html) - To parse JSON                                | -   [patchwork](https://cran.r-project.org/web/packages/patchwork/index.html) - For combining ggplot plots                   |\n|                                                                                                                            |                                                                                                                              |\n| -   [tidyverse](https://www.tidyverse.org/) - Data science tools                                                           | -   [ggraph](https://ggraph.data-imaginist.com/) - For plotting network data                                                 |\n|                                                                                                                            |                                                                                                                              |\n| -   [ggtext](https://cran.r-project.org/web/packages/ggtext/index.html) - Tools for text formatting                        | -   [tidygraph](https://cran.r-project.org/web/packages/tidygraph/index.html) - For graph manipulations                      |\n|                                                                                                                            |                                                                                                                              |\n| -   [knitr](https://cran.r-project.org/web/packages/knitr/index.html) - For better table displays                          | -   [igraph](https://cran.r-project.org/web/packages/igraph/index.html) - Contains functions for network analysis            |\n|                                                                                                                            |                                                                                                                              |\n| -   [lubridate](https://cran.r-project.org/web/packages/lubridate/vignettes/lubridate.html) - For processing date and time | -   [ggiraph](https://cran.r-project.org/web/packages/ggiraph/index.html) - Interactive plots                                |\n|                                                                                                                            |                                                                                                                              |\n| -   [hms](https://cran.r-project.org/web/packages/hms/index.html) - For durations                                          | -   [plotly](https://cran.r-project.org/web/packages/plotly/index.html) - Interactive plots                                  |\n|                                                                                                                            |                                                                                                                              |\n| -   [scales](https://cran.r-project.org/web/packages/scales/index.html) - For breaks and labels                            | -   [wordcloud](https://cran.r-project.org/web/packages/wordcloud/index.html)- For frequency representation of words         |\n|                                                                                                                            |                                                                                                                              |\n| -   [tidytext](https://cran.r-project.org/web/packages/tidytext/index.html) - For functions text mining                    | -   [ggh4x](https://cran.r-project.org/web/packages/ggh4x/index.html) - For axis, strip, and facet customizations            |\n|                                                                                                                            |                                                                                                                              |\n| -   [tm](https://cran.r-project.org/web/packages/tm/index.html) - For text mining                                          | -   [visNetwork](https://cran.r-project.org/web/packages/visNetwork/index.html) - For interactive visualisation of networks. |\n|                                                                                                                            |                                                                                                                              |\n| -   [SnowBallC](https://cran.r-project.org/web/packages/SnowballC/index.html) - For Porter's word stemming                 | -   [RColorBrewer](https://cran.r-project.org/web/packages/RColorBrewer/index.html) - Colour schemes for graphics            |\n|                                                                                                                            |                                                                                                                              |\n| -   [SmartEDA](https://cran.r-project.org/web/packages/SmartEDA/index.html) - EDA with some graphing                       | -   [circlize](https://cran.r-project.org/web/packages/circlize/index.html) - For circular plots                             |\n|                                                                                                                            |                                                                                                                              |\n| -   [reactable](https://cran.r-project.org/web/packages/reactable/index.html) - For interactive data tables                | -   [ggalluvial](https://cran.r-project.org/web/packages/alluvial/index.html) - For alluvial diagrams                        |\n|                                                                                                                            |                                                                                                                              |\n| -   [highcharter](https://cran.r-project.org/web/packages/highcharter/index.html)- For wrapper function                    | -   [networkD3](https://cran.r-project.org/web/packages/networkD3/index.html)- For D3-based interactive network graphs       |\n|                                                                                                                            |                                                                                                                              |\n| -   [conflicted](https://cran.r-project.org/web/packages/conflicted/index.html) - For managing namespace conflicts         | -   [leaflet](https://cran.r-project.org/web/packages/leaflet/index.html)- For interactive maps                              |\n+----------------------------------------------------------------------------------------------------------------------------+------------------------------------------------------------------------------------------------------------------------------+\n\n-   We will use the code chunk below uses p_load() of pacman package to check if packages are installed in the computer. If they are, then they will be launched into R. Though it is not added here in pacman due to conflicts, networkD3, highcharter, leaflet, conflicted will also be added on Shiny.\n\n```{r}\n#| code-fold: true \n#| code-summary: \"Show the code\" \npacman::p_load(jsonlite, tidyverse, ggtext,   \n               knitr, lubridate, hms, scales,   \n               tidytext, tm, SnowballC,   \n               patchwork, ggraph,    \n               tidygraph, igraph, ggiraph,    \n               SmartEDA, plotly, wordcloud,    \n               ggh4x, visNetwork, RColorBrewer, \n               circlize, ggalluvial, reactable)  \n```\n\n## **🧰 Part of Tidyverse**\n\n::: {.card style=\"background-color: #f5f9ff; padding: 1rem; border-left: 5px solid #6482eb; margin-bottom: 1rem;\"}\n-   [stringr](https://cran.r-project.org/web/packages/stringr/index.html) - For wrapping text and string manipulation\n\n-   [readr](https://cran.r-project.org/web/packages/readr/index.html) - For reading rectangular data (CSV, TSV, etc)\n\n-   [dplyr](https://cran.r-project.org/web/packages/dplyr/index.html) - For transforming, filtering, summarising data\n\n-   [ggplot2](https://cran.r-project.org/web/packages/ggplot2/index.html) - For building data visualisation\n:::\n\n## 🔄**Workarounds:**\n\nThese are some workarounds required for Shiny application:\n\n::: {.card style=\"background-color: #f5f9ff; padding: 1rem; border-left: 5px solid #6482eb; margin-bottom: 1rem;\"}\n-   magick - For graphics and image processing will be replaced by renderImage() + impageOutput()\n\n-   We will use renderWordcloud2() (from the wordcloud2 package) and wordcloud2Output() in our UI.\n:::\n\n## 🆚**Settle Conflict Issues:**\n\n::: {.card style=\"background-color: #f5f9ff; padding: 1rem; border-left: 5px solid #6482eb; margin-bottom: 1rem;\"}\n-   conflicts_prefer(shinydashboard::box)\n-   conflicts_prefer(dplyr::filter)\n-   conflicts_prefer(dplyr::lag)\n-   conflicts_prefer(networkD3::JS)\n:::\n\n## **1.2 Loading Data**\n\nIn the code chunk below, fromJSON() of jsonlite package was used to import mc3.json file into R and save the output object.\n\n```{r}\n#| code-fold: true\n#| code-summary: \"Show the code\"\nmc3_data <- fromJSON(\"data/mc3_graph.json\")\nmc3_schema <- fromJSON(\"data/MC3_schema.json\")\n```\n\nIt contains graph data, where nodes can be accessed via `nodes` and edges via `links`. This dataset had many columns but we filtered the relevant data during wrangling.\n\n## **1.3 Defining common variables**\n\nWe will also set some values for consistency throughout all graphs.\n\n::: panel-tabset\n## Style and Colours\n\n```{r}\nnode_legend_colors_plot <- c(\n  \"Person\" = \"#88CCEE\",\n  \"Vessel\" = \"#D55E00\",\n  \"Organization\" = \"#117733\",\n  \"Location\" = \"#AA4499\",\n  \"Group\"= \"#CC79A7\",\n  \"Event\" = \"#DDCC77\",\n  \"Relationship\" = \"#AF8DC3\",\n  \"Nadia Conti\" = \"red\"\n)\n\nnode_legend_shapes_plot <- c(\n  \"Person\" = \"dot\",\n  \"Vessel\" = \"triangle\",\n  \"Organization\" = \"square\",\n  \"Location\" = \"diamond\",\n  \"Group\" = \"circle plus\",\n  \"Event\" = \"star\",\n  \"Relationship\" = \"square x\",\n  \"Nadia Conti\" = \"star\"\n)\n\nSTYLES <- list(\n  node_label_dark = \"black\",\n  font_family = \"Roboto Condensed\"\n)\n```\n:::\n\n## **1.4 Inspecting knowledge graph structure**\n\nIn the code chunk below glimpse() is used to reveal the structure of mc3_data knowledge graph.\n\n::: panel-tabset\n## The Code\n\n``` r\nglimpse(mc3_data)\n```\n\n## The Result\n\n```{r, echo=FALSE}\nglimpse(mc3_data)\n```\n:::\n\n## **1.5 Extracting the edges and nodes tables**\n\nNext, `as_tibble()` of **tibble** package package is used to extract the nodes and links tibble data frames from *mc3* tibble dataframe into two separate tibble dataframes called *mc3_nodes_raw* and *mc3_edges_raw* respectively.\n\n::: panel-tabset\n## The Code\n\n```{r}\nmc3_nodes_raw <- as_tibble(mc3_data$nodes)\nmc3_edges_raw <- as_tibble(mc3_data$edges)\n```\n\nWe also looked into the nodes and edges structure.\n\n## Nodes structure\n\n```{r}\nExpData(data=mc3_nodes_raw,type=2)\n```\n\n## Edges structure\n\n```{r}\nExpData(data=mc3_edges_raw,type=2)\n```\n:::\n\n# **2) Initial EDA for Nodes and Edges**\n\n## **2.1 Nodes via Shiny**\n\n::: panel-tabset\n## Nodes\n\nIn the code chunk below, ExpCatViz() of SmartEDA package is used to reveal the frequency distribution of all categorical fields in mc3_nodes tibble dataframe.\n\n```{r}\nlibrary(shiny)\nlibrary(ggplot2)\n\n# Run ExpCatViz once at the top to avoid recomputing\nExpCatViz(data=mc3_nodes_raw,\n          col=\"navyblue\")\n\n```\n\n## Drilling into Node sub_type\n\nCode chunk below uses ggplot2 functions to reveal the frequency distribution of *sub_type* field of *mc3_nodes_raw*.\n\n```{r}\n# Step 1: Count and reorder\nmc3_nodes_ordered <- mc3_nodes_raw %>%\n  count(sub_type) %>%\n  arrange((n)) %>%\n  mutate(sub_type = factor(sub_type, levels = sub_type))\n\n# Step 2: Plot with navy bars, sorted, and horizontal\nggplot(mc3_nodes_ordered, aes(x = sub_type, y = n)) +\n  geom_col(fill = \"navy\") +\n  coord_flip() +\n  labs(x = \"Sub_type\", y = \"Count\",\n    title = \"Distribution of Subtypes\") +\n  theme_minimal()\n```\n\n## Entity subtypes\n\nIn the code chunk below, the Entity subtypes are filtered.\n\n```{r}\n# Step 1: Filter for type == \"Entity\", count sub_type, sort \nrelationship_subtypes <- mc3_nodes_raw %>%\n  filter(type == \"Entity\") %>%\n  count(sub_type) %>%\n  arrange(n) %>%\n  mutate(sub_type = factor(sub_type, levels = sub_type)) \n\n# Step 2: Plot\nggplot(relationship_subtypes, aes(x = sub_type, y = n)) +\n  geom_col(fill = \"navy\") +\n  coord_flip() +\n  labs(\n    x = \"Entity Subtype\",\n    y = \"Count\",\n    title = \"Distribution of Entity Subtypes\"\n  ) +\n  theme_minimal()\n```\n\n## Event subtypes\n\nIn the code chunk below, the Event subtypes are filtered.\n\n```{r}\n# Step 1: Filter for type == \"Event\", count sub_type, sort \nrelationship_subtypes <- mc3_nodes_raw %>%\n  filter(type == \"Event\") %>%\n  count(sub_type) %>%\n  arrange(n) %>%\n  mutate(sub_type = factor(sub_type, levels = sub_type)) \n\n# Step 2: Plot\nggplot(relationship_subtypes, aes(x = sub_type, y = n)) +\n  geom_col(fill = \"navy\") +\n  coord_flip() +\n  labs(\n    x = \"Event Subtype\",\n    y = \"Count\",\n    title = \"Distribution of Event Subtypes\"\n  ) +\n  theme_minimal()\n```\n\n## Relationship subtypes\n\nIn the code chunk below, the relationship subtypes are filtered.\n\n```{r}\n# Step 1: Filter for type == \"Relationship\", count sub_type, sort \nrelationship_subtypes <- mc3_nodes_raw %>%\n  filter(type == \"Relationship\") %>%\n  count(sub_type) %>%\n  arrange(n) %>%\n  mutate(sub_type = factor(sub_type, levels = sub_type))\n\n# Step 2: Plot\nggplot(relationship_subtypes, aes(x = sub_type, y = n)) +\n  geom_col(fill = \"navy\") +\n  coord_flip() +\n  labs(\n    x = \"Relationship Subtype\",\n    y = \"Count\",\n    title = \"Distribution of Relationship Subtypes\"\n  ) +\n  theme_minimal()\n```\n:::\n\n## 2.1.1 Findings from EDA\n\n::: panel-tabset\n## Nodes\n\nWe will use the EDA findings to determine data to focus on or eliminate. From the bar charts and the original data on mc3_nodes_raw, it was observed that:\n\n-   Nodes were one of three types (Entity, Event, Relationship), where each of these types have their sub_types. Majority were of event type, followed by relationship, and entity.\n\n    -   There were 25 subtypes. Communications made up the bulk of the sub_type for Events. Coordinates made up the bulk of the sub_type for Relationship. The additional node sub_types not mentioned in the VAST 2025 MC3 Data Description under Node Attributes were: fishing, communication and coordinates.\n\n## Event Types\n\n-   Observations of EDA from Event types:\n\n    -   `Findings` field were filled when there were `monitoring_type`.\n\n    -   `Content` refers to radio communication content.\n\n    -   `Results` field were filled when there were `assessment_type` performed.\n\n    -   When there is an `enforcement_type` of enforcement operations or warnings, there might be an `outcome` at times.\n\n    -   When there is a `movement_type`, there might be a place of `destination` at times.\n\n## Relationship Types\n\n-   Observations of EDA from Relationship types:\n\n    -   When the subtype was coordinate, there were data in the field named `coordination_types`.\n\n    -   When the subtype was operate, there were data in the field named `operational_roles`.\n\n    -   When there is a `jurisdiction_type`, there might be an `authority_level`.\n\n    -   There are only restricted or special access data within `permission_types`.\n\n    -   When there is a `report_type` of data transmission or environmental report, there might be a `submission_date`.\n\n## Entity Types\n\n-   Observations of EDA from Entity types:\n\n    -   The 5 id under Group sub-types were not very useful information.\n\n## Course of Action\n\n-   Elimination and directed focus:\n\n    -   Relative to the entire dataset, there were little `assessment_type` (3%), `movement_type` (2%), `enforcement_type` (2%), `permission_type` (4%), `report_type` (2%), `authority_level` (1%). We will direct our focus on other areas instead of these.\n\n    -   There were no to little useful data in the fields named: `activity_type`, `references`, `dates`, `time`, and `friendship_type`. These were not utilised.\n\n    -   We directed our focus on Event_Communication, Event_Monitoring, and Event_VesselMovement.\n:::\n\n## **2.2 Edges**\n\nThe code chunk below used ExpCATViz() of SmartEDA package to reveal the frequency distribution of all categorical fields in mc3_edges_raw tibble dataframe.\n\n::: panel-tabset\n## Frequency Distribution of Categorical Fields\n\n```{r}\nExpCatViz(data=mc3_edges_raw,\n          col=\"navyblue\")\n```\n\nEntities are connected by edges to other Entities via an Event or Relationship node. The one exception to this is the Communication Event subtype, which is additionally linked to either an Event or Relationship node. The type field denotes the connector or edge type for the Entities, Event, and Relationship nodes. The edges are one of these: received, evidence_for, sent, NA.\n\n## Filter by type == sent\n\n```{r}\n# Step 1: Filter for type == \"sent\"\nfiltered_edges <- mc3_edges_raw %>%\n  filter(type == \"sent\") %>%\n  count(source) %>%\n  arrange(desc(n)) %>%\n  mutate(source = factor(source, levels = rev(unique(source))))  # descending \n\n# Step 2: Plot\nggplot(filtered_edges, aes(x = source, y = n)) +\n  geom_col(fill = \"navy\") +\n  coord_flip() +\n  labs(\n    title = \"Distribution of 'sent' Edges type by Source\",\n    x = \"Source\",\n    y = \"Count\"\n  ) +\n  theme_minimal()\n```\n:::\n\n**What we understood from the information provided by Vast Challenge on Directional Edges:**\n\n-   For relationship as colleagues node or friends node, the node will have arrows/ edges pointing towards the relationship node.\n\n-   For other relationships and events, the direction would be following the source and target.\n\n# **3) Data Preparation**\n\n## **3.1 Data Cleaning and Wrangling**\n\n::: panel-tabset\n## Cleaning and wrangling nodes\n\n-   convert values in id field into character data type,\n\n-   exclude records with `id` value are na,\n\n-   exclude records with similar id values,\n\n-   exclude `thing_collected` , `time` , `date`, `friendship_type` field, and\n\n-   save the cleaned tibble dataframe into a new tibble datatable called `mc3_nodes_cleaned`.\n\n```{r}\nmc3_nodes_cleaned <- mc3_nodes_raw %>%\n  mutate(id = as.character(id)) %>%\n  filter(!is.na(id)) %>%\n  distinct(id, .keep_all = TRUE) %>%\n  select(-thing_collected, -time, -date, -friendship_type)\n```\n\n## Unique Node Count\n\n```{r, echo=FALSE}\n# Find the number of unique types in each column and sort descending\nunique_counts <- mc3_nodes_cleaned %>%\n  summarise_all(n_distinct) %>%\n  pivot_longer(cols = everything(), names_to = \"column\", values_to = \"unique_count\") %>%\n  arrange(desc(unique_count))  # sort by unique_count in descending order\n\n# Print the result\nprint(unique_counts)\n```\n\n## Cleaning and wrangling edges\n\n-   renamed `source` and `target` fields to `from_id` and `to_id` respectively,\n\n-   converted values in `from_id` and `to_id` fields to character data type,\n\n-   excluded values in `from_id` and `to_id` which not found in the id field of mc3_nodes_cleaned,\n\n-   excluded records whereby `from_id` and/or `to_id` values are missing, and\n\n-   saved the cleaned tibble dataframe and called it mc3_edges_cleaned.\n\n```{r}\nmc3_edges_cleaned <- mc3_edges_raw %>%\n  rename(from_id = source,\n         to_id = target) %>%\n  mutate(across(c(from_id, to_id), as.character)) %>%\n  # Parse to_id to get supertype and sub_type for target nodes (e.g., Event_Communication)\n  separate(to_id, into = c(\"to_id_supertype\", \"to_id_sub_type\", \"to_id_num\"),\n           sep = \"_\", remove = FALSE, fill = \"right\", extra = \"merge\") %>%\n  # Filter to ensure from_id and to_id exist in mc3_nodes_cleaned (prevent orphaned edges)\n  filter(from_id %in% mc3_nodes_cleaned$id,\n         to_id %in% mc3_nodes_cleaned$id) %>%\n  filter(!is.na(from_id), !is.na(to_id))\n\nprint(\"Columns in mc3_edges_cleaned after initial cleaning:\")\nprint(colnames(mc3_edges_cleaned))\nprint(\"Head of mc3_edges_cleaned after initial cleaning:\")\nprint(head(mc3_edges_cleaned))\n\n```\n\n## Unique Edges Count\n\n```{r}\n# Find the number of unique types in each column\nunique_counts <- mc3_edges_cleaned %>%\n  summarise_all(n_distinct) %>%\n  pivot_longer(cols = everything(), names_to = \"column\", values_to = \"unique_count\")\n\n# Print the unique counts for each column\nprint(unique_counts)\n```\n\n## Other preparatory work\n\nNext, code chunk below will be used to create mapping of character id in mc3_nodes_cleaned to row index\n\n```{r}\nnode_index_lookup <- mc3_nodes_cleaned %>%\n  mutate(.row_id = row_number()) %>%\n  select(id, .row_id)\n```\n\nNext, the code chunk below was used to join and convert `from_id` and `to_id` to integer indices. At the same time we also dropped rows with unmatched nodes.\n\n```{r}\nmc3_edges_indexed <- mc3_edges_cleaned %>%\n  left_join(node_index_lookup, by = c(\"from_id\" = \"id\")) %>%\n  rename(from = .row_id) %>%\n  left_join(node_index_lookup, by = c(\"to_id\" = \"id\")) %>%\n  rename(to = .row_id) %>%\n  # Filter out edges where either source or target node was not found\n  filter(!is.na(from) & !is.na(to)) %>%\n  # Select all columns to carry forward to mc3_edges_final\n  select(from, to, id, is_inferred, type, # Original edge attributes\n         from_id, to_id, to_id_supertype, to_id_sub_type, to_id_num # Original IDs and parsed target type\n         )\n```\n\nNext the code chunk below was used to subset nodes to only those referenced by edges.\n\n```{r}\nused_node_indices <- sort(unique(c(mc3_edges_indexed$from, mc3_edges_indexed$to)))\nmc3_nodes_final <- mc3_nodes_cleaned %>%\n  slice(used_node_indices) %>%\n  mutate(new_index = row_number())\n```\n\nWe then used the code chunk below to rebuild lookup from old index to new index.\n\n```{r}\nold_to_new_index <- tibble(\n  old_index = used_node_indices,\n  new_index = seq_along(used_node_indices)\n)\n```\n\nLastly, the code chunk below was used to update edge indices to match new node table.\n\n```{r}\nmc3_edges_final <- mc3_edges_indexed %>%\n  left_join(old_to_new_index, by = c(\"from\" = \"old_index\")) %>%\n  rename(from_new = new_index) %>%\n  left_join(old_to_new_index, by = c(\"to\" = \"old_index\")) %>%\n  rename(to_new = new_index) %>%\n  # Explicitly select all columns that are needed downstream\n  select(from = from_new, to = to_new,\n         id, is_inferred, type,\n         from_id, to_id, to_id_supertype, to_id_sub_type, to_id_num)\n```\n:::\n\n## **3.2 Building the tidygraph object**\n\n::: panel-tabset\n## Build the object-tbl_graph\n\n```{r}\nmc3_graph <- tbl_graph(\n  nodes = mc3_nodes_final,\n  edges = mc3_edges_final,\n  directed = TRUE\n)\n```\n\n## Examining the object\n\n```{r}\nstr(mc3_graph)\n```\n:::\n\n# **4) Knowledge Graphs**\n\n## **VisNetwork**\n\nVisNetwork provides the user to understand relationships through interactivity. For instance:\n\n-   The individual nodes can be selected from the drop-down menu to view its connected nodes and edges.\n\n-   The hover tooltip provides additional details from fields such as content, coordination_type, findings, destination, operational_role, results, and jurisdiction_type based on the related id information from mc3_nodes_final.\n\n## The Graph- VisNetwork\n\n::: no-code-fold\n```{r, echo=FALSE}\n\n# ---- 1. Define styles and legends ----\n\nevent_subtypes <- c(\n  \"Communication\", \"Monitoring\", \"VesselMovement\", \"Assessment\",\n  \"Collaborate\", \"Endorsement\", \"TourActivity\", \"TransponderPing\",\n  \"Harbor Report\", \"Fishing\", \"Criticize\"\n)\n\nrelationship_subtypes <- c(\n  \"Coordinates\", \"AccessPermission\", \"Operates\", \"Colleagues\",\n  \"Suspicious\", \"Reports\", \"Jurisdiction\", \"Unfriendly\", \"Friends\"\n)\n\nnode_legend_colors_plot <- c(\n  \"Person\" = \"#88CCEE\",\n  \"Vessel\" = \"#D55E00\",\n  \"Organization\" = \"#117733\",\n  \"Location\" = \"#AA4499\",\n  \"Group\"= \"#CC79A7\",\n  \"Event\" = \"#DDCC77\",         # type level\n  \"Relationship\" = \"#AF8DC3\"   # type level\n)\n\nnode_legend_shapes_plot <- c(\n  \"Person\" = \"dot\",\n  \"Vessel\" = \"triangle\",\n  \"Organization\" = \"square\",\n  \"Location\" = \"diamond\",\n  \"Group\" = \"circle plus\",\n  \"Event\" = \"star\",              # type level\n  \"Relationship\" = \"square x\"    # type level\n)\n\nSTYLES <- list(\n  node_label_dark = \"black\",\n  font_family = \"Roboto Condensed\"\n)\n\n# ---- 2. Prepare nodes ----\nnodes <- mc3_nodes_final %>%\n  mutate(\n    label = ifelse(is.na(name), id, name),\n    \n    # These parts are for pulling the related data from other fields\n    tooltip_extra = case_when(\n      type == \"Event\" & sub_type == \"Communication\" ~ content,\n      type == \"Event\" & sub_type == \"Monitoring\" ~ findings,\n      type == \"Event\" & sub_type == \"VesselMovement\" ~ destination,\n      type == \"Event\" & sub_type == \"Assessment\" ~ results,\n      type == \"Relationship\" & sub_type == \"Coordinates\" ~ coordination_type,\n      type == \"Relationship\" & sub_type == \"Operates\" ~ operational_role,\n      type == \"Relationship\" & sub_type == \"Jurisdiction\" ~ jurisdiction_type,\n      TRUE ~ NA_character_\n    ),\n    \n    title = paste0(\n      \"<b>\", label, \"</b><br>\",\n      \"Type: \", type, \"<br>\",\n      \"Sub-type: \", sub_type, \"<br>\",\n      ifelse(!is.na(tooltip_extra), paste0(\"<br><b>Details:</b> \", tooltip_extra), \"\")\n    ),\n    \n    # Fallback logic: if sub_type is NA or not in styling list, use type instead\n    group = ifelse(sub_type %in% names(node_legend_colors_plot), sub_type, type)\n  ) %>%\n  select(id, label, group, title) %>%\n  distinct()\n\n# ---- 3. Prepare directed edges (type == \"sent\") ----\n\nedges <- mc3_edges_final %>%\n  filter(from_id %in% nodes$id & to_id %in% nodes$id) %>%\n  select(from = from_id, to = to_id)\n\n# ---- 4. Build visNetwork ----\n\nnet <- visNetwork(nodes, edges, width = \"100%\", height = \"600px\") %>%\n  visEdges(arrows = list(to = list(enabled = TRUE, scaleFactor = 1.5))) %>%\n  visOptions(highlightNearest = TRUE, nodesIdSelection = TRUE) %>%\n  visIgraphLayout(layout = \"layout_with_fr\") %>%\n  visNodes(font = list(\n    size = 14,\n    color = STYLES$node_label_dark,\n    face = STYLES$font_family,\n    vadjust = -15\n  ))\n\n# ---- 5. Apply shape and color per group ----\n\nfor (group_name in names(node_legend_colors_plot)) {\n  net <- net %>% visGroups(\n    groupname = group_name,\n    color = node_legend_colors_plot[[group_name]],\n    shape = node_legend_shapes_plot[[group_name]]\n  )\n}\n# ---- 6. Add legend ----\n\nused_groups <- unique(nodes$group)\n\nlegend_df <- tibble::tibble(\n  label = used_groups,\n  shape = node_legend_shapes_plot[used_groups],\n  color = node_legend_colors_plot[used_groups]\n) %>%\n  distinct(label, .keep_all = TRUE)  # remove duplicates just in case\n\nnet <- net %>% visLegend(\n  addNodes = legend_df,\n  ncol = 2,                         # number of columns\n  position = \"left\",              \n  main = \"Entity (Sub)Types\",      # title\n  useGroups = FALSE                # show custom legend entries\n)\n# ---- 7. Render ----\nnet\n\n```\n:::\n\n```{r, results=FALSE}\n#| code-fold: true\n#| code-summary: \"Show the code\"\n# ---- 1. Define styles and legends ----\n\nevent_subtypes <- c(\n  \"Communication\", \"Monitoring\", \"VesselMovement\", \"Assessment\",\n  \"Collaborate\", \"Endorsement\", \"TourActivity\", \"TransponderPing\",\n  \"Harbor Report\", \"Fishing\", \"Criticize\"\n)\n\nrelationship_subtypes <- c(\n  \"Coordinates\", \"AccessPermission\", \"Operates\", \"Colleagues\",\n  \"Suspicious\", \"Reports\", \"Jurisdiction\", \"Unfriendly\", \"Friends\"\n)\n\nnode_legend_colors_plot <- c(\n  \"Person\" = \"#88CCEE\",\n  \"Vessel\" = \"#D55E00\",\n  \"Organization\" = \"#117733\",\n  \"Location\" = \"#AA4499\",\n  \"Group\"= \"#CC79A7\",\n  \"Event\" = \"#DDCC77\",         # type level\n  \"Relationship\" = \"#AF8DC3\"   # type level\n)\n\nnode_legend_shapes_plot <- c(\n  \"Person\" = \"dot\",\n  \"Vessel\" = \"triangle\",\n  \"Organization\" = \"square\",\n  \"Location\" = \"diamond\",\n  \"Group\" = \"circle plus\",\n  \"Event\" = \"star\",              # type level\n  \"Relationship\" = \"square x\"    # type level\n)\n\nSTYLES <- list(\n  node_label_dark = \"black\",\n  font_family = \"Roboto Condensed\"\n)\n\n# ---- 2. Prepare nodes ----\nnodes <- mc3_nodes_final %>%\n  mutate(\n    label = ifelse(is.na(name), id, name),\n    \n    # These parts are for pulling the related data from other fields\n    tooltip_extra = case_when(\n      type == \"Event\" & sub_type == \"Communication\" ~ content,\n      type == \"Event\" & sub_type == \"Monitoring\" ~ findings,\n      type == \"Event\" & sub_type == \"VesselMovement\" ~ destination,\n      type == \"Event\" & sub_type == \"Assessment\" ~ results,\n      type == \"Relationship\" & sub_type == \"Coordinates\" ~ coordination_type,\n      type == \"Relationship\" & sub_type == \"Operates\" ~ operational_role,\n      type == \"Relationship\" & sub_type == \"Jurisdiction\" ~ jurisdiction_type,\n      TRUE ~ NA_character_\n    ),\n    \n    title = paste0(\n      \"<b>\", label, \"</b><br>\",\n      \"Type: \", type, \"<br>\",\n      \"Sub-type: \", sub_type, \"<br>\",\n      ifelse(!is.na(tooltip_extra), paste0(\"<br><b>Details:</b> \", tooltip_extra), \"\")\n    ),\n    \n    # Fallback logic: if sub_type is NA or not in styling list, use type instead\n    group = ifelse(sub_type %in% names(node_legend_colors_plot), sub_type, type)\n  ) %>%\n  select(id, label, group, title) %>%\n  distinct()\n\n# ---- 3. Prepare directed edges (type == \"sent\") ----\n\nedges <- mc3_edges_final %>%\n  filter(from_id %in% nodes$id & to_id %in% nodes$id) %>%\n  select(from = from_id, to = to_id)\n\n# ---- 4. Build visNetwork ----\n\nnet <- visNetwork(nodes, edges, width = \"100%\", height = \"600px\") %>%\n  visEdges(arrows = list(to = list(enabled = TRUE, scaleFactor = 1.5))) %>%\n  visOptions(highlightNearest = TRUE, nodesIdSelection = TRUE) %>%\n  visIgraphLayout(layout = \"layout_with_fr\") %>%\n  visNodes(font = list(\n    size = 14,\n    color = STYLES$node_label_dark,\n    face = STYLES$font_family,\n    vadjust = -15\n  ))\n\n# ---- 5. Apply shape and color per group ----\n\nfor (group_name in names(node_legend_colors_plot)) {\n  net <- net %>% visGroups(\n    groupname = group_name,\n    color = node_legend_colors_plot[[group_name]],\n    shape = node_legend_shapes_plot[[group_name]]\n  )\n}\n# ---- 6. Add legend ----\n\nused_groups <- unique(nodes$group)\n\nlegend_df <- tibble::tibble(\n  label = used_groups,\n  shape = node_legend_shapes_plot[used_groups],\n  color = node_legend_colors_plot[used_groups]\n) %>%\n  distinct(label, .keep_all = TRUE)  # remove duplicates just in case\n\nnet <- net %>% visLegend(\n  addNodes = legend_df,\n  ncol = 2,                         # number of columns\n  position = \"left\",              \n  main = \"Entity (Sub)Types\",      # title\n  useGroups = FALSE                # show custom legend entries\n)\n# ---- 7. Render ----\nnet\n\n```\n\n# **5) Further Checking and Cleaning Data**\n\n::: panel-tabset\n## 5.1 Checking Nodes\n\nCheck if mapping is correct for type and sub_type.\n\n```{r}\nmc3_nodes_cleaned %>%\n  group_by(type, sub_type) %>%\n  summarize(count = n()) %>%\n  arrange(-count) %>%\n  kable()\n```\n\n## 5.2.1 Cleaning Edges\n\n```{r}\n# Split the 'from_id' column\nmc3_edges_cleaned <- mc3_edges_cleaned %>%\n  separate(from_id, into = c(\"from_id_supertype\", \"from_id_sub_type\", \"from_id_id\"), sep = \"_\", remove = FALSE, extra = \"drop\")\n\n# Split the 'target' column into \nmc3_edges_cleaned <- mc3_edges_cleaned %>%\n  separate(to_id, into = c(\"to_id_supertype\", \"to_id_sub_type\",\"to_id_id\"), sep = \"_\", remove = FALSE, extra = \"drop\")\n\n# Find the number of unique types in each column\nunique_counts <- mc3_edges_cleaned %>%\n  summarise_all(n_distinct) %>%\n  pivot_longer(cols = everything(), names_to = \"column\", values_to = \"unique_count\")\n\n# Print the unique counts for each column\nprint(unique_counts)\n```\n\n## 5.2.2 Checking Edges\n\n```{r}\n# Check the mapping\nmc3_edges_cleaned %>%\n  group_by(from_id_supertype, from_id_sub_type) %>%\n  summarize(count = n()) %>%\n  arrange(-count) %>%\n  kable()\n\n# Check the mapping\nmc3_edges_cleaned %>%\n  group_by(to_id_supertype, to_id_sub_type) %>%\n  summarize(count = n()) %>%\n  arrange(-count) %>%\n  kable()\n```\n\n**Under Event-Communication types:** The edges target type and target subtypes matches the count of 584 for node to_id_supertype and node to_id_sub_type. However, there were only 581 count for content within the original node file. We then looked into duplicates.\n\n## 5.3 Checking for Duplicates\n\n```{r}\n# checking for duplicates\nduplicate_values1 <- mc3_nodes_cleaned %>%\n  count(content) %>%\n  filter(n > 1)\n\n# View duplicates\nprint(duplicate_values1)\n```\n\nThere were 4 duplicates within the content column. Upon checking the original data, one was the sender and the other was the receiver who received the same content. We left the data as it was.\n:::\n\n# **6) Tackling Question 1**\n\n## 6.1 All Communications\n\nSince the content column determines the important events and relationships, the communication sub_type in the original nodes file would be useful. Thus, the communication to_id_sub_type and from_id_sub_type from the original edges file will also be useful.\n\n### 6.1.1 Creation of a timeline of all radio communications in table format\n\n::: panel-tabset\n## The Table\n\n```{r, echo=FALSE}\n# --- 1. Extract All Communications ---\n# Logic: Sender (source) --sent--> Event_Communication (target) --received--> Recipient (target)\n# This extracts all communication events\n\n# --- 2. Clean and Prepare Nodes ---\nmc3_nodes_cleaned <- mc3_nodes_raw %>%\n  mutate(id = as.character(id)) %>%\n  filter(!is.na(id)) %>%\n  distinct(id, .keep_all = TRUE) %>%\n  # Rename 'type' to 'supertype' to reduce confusion with communication type\n  rename(supertype = type) %>%\n  # Select only columns that are needed and are consistently present\n  select(id, name, sub_type, content, timestamp) \n\n# --- 3. Clean and Prepare Edges ---\n# Rename 'type' in edges to 'edge_type' to avoid conflict with node 'supertype'\nmc3_edges_cleaned <- mc3_edges_raw %>%\n  rename(from_id = source,\n         to_id = target,\n         edge_type = type) %>% # Renamed 'type' to 'edge_type'\n  mutate(across(c(from_id, to_id), as.character)) %>%\n  # Filter out any edges where from_id or to_id are not in cleaned nodes\n  filter(from_id %in% mc3_nodes_cleaned$id,\n         to_id %in% mc3_nodes_cleaned$id)\n\nother_communications_df <- mc3_edges_cleaned %>%\n  filter(edge_type == \"sent\") %>% # Start with 'sent' edges\n  # Join with nodes to get content and timestamp of the Event_Communication node\n  left_join(mc3_nodes_cleaned %>% select(id, content, timestamp),\n            by = c(\"to_id\" = \"id\")) %>%\n  rename(event_id = to_id, event_content = content, event_timestamp = timestamp) %>%\n  # Now, find the recipient of this communication event\n  left_join(mc3_edges_cleaned %>%\n              filter(edge_type == \"received\") %>%\n              select(event_id_match = from_id, recipient_id = to_id),\n            by = c(\"event_id\" = \"event_id_match\")) %>%\n  # Join with nodes to get the sender's name and sub_type\n  left_join(mc3_nodes_cleaned %>% select(id, name, sub_type),\n            by = c(\"from_id\" = \"id\")) %>%\n  rename(sender_id_actual = from_id, sender_name = name, sender_sub_type = sub_type) %>%\n  # Join with nodes to get the recipient's name and sub_type\n  left_join(mc3_nodes_cleaned %>% select(id, name, sub_type),\n            by = c(\"recipient_id\" = \"id\")) %>%\n  rename(recipient_name = name, recipient_sub_type = sub_type) %>%\n  # Select and rename final columns for all communications\n  select(\n    communication_type = edge_type, # This will be \"sent\" from original filter\n    sender_id = sender_id_actual,\n    sender_name,\n    sender_sub_type,\n    recipient_id,\n    recipient_name,\n    recipient_sub_type,\n    event_id,\n    content = event_content,\n    timestamp = event_timestamp\n  ) \n\n# create a timeline visualization or inspect content.\nprint(knitr::kable(head(other_communications_df %>%\n                          select(timestamp, sender_name, \n                                 recipient_name, content), 10),\n                   format = \"markdown\", align = \"l\"))\n```\n\n## The Code\n\n``` r\n# --- 1. Extract All Communications ---\n# Logic: Sender (source) --sent--> Event_Communication (target) --received--> Recipient (target)\n# This extracts all communication events\n\n# --- 2. Clean and Prepare Nodes ---\nmc3_nodes_cleaned <- mc3_nodes_raw %>%\n  mutate(id = as.character(id)) %>%\n  filter(!is.na(id)) %>%\n  distinct(id, .keep_all = TRUE) %>%\n  # Rename 'type' to 'supertype' to reduce confusion with communication type\n  rename(supertype = type) %>%\n  # Select only columns that are needed and are consistently present\n  select(id, name, sub_type, content, timestamp) \n\n# --- 3. Clean and Prepare Edges ---\n# Rename 'type' in edges to 'edge_type' to avoid conflict with node 'supertype'\nmc3_edges_cleaned <- mc3_edges_raw %>%\n  rename(from_id = source,\n         to_id = target,\n         edge_type = type) %>% # Renamed 'type' to 'edge_type'\n  mutate(across(c(from_id, to_id), as.character)) %>%\n  # Filter out any edges where from_id or to_id are not in cleaned nodes\n  filter(from_id %in% mc3_nodes_cleaned$id,\n         to_id %in% mc3_nodes_cleaned$id)\n\nother_communications_df <- mc3_edges_cleaned %>%\n  filter(edge_type == \"sent\") %>% # Start with 'sent' edges\n  # Join with nodes to get content and timestamp of the Event_Communication node\n  left_join(mc3_nodes_cleaned %>% select(id, content, timestamp),\n            by = c(\"to_id\" = \"id\")) %>%\n  rename(event_id = to_id, event_content = content, event_timestamp = timestamp) %>%\n  # Now, find the recipient of this communication event\n  left_join(mc3_edges_cleaned %>%\n              filter(edge_type == \"received\") %>%\n              select(event_id_match = from_id, recipient_id = to_id),\n            by = c(\"event_id\" = \"event_id_match\")) %>%\n  # Join with nodes to get the sender's name and sub_type\n  left_join(mc3_nodes_cleaned %>% select(id, name, sub_type),\n            by = c(\"from_id\" = \"id\")) %>%\n  rename(sender_id_actual = from_id, sender_name = name, sender_sub_type = sub_type) %>%\n  # Join with nodes to get the recipient's name and sub_type\n  left_join(mc3_nodes_cleaned %>% select(id, name, sub_type),\n            by = c(\"recipient_id\" = \"id\")) %>%\n  rename(recipient_name = name, recipient_sub_type = sub_type) %>%\n  # Select and rename final columns for all communications\n  select(\n    communication_type = edge_type, # This will be \"sent\" from original filter\n    sender_id = sender_id_actual,\n    sender_name,\n    sender_sub_type,\n    recipient_id,\n    recipient_name,\n    recipient_sub_type,\n    event_id,\n    content = event_content,\n    timestamp = event_timestamp\n  ) \n\n# create a timeline visualization or inspect content.\nprint(knitr::kable(head(other_communications_df %>%\n                          select(timestamp, sender_name, \n                                 recipient_name, content), 10),\n                   format = \"markdown\", align = \"l\"))\n```\n:::\n\n### 6.1.2 Static Chord Diagram- All Communicators\n\n```{r, fig.width=10, fig.height=8, echo=FALSE, message=FALSE, warning=FALSE}\n\n# --- Step 1: Build communication matrix ---\nsent_df <- other_communications_df %>%\n  filter(communication_type == \"sent\") %>%\n  count(sender_name, recipient_name, name = \"sent\")\n\nreceived_df <- other_communications_df %>%\n  filter(communication_type == \"received\") %>%\n  count(sender_name = recipient_name, recipient_name = sender_name, name = \"received\")\n\ncombined_df <- full_join(sent_df, received_df, by = c(\"sender_name\", \"recipient_name\")) %>%\n  mutate(across(c(sent, received), ~replace_na(., 0)),\n         total = sent + received)\n\ncomm_matrix <- xtabs(total ~ sender_name + recipient_name, data = combined_df)\n\n# --- Step 2: Assign color per entity sub-type ---\ntype_lookup <- other_communications_df %>%\n  select(name = sender_name, type = sender_sub_type) %>%\n  bind_rows(other_communications_df %>% select(name = recipient_name, type = recipient_sub_type)) %>%\n  distinct(name, .keep_all = TRUE)\n\n# Define pastel Set2 colors for each type\ntype_colors_palette <- brewer.pal(n = 4, name = \"Set2\")\nnames(type_colors_palette) <- c(\"Person\", \"Organization\", \"Vessel\", \"Location\")\n\n# Map to nodes in the matrix\ngrid_colors <- type_colors_palette[type_lookup$type]\nnames(grid_colors) <- type_lookup$name\ngrid_colors <- grid_colors[rownames(comm_matrix)]\n\n# --- Step 3: Plot chord diagram ---\ncircos.clear()\npar(mar = c(4, 2, 8, 10))  # bottom, left, top, right\n\nchordDiagram(\n  comm_matrix,\n  grid.col = grid_colors,\n  transparency = 0.25,\n  annotationTrack = \"grid\",\n  preAllocateTracks = list(track.height = 0.1)\n)\n\n# Add readable sector names\ncircos.trackPlotRegion(\n  track.index = 1,\n  panel.fun = function(x, y) {\n    name <- get.cell.meta.data(\"sector.index\")\n    circos.text(\n      x = mean(get.cell.meta.data(\"xlim\")),\n      y = 0,\n      labels = str_wrap(name, 10),\n      facing = \"clockwise\",\n      niceFacing = TRUE,\n      adj = c(0, 0.5),\n      cex = 0.6\n    )\n  },\n  bg.border = NA\n)\n\n# --- Step 4: Title, subtitle ---\ntitle(\n  main = \"Chord Diagram of Communication Flows\",\n  cex.main = 1.6,\n  font.main = 2,\n  line = 5\n)\nmtext(\"Each ribbon shows volume of sent + received messages\", side = 3, line = 3, cex = 1, col = \"gray30\")\nmtext(\"Note. Group subtype is excluded from this diagram\", side = 1, line = 3, cex = 0.8, col = \"gray40\")\n\n# --- Step 5: Custom Legend ---\nlegend_items <- names(type_colors_palette)\nlegend(\n  x = 1.1, y = 0.85, legend = legend_items,\n  fill = type_colors_palette,\n  border = \"gray30\",\n  bty = \"n\",\n  cex = 0.7,\n  pt.cex = 0.7,\n  title = \"Entity Sub-Type\" \n\n)\n\n```\n\n**Findings:**\n\nThe thickness of each ribbon (chord) represents the magnitude of the relationship. A thicker ribbon represents more frequent communications (sent + received) between a sender and recipient.\n\nHere, we have an overview of paired communicators who have higher frequencies. We also can see the links between communicators. These are the entities who communicated frequently with others that we might want to focus on:\n\n-   Person: The Intern, The Lookout, Clepper Jensen, Davis, Miranda Jordan, Mrs. Money.\n\n-   Organization: Oceanus City Council, Green Guardian\n\n-   Vessel: Reef Guardian, Neptune, Mako, Remora\n\n-   Location: Himark Habor\n\n-   Group: N/A\n\n### 6.1.3 Heatmap of Correspondences\n\n::: panel-tabset\n## Heatmap\n\n```{r, echo=FALSE}\n# Step 1: Count interactions\nadj_df <- other_communications_df %>%\n  count(sender_name, recipient_name, name = \"count\")\n\n# Step 2: Compute total sent and received counts\nsender_order <- adj_df %>%\n  group_by(sender_name) %>%\n  summarise(total_sent = sum(count)) %>%\n  arrange(desc(total_sent)) %>%\n  pull(sender_name)\n\nrecipient_order <- adj_df %>%\n  group_by(recipient_name) %>%\n  summarise(total_received = sum(count)) %>%\n  arrange(desc(total_received)) %>%\n  pull(recipient_name)\n\n# Step 3: Reorder factor levels\nadj_df <- adj_df %>%\n  mutate(\n    sender_name = factor(sender_name, levels = sender_order),\n    recipient_name = factor(recipient_name, levels = recipient_order)\n  )\n\n# Step 4: Plot heatmap\nggplot(adj_df, aes(x = recipient_name, y = sender_name, fill = count)) +\n  geom_tile(color = \"white\") +\n  scale_fill_gradient(low = \"white\", high = \"navyblue\") +\n  labs(\n    title = \"Sender-Recipient Communication Heatmap\",\n    subtitle = \"Top communicators sorted to bottom-left\",\n    x = \"Recipient\",\n    y = \"Sender\",\n    fill = \"Messages\"\n  ) +\n  theme_minimal(base_size = 10) +\n  theme(\n    axis.text.x = element_text(angle = 45, hjust = 1),\n    plot.title = element_text(size = 12, face = \"bold\"),\n    plot.subtitle = element_text(size = 10),\n    panel.grid = element_blank()\n  )\n```\n\n## The Code\n\n``` r\n# Step 1: Count interactions\nadj_df <- other_communications_df %>%\n  count(sender_name, recipient_name, name = \"count\")\n\n# Step 2: Compute total sent and received counts\nsender_order <- adj_df %>%\n  group_by(sender_name) %>%\n  summarise(total_sent = sum(count)) %>%\n  arrange(desc(total_sent)) %>%\n  pull(sender_name)\n\nrecipient_order <- adj_df %>%\n  group_by(recipient_name) %>%\n  summarise(total_received = sum(count)) %>%\n  arrange(desc(total_received)) %>%\n  pull(recipient_name)\n\n# Step 3: Reorder factor levels\nadj_df <- adj_df %>%\n  mutate(\n    sender_name = factor(sender_name, levels = sender_order),\n    recipient_name = factor(recipient_name, levels = recipient_order)\n  )\n\n# Step 4: Plot heatmap\nggplot(adj_df, aes(x = recipient_name, y = sender_name, fill = count)) +\n  geom_tile(color = \"white\") +\n  scale_fill_gradient(low = \"white\", high = \"navyblue\") +\n  labs(\n    title = \"Sender-Recipient Communication Heatmap\",\n    subtitle = \"Top communicators sorted to bottom-left\",\n    x = \"Recipient\",\n    y = \"Sender\",\n    fill = \"Messages\"\n  ) +\n  theme_minimal(base_size = 10) +\n  theme(\n    axis.text.x = element_text(angle = 45, hjust = 1),\n    plot.title = element_text(size = 12, face = \"bold\"),\n    plot.subtitle = element_text(size = 10),\n    panel.grid = element_blank()\n  )\n```\n:::\n\n**Findings:**\n\nAfter extraction of the entities who communicated frequently (from the Static Chord Diagram), we tabled who they communicated with by using the heatmap. E.g. Name1 communicated with Name2.\n\n+----------------+----------------------+-----------------------------------------------------------------------------------------------------------------------------------------------------------+\n| Name 1 Subtype | Name1                | Name2                                                                                                                                                     |\n+================+======================+===========================================================================================================================================================+\n| Person         | The Intern           | The Lookout, Mrs. Money                                                                                                                                   |\n+----------------+----------------------+-----------------------------------------------------------------------------------------------------------------------------------------------------------+\n| Person         | Clepper Jensen       | Miranda Jordan                                                                                                                                            |\n+----------------+----------------------+-----------------------------------------------------------------------------------------------------------------------------------------------------------+\n| Person         | Davis                | Neptune                                                                                                                                                   |\n+----------------+----------------------+-----------------------------------------------------------------------------------------------------------------------------------------------------------+\n| Person         | Mrs. Money           | The Intern, The Middleman, Boss                                                                                                                           |\n+----------------+----------------------+-----------------------------------------------------------------------------------------------------------------------------------------------------------+\n| Vessel         | Mako                 | Remora, Green Guardians, Oceanus City Council, Neptune, Reef Guardians, Himark Harbor, Davis, Sentinel, Paackland Habor, Samantha Blake, Serenity, Osprey |\n+----------------+----------------------+-----------------------------------------------------------------------------------------------------------------------------------------------------------+\n| Vessel         | Remora               | Mako, Neptune, Himark Habor, Davis, Paackland Harbor, V. Miesel Shipping, Marlin, Small Fry                                                               |\n+----------------+----------------------+-----------------------------------------------------------------------------------------------------------------------------------------------------------+\n| Vessel         | Neptune              | Mako, Himark Habor, Remora, Mrs Money, V. Miesel Shipping, Nadia, Serenity                                                                                |\n+----------------+----------------------+-----------------------------------------------------------------------------------------------------------------------------------------------------------+\n| Vessel         | Reef Guardian        | Green Guardians, Oceanus City Council, Mako, Paackland Harbor, EcoVigil, Serenity, Defender                                                               |\n+----------------+----------------------+-----------------------------------------------------------------------------------------------------------------------------------------------------------+\n| Organization   | Green Guardian       | Green Guardians, Oceanus City Council, The Lookout, Sentinel, Horizon                                                                                     |\n+----------------+----------------------+-----------------------------------------------------------------------------------------------------------------------------------------------------------+\n| Organization   | Oceanus City Council | Green Guardians, Reef Guardians, Himark Harbor, Sentinel, Paackland Harbor, Liam Thorne, Samantha Blake, Haacklee Harbor                                  |\n+----------------+----------------------+-----------------------------------------------------------------------------------------------------------------------------------------------------------+\n| Location       | Himark Habor         | Oceanus City Council, Mako, Serenity, Marlin                                                                                                              |\n+----------------+----------------------+-----------------------------------------------------------------------------------------------------------------------------------------------------------+\n\n# **7) Tackling Question 2**\n\nIn section 7 and 8, we attempted to find answers to question 2 and 4, as we explored other interesting information.\n\n# Question 2a)\n\n### 7.1.2 Unique count from each sender subtype\n\n::: panel-tabset\n## Unique Count\n\n```{r, echo=FALSE}\nsender_names_by_type <- other_communications_df %>%\n  group_by(sender_sub_type) %>%\n  summarise(\n    unique_senders = n_distinct(sender_name),\n    sender_names = paste(sort(unique(sender_name)), collapse = \", \")\n  ) %>%\n  arrange(desc(unique_senders))  # sort from largest to smallest\n\n# View the table\nprint(sender_names_by_type)\n```\n\n## The Code\n\n``` r\nsender_names_by_type <- other_communications_df %>%\n  group_by(sender_sub_type) %>%\n  summarise(\n    unique_senders = n_distinct(sender_name),\n    sender_names = paste(sort(unique(sender_name)), collapse = \", \")\n  ) %>%\n  arrange(desc(unique_senders))  # sort from largest to smallest\n\n# View the table\nprint(sender_names_by_type)\n```\n\nThere were no Group sub-type as confirmed by this filtered table.\n:::\n\n## 7.2 People and Vessels\n\nDue to a large number of entity subtypes as people and vessels in 7.1.4, we then looked into the characters' and vessel's identity and their actual communication content.\n\n### 7.2.1 Filter by Vessel and Person only\n\n::: panel-tabset\n## The Code\n\n```{r}\nperson_vessel_df <- other_communications_df %>%\n  filter(\n    (sender_sub_type == \"Person\" & recipient_sub_type == \"Vessel\") |\n    (sender_sub_type == \"Vessel\" & recipient_sub_type == \"Person\") |\n    (sender_sub_type == \"Person\" & recipient_sub_type == \"Person\") |\n    (sender_sub_type == \"Vessel\" & recipient_sub_type == \"Vessel\")\n  )\n```\n:::\n\n### 7.2.2 Plotted Timeline- People & Vessels\n\n```{r}\n#| code-fold: true\n#| code-summary: \"Show the code\"\n# --- FACTORING and DATETIME CLEANING ---\nperson_vessel_df_for_plot <- person_vessel_df %>%\n  mutate(\n    timestamp = as.POSIXct(timestamp),\n    comm_date = as.Date(timestamp),\n    comm_time_of_day = hms::as_hms(format(timestamp, \"%H:%M:%S\")),\n    sender_sub_type = factor(sender_sub_type, levels = c(\"Person\", \"Vessel\")),\n    communicating_pair_sorted = paste(pmin(sender_name, recipient_name), pmax(sender_name, recipient_name), sep = \" & \")\n  )\n\n# --- WRAPPING CONTENT AND TOOLTIP ---\nplot_data1 <- person_vessel_df_for_plot %>%\n  mutate(\n    timestamp = as.POSIXct(timestamp),\n    date = as.Date(timestamp),\n    time = format(timestamp, \"%H:%M:%S\"),\n    wrapped_content = str_wrap(content, width = 50),\n    tooltip_text = paste0(\n      \"<b>Date:</b> \", date, \"<br>\",\n      \"<b>Time:</b> \", time, \"<br>\",\n      \"<b>From:</b> \", sender_name, \"<br>\",\n      \"<b>To:</b> \", recipient_name, \"<br>\",\n      \"<b>Event_id:</b> \", event_id, \"<br><br>\",\n      \"<b>Content:</b><br>\", wrapped_content\n    )\n  )\n\n# Plot\np <-ggplot(plot_data1, aes(x = comm_date, y = comm_time_of_day)) +\n  geom_point(aes(\n    color = sender_id,\n    shape = sender_sub_type,\n    text = tooltip_text\n  ),show.legend = c(color = TRUE, shape = FALSE), \n  size = 2, alpha = 0.7) +\n  scale_shape_manual(values = c(\"Person\" = 16, \"Vessel\" = 17)) +\n  facet_wrap(~ sender_sub_type, ncol = 1, scales = \"fixed\") +\n  scale_y_time(\n    limits = hms::as_hms(c(\"08:00:00\", \"14:00:00\")),  # reversed to show time top-to-bottom\n    breaks = hms::as_hms(c(\"08:00:00\", \"09:00:00\", \"10:00:00\", \"11:00:00\", \"12:00:00\", \"13:00:00\", \"14:00:00\")),\n    labels = c(\"08:00\", \"09:00\", \"10:00\", \"11:00\", \"12:00\", \"13:00\", \"14:00\")\n)+\n  scale_x_date(\n  date_breaks = \"1 day\",\n  date_labels = \"%d %b\"\n)+\n  labs(\n    title = \"Communication Events Over Time (Sender's Perspective)\",\n    x = \"Date\",\n    y = \"Time of Day\",\n    color = \"Sender (subtype, name)\"\n  ) +\n  theme_grey() +\n  theme(\n    axis.text.y = element_text(size = 6),\n    axis.title.y = element_text(size = 7),\n    axis.ticks.y = element_line(),\n    axis.text.x = element_text(size = 6, angle = 45, hjust = 1),\n    axis.title.x = element_text(margin = margin(t = 8), size = 7),\n    panel.spacing = unit(0.5, \"lines\"),  # Applies to both x and y spacing\n    strip.text = element_text(size = 8, face = \"bold\"),\n    legend.position = \"bottom\",\n    legend.text = element_text(size = 6),\n    legend.title = element_blank()\n  )\n\n# --- Convert to interactive plot ---\nggplotly(p, tooltip = \"tooltip_text\")\n```\n\n#### 7.2.2.1 Findings on People/ Vessels:\n\n-   Core logic:\n\n    -   If two names appear as sender and recipient in the same message, they cannot belong to the same person — i.e., they're not aliases of each other.\n\n    -   If two names sent a message at the exact time, they cannot belong to the same person.\n\n    -   For instance, if Nadia sent a message to The Accountant, they would not be the same individual. If Nadia sent a message at 10am to The Accountant and The Lookout also sent a message at 10am to The Intern, Nadia and The Lookout cannot be the same person.\n\n-   Select only The Accountant, Mrs. Money, Elise: We see close timings between Mrs. Money and Elise on 8 Oct, and 10 Oct. These were on the same topic. Elise then disappears from radar on 10 Oct. She reappears as The Accountant and Mrs. Money on 11 Oct on the same topic and remains only as The Accountant till 14 Oct.\n\n-   Select only Liam and The Middleman: The Middleman disappeared on 7 Oct and appeared as Liam on 8 Oct. On 11 Oct Mrs. Money asked The Middleman if anything was found by conservation vessels. On the same day, Liam reappeared and replied Elise that nothing was found by them.\n\n-   Select only The Boss and Nadia: The Boss disappeared on 5 Oct and reappeared as Nadia on 8 Oct. Likely the same person.\n\n-   Select only Small Fry and Rodriguez: on 2 Oct Rodriguez corresponded with Remora and Mako on meeting at the slip #14. It happened again on 14 Oct as he took on dual roles and responded to the same message with different names. Likely the same person.\n\n-   Select only The Lookout and Sam: on 7 Oct Sam asked Kelly to get information on who authorized the permit. 2 minutes later, The Lookout (Kelly) responded to The Intern (Sam), that it was signed by Jensen from City Council.\n\n-   Seawatch only appeared on 10 Oct but Horizon talked to Seawatch on 8 Oct. Therefore, some other entity is Seawatch before or during 8 Oct. Defender told Seawatch on 3 Oct at 8.39am that it increased its patrol and informed Seawatch to maintain vigilance. The Lookout (Seawatch) responded to Sentinel (Defender) at 8.41am that it acknowledged the need for vigilance.\n\n-   After getting a general idea of the characters' involvement, we looked at the interactions in 7.3.\n\n## 7.3 Discussion/ Interpretation on all communications:\n\nFrom the interactive plot, we were able to select certain names of individuals and/or vessels from the legend and read their conversations. We segmented entities based on our first cut of observations of the following people or vessels and rated them as suspicious or non-suspicious. We tabled out what we have learnt with variables: Sender, Recipient, Commonalities, Rationale, Suspicious?, Date, Event Id, in Section 7.3.1 and 7.3.2.\n\n### 7.3.1 Suspicious Conversations\n\n```{r}\n#| code-fold: true\n#| code-summary: \"Show the code\"\nlibrary(reactable)\nlibrary(dplyr)\nlibrary(stringr)\nlibrary(tidyr) # For separate_rows, if needed for 'Event Id' later\n\n# Create the data frame using tribble, consolidating multi-line entries\ndf_new_data <- tribble(\n  ~Sender, ~Recipient, ~Commonalities, ~Rationale, ~Suspicious_Status, ~Date, ~Event_Id,\n  \"The Lookout (Person)\", \"The Intern (Person)\", \"Mako\", \"Jensen from City Council signed a permit to set a corridor for Mako vessel.\", \"Jensen\", \"5/10\", \"371\",\n  \"Glitters Team aka. Sailor Shift Team\", \"Boss (Person)\", \"Permit, Commissioner Torres\", \"Glitters thanked their Boss who got Commissioner Torres to sign off the permit\", \"Nadia aka The Boss\", \"6/10\", \"389\",\n  \"Remora (Vessel)\", \"Sailor Shift Team aka. Glitters Team\", \"Permit, Commissioner Torres\", \"Davis thanked Nadia who got Commissioner Torres to sign off the permit\", \"Nadia aka The Boss\", \"6/10\", \"388\",\n  \"Mrs. Money (Person)\", \"Mako (Vessel); Neptune (Vessel)\", \"Mako, Remora, Neptune\", \"Mrs. Money is the Financial Controller who provides the payment protocols for Mako and Remora's captions. She also provides the encryption protocols and transfer devices. Mrs. Money coordinates payment protocols for Remora and Mako captains\", \"Elise aka. Mrs. Money\", \"7/10\", \"458 and 464\",\n  \"Neptune/ Neptune Captain\", \"Elise aka. Mrs. Money (Person)\", \"Remora, Mako\", \"Neptune told her to coordinate payment protocols for Remora and Mako captains\", \"Elise aka. Mrs. Money\", \"7/10\", \"456 and 518\",\n  \"Remona (Vessel)\", \"Rodriquez (Person)\", \"Sailor Shift\", \"Nemo Reef selected for Sailor Shift's music shoot.; Nadia personally handled permits for Nemo Reefs after meeting Davis.\", \"Both\", \"2/10\", \"153 and 328\",\n  \"Remona (Vessel)\", \"Nadia (Person)\", \"Delta 3, Sailor Shift\", \"Tourism facade created by Remona and awaiting installation of underwater lighting placements at Nemo Reef.\", \"Both\", \"14/10\", \"943\",\n  \"Davis (Person)\", \"Mako (Vessel)\", \"Rodriquez, Nadia, Neptune\", \"Rodriquez will help with logistics.\", \"Both\", \"2/10\", \"115\",\n  \"Davis (Person)\", \"Mako (Vessel)\", \"Rodriquez, Nadia, Neptune\", \"V. Miesel's Marine Research Permit is CR-7844. There is a 5 day deadline from 8 Oct.\", \"Both\", \"8/10\", \"548\",\n  \"Davis (Person)\", \"Mako (Vessel)\", \"Rodriquez, Nadia, Neptune\", \"V. Miesel approved their operational authority.\", \"Both\", \"12/10\", \"802\",\n  \"Davis (Person)\", \"Remona (Vessel)\", \"Client\", \"Davis wants to maintain client's privacy with Paackland Harbour.\", \"Both, and also Paackland Harbour\", \"4/10\", \"282\",\n  \"Mako (Vessel)\", \"Davis (Person)\", \"Permit CR-7844, Boss\", \"Davis is a captain.\", \"Both\", \"5/10\", \"349\",\n  \"Mako (Vessel)\", \"Boss (Person)\", \"Boss, Samantha\", \"Oceanus Council approved Mako's departure to Nemo Reef with minimal documentation.\", \"Oceanus Council\", \"5/10\", \"365\",\n  \"Boss (Person)\", \"Marko (Vessel)\", \"Mission, Boss\", \"Informed Marko to abort mission as conservation patrols are tracking it\", \"Both\", \"4/10\", \"316\",\n  \"Small Fry aka Rodriquez (Person)\", \"Remora (Vessel, Mako (Vessel)\", \"Slip #14, Glitters Team, Sailor Team\", \"Mako asked Rodriquez when he could come by slip #14.; Small Fry replied he would come by slip #14 in 30 minutes time.; Small Fry surprised that Glitters Team filing for paperwork downtown for protected area of Nemo Reef.\", \"Both\", \"2/10\", \"142, 143 and 156\",\n  \"Neptune\", \"Nadia (Person); Neptune (Vessel)\", \"Equipment specs\", \"Neptune asked to meet Nadia at 0600 and confirm the equipment specs approved by Elise.; Nadia confirmed the time with Neptune and agreed to show her reviewed equipment specs from The Accountant.\", \"Both; Elise aka The Accountant\", \"8/10\", \"537 and 738\",\n  \"Knowles (Vessel)\", \"Davis (Person)\", \"Boss\", \"Instructed by Mako to provide equipment transfer.\", \"Both\", \"14/10\", \"1001 and 1003\",\n  \"Sentinel(Vessel)\", \"Mako (Vessel)\", \"Permit\", \"Mako told Sentinel it was operating under NR-1045.\", \"Mako\", \"7/10\", \"467\",\n  \"Mako (Vessel)\", \"Sentinel (Vessel)\", \"Permit\", \"Sentinel asked the reasons for Mako operating under permit NR-1045\", \"Mako\", \"8/10\", \"574\",\n  \"Mako (Vessel)\", \"Sentinel (Vessel)\", \"Permit\", \"Mako told Sentinel it was operating under permit CR-7844 (marine equipment transport) not NR-1045\", \"Mako\", \"8/10\", \"575\",\n  \"Miranda (Person)\", \"Clepper Jesen (Person)\", \"Rodriquez\", \"Rodriquez filed for permits under Sailor Shifts Team for 2 commercial and 1 private yatch to perform environmental sampling.\", \"Rodriquez is suspicious. The communicators are not suspicious.\", \"2/10\", \"130\",\n  \"Miranda (Person)\", \"Clepper Jesen (Person)\", \"Rodriquez\", \"Rodriquez is connected to a mining consortium with previous violations in protected areas.\", \"Rodriquez is suspicious. The communicators are not suspicious\", \"2/10\", \"134\",\n  \"Miranda (Person)\", \"Clepper Jesen (Person)\", \"Rodriquez\", \"Rodriquez is connected to Council Knowles and they are related to V. Miesel Shipping which is possibly a shell company which has vessels.\", \"Rodriquez is suspicious. The communicators are not suspicious.\", \"3/10\", \"201\",\n  \"Miranda (Person)\", \"Clepper Jesen (Person)\", \"Rodriquez is suspicious\", \"Council Knowles' brother-in-law owns the offshore bank account to V. Miesel Shipping. The company is involved in rare earth extraction.\", \"Rodriquez is suspicious. The communicators are not suspicious.\", \"3/10\", \"204\",\n  \"Miranda (Person)\", \"Clepper Jesen (Person)\", \"Rodriquez is suspicious\", \"Knowles accepted cash from Rodriquez.\", \"Rodriquez is suspicious. The communicators are not suspicious.\", \"3/10\", \"206\"\n)\n\n# Process the data (primarily for consistent whitespace and Event_Id splitting if necessary)\ndf_processed <- df_new_data %>%\n  # Standardize delimiters and remove excess whitespace across all character columns.\n  mutate(\n    across(where(is.character), ~ str_replace_all(.x, \"[,\\n]+\", \", \") %>% str_trim())\n  ) %>%\n  # For Event_Id, replace \"and\" with comma and then separate rows if needed\n  mutate(Event_Id = str_replace_all(Event_Id, \" and \", \", \")) %>%\n  mutate(across(where(is.character), str_trim)) %>%\n  mutate(Event_Id = as.character(Event_Id)) # Ensure Event_Id is character\n\n# Create the reactable table\nreactable(\n  df_processed,\n  filterable = TRUE,\n  searchable = TRUE,\n  paginationType = \"numbers\",\n  defaultPageSize = 5,\n  showPageSizeOptions = TRUE,\n  pageSizeOptions = c(5, 10, 20, 50, 100),\n  striped = TRUE,\n  highlight = TRUE,\n  columns = list(\n    Sender = colDef(name = \"Sender\", minWidth = 120),\n    Recipient = colDef(name = \"Recipient\", minWidth = 120),\n    Commonalities = colDef(name = \"Commonalities\", minWidth = 150),\n    Rationale = colDef(name = \"Rationale\", minWidth = 300),\n    # Rename Suspicious_Status for display\n    Suspicious_Status = colDef(name = \"Suspicious?\", minWidth = 150),\n    # Date column as text, no special date sorting\n    Date = colDef(name = \"Date\", minWidth = 80, align = \"center\"),\n    Event_Id = colDef(name = \"Event Id\", minWidth = 80, align = \"center\")\n  ),\n  theme = reactableTheme(\n    borderColor = \"#dfe2e5\",\n    stripedColor = \"#f6f8fa\",\n    highlightColor = \"#f0f5f9\",\n    cellPadding = \"8px 12px\",\n    style = list(fontFamily = \"Verdana, Geneva, sans-serif\", fontSize = \"14px\"),\n    headerStyle = list(\n      \"&.rt-th:hover\" = list(backgroundColor = \"#e0e6eb\"),\n      fontSize = \"15px\",\n      fontWeight = 600,\n      color = \"#333\",\n      background = \"#f7f7f7\"\n    ),\n    rowSelectedStyle = list(backgroundColor = \"#e6f2ff\", \"&:hover\" = list(backgroundColor = \"#e6f2ff\")),\n    searchInputStyle = list(width = \"100%\", margin = \"5px 0\", padding = \"5px\"),\n    filterInputStyle = list(width = \"100%\", margin = \"2px 0\", padding = \"4px\")\n  )\n)\n```\n\n### 7.3.2 Non-suspicious conversations\n\n```{r}\n#| code-fold: true\n#| code-summary: \"Show the code\"\n# Load necessary packages\nlibrary(reactable)\nlibrary(dplyr)\nlibrary(stringr)\nlibrary(tidyr) # For separate_rows\nlibrary(lubridate) # For date parsing\n\n# 1. Manually parse the data into a tribble\n# Each row in the tribble corresponds to a logical entry from provided text.\n# Multi-line strings within a cell are captured using '\\n'.\n# The 'Suspicious?' column is named 'Suspicious_Status' in R to avoid special characters,\n# and will be renamed in the reactable column definition for display.\ndf_raw_input <- tribble(\n  ~Sender, ~Recipient, ~Commonalities, ~Rationale, ~Suspicious_Status, ~Date, ~Event_Id,\n  \"Samantha (Person)\", \"Sailor Shift Team aka Glitters Team (Organization)\", \"Permit, Nemo Reef, Music Video\", \"Samantha was assisting Sailor Shift Team to coordinate the permit and equipment rental for their music video and wanted confirmation on Nemo Reef as their intended location.\", \"Unsure\", \"1/10\", \"64\",\n  \"Sailor Shift Team aka Glitters Team (Organization)\", \"Samantha (Person)\", \"Permit, Nemo Reef,\", \"Glitters Team confirmed with Samantha that they would like to use Nemo Reef as their primary location\", \"Unsure\", \"1/10\", \"66\",\n  \"Mako (Vessel)\", \"Samantha (Person)\", \"Nemo Reef Permit\", \"Mako claims that Samantha has a coordination team. Preparing for an event in a week's time from 6 Oct.\", \"Samantha is not\", \"6/10\", \"380\",\n  \"Mako (Vessel)\", \"Samantha (Person)\", \"Nemo Reef Permit\", \"Samantha advised them to stop activities which might be illegal without permit\", \"Samantha is not\", \"10/10\", \"687\",\n  \"The Lookout (Person)\", \"Sentinel (Vessel)\", \"Marina's Dream, Music Video\", \"Spotted 3 suspicious vessels around Nemo Reef on 3/10.\", \"Both are not\", \"3/10\", \"171\",\n  \"The Lookout (Person)\", \"Sentinel (Vessel)\", \"Marina's Dream, Music Video\", \"Spotted music video production on 13/10\", \"Both are not\", \"13/10\", \"912\",\n  \"The Lookout (Person)\", \"Horizon (Vessel)\", \"Music Video\", \"Found it suspicious to spot lighting rigs and cameras at 12pm. Wanted Horizon to investigate\", \"Both are not\", \"13/10\", \"926\",\n  \"EcoVigil (Vessel)\", \"Liam (Person)\", \"ROVs\", \"Collection of water samples using ROVs\", \"EcoVigil is not\", \"11/10\", \"737 and 751\" # \"and\" will be handled by separate_rows\n)\n\n# 2. Process the data for display and sorting\ndf_processed <- df_raw_input %>%\n  # Standardize delimiters and remove excess whitespace across all character columns.\n  # This flattens multi-line strings within cells and makes 'separate_rows' more reliable.\n  mutate(\n    across(where(is.character), ~ str_replace_all(.x, \"[,\\n]+\", \", \") %>% str_trim())\n  ) %>%\n  # Handle the \"and\" in Event_Id, converting it to a comma for consistent splitting.\n  mutate(Event_Id = str_replace_all(Event_Id, \" and \", \", \")) %>%\n  # Now, use separate_rows for Event_Id if it contains multiple comma-separated values.\n  # 'Date' column appears to be single-valued in this dataset, so it's not included here.\n  # If Date could also have multiple values (e.g., \"1/10, 2/10\"), you would add it to separate_rows.\n  separate_rows(Event_Id, sep = \", \", convert = FALSE) %>%\n  # Trim whitespace again after separation in case of leading/trailing spaces\n  mutate(across(where(is.character), str_trim)) %>%\n  # Convert Date to actual date objects for proper sorting.\n  # Using `dmy` for day/month/year format and assuming the current year (2025).\n  mutate(\n    FullDate = paste0(Date, \"/2025\"), # Add the current year for correct parsing\n    ParsedDate = dmy(FullDate, quiet = TRUE) # Convert to Date object (Day Month Year)\n  ) %>%\n  # Order the data by parsed date and then event ID\n  arrange(ParsedDate, Event_Id) %>%\n  select(-FullDate) %>% # Remove the helper column\n  # Ensure Event_Id is character type for display purposes\n  mutate(Event_Id = as.character(Event_Id))\n\n# 3. Create the reactable table\nreactable(\n  df_processed,\n  filterable = TRUE, # Enable column filters at the top of each column\n  searchable = TRUE, # Add a global search box above the table\n  paginationType = \"numbers\", # Display page numbers (e.g., 1, 2, 3 instead of Prev/Next)\n  defaultPageSize = 5, # Show 5 rows per page by default\n  showPageSizeOptions = TRUE, # Allow users to select different page sizes\n  pageSizeOptions = c(5, 10, 20, 50, 100), # Available page size options\n  striped = TRUE, # Add alternating row colors for better readability\n  highlight = TRUE, # Highlight the row when the user hovers over it\n  # Define the default sorting for the table when it first loads\n  defaultSorted = list(ParsedDate = \"asc\"), # Sort by the hidden ParsedDate column in ascending order\n  columns = list(\n    # The 'ParsedDate' column is used internally for correct date sorting but is not displayed\n    ParsedDate = colDef(\n      show = FALSE\n    ),\n    # Define how each visible column should be displayed and behave\n    Date = colDef(\n      name = \"Date\", # Display name for the column header\n      defaultSortOrder = \"asc\", # Ensure initial sort is ascending for the displayed date\n      minWidth = 80, # Minimum width for the column to ensure content fits\n      align = \"center\" # Align text to the center for better presentation of dates\n    ),\n    Sender = colDef(name = \"Sender\", minWidth = 120),\n    Recipient = colDef(name = \"Recipient\", minWidth = 120),\n    Commonalities = colDef(name = \"Commonalities\", minWidth = 150),\n    Rationale = colDef(name = \"Rationale\", minWidth = 300),\n    # Custom definition for the 'Suspicious_Status' column to display its original name\n    Suspicious_Status = colDef(name = \"Suspicious?\", minWidth = 150),\n    Event_Id = colDef(\n      name = \"Event ID\", # Display name for the column header\n      minWidth = 80, # Minimum width\n      align = \"center\" # Align text to the center\n    )\n  ),\n  # Customize the visual theme of the reactable table for a consistent look and feel\n  theme = reactableTheme(\n    borderColor = \"#dfe2e5\", # Defines the color of table borders\n    stripedColor = \"#f6f8fa\", # Defines the background color of striped rows\n    highlightColor = \"#f0f5f9\", # Defines the background color when a row is hovered over\n    cellPadding = \"8px 12px\", # Sets the padding inside table cells\n    style = list(fontFamily = \"Verdana, Geneva, sans-serif\", fontSize = \"14px\"), # General font family and size for table content\n    headerStyle = list(\n      \"&.rt-th:hover\" = list(backgroundColor = \"#e0e6eb\"), # Hover effect for table headers\n      fontSize = \"15px\", # Font size for headers\n      fontWeight = 600, # Font weight for headers (bold)\n      color = \"#333\", # Text color for headers\n      background = \"#f7f7f7\" # Background color for headers\n    ),\n    rowSelectedStyle = list(backgroundColor = \"#e6f2ff\", \"&:hover\" = list(backgroundColor = \"#e6f2ff\")), # Style for selected rows\n    searchInputStyle = list(width = \"100%\", margin = \"5px 0\", padding = \"5px\"), # Style for the global search input box\n    filterInputStyle = list(width = \"100%\", margin = \"2px 0\", padding = \"4px\") # Style for individual column filter input boxes\n  )\n)\n```\n\n# Question 2b)\n\n## 7.5 Community Detection and Centrality Measure- ggraph\n\n### 7.5.1 Community Detection- All\n\nSince we had an idea of the identity of the characters involved and their sub types, we wanted to uncover the communities they belonged to. We used the Louvian method for community detection to find communities that were densely connected internally but sparse to others.\n\n::: panel-tabset\n## Community Detection\n\n```{r, echo=FALSE}\nset.seed(1234)  \n\n# --- STEP 1: Prepare the edge list ---\nedge_df <- other_communications_df %>%\n  select(sender_id, recipient_id) %>%\n  filter(!is.na(sender_id) & !is.na(recipient_id)) %>%\n  rename(from = sender_id, to = recipient_id) %>%\n  distinct()\n\n# Remove self-loops\nedge_df <- edge_df %>% filter(from != to)\n\n# --- STEP 2: Create the graph object (undirected) ---\ng <- tbl_graph(edges = edge_df, directed = FALSE)\n\n# --- STEP 3: Run Louvain community detection ---\ng <- g %>%\n  mutate(community = group_louvain())\n\n# --- STEP 4: Visualize the graph ---\nggraph(g, layout = \"fr\") +\n  geom_edge_link(alpha = 0.3) +\n  geom_node_point(aes(color = as.factor(community)), size = 5) +\n  geom_node_text(aes(label = name), repel = TRUE, size = 3) +\n  theme_void() +\n  labs(title = \"Community Detection in Communication Network\",\n       color = \"Community\")\n```\n\n## The Code\n\n``` r\nset.seed(1234)  \n\n# --- STEP 1: Prepare the edge list ---\nedge_df <- other_communications_df %>%\n  select(sender_id, recipient_id) %>%\n  filter(!is.na(sender_id) & !is.na(recipient_id)) %>%\n  rename(from = sender_id, to = recipient_id) %>%\n  distinct()\n\n# Remove self-loops\nedge_df <- edge_df %>% filter(from != to)\n\n# --- STEP 2: Create the graph object (undirected) ---\ng <- tbl_graph(edges = edge_df, directed = FALSE)\n\n# --- STEP 3: Run Louvain community detection ---\ng <- g %>%\n  mutate(community = group_louvain())\n\n# --- STEP 4: Visualize the graph ---\nggraph(g, layout = \"fr\") +\n  geom_edge_link(alpha = 0.3) +\n  geom_node_point(aes(color = as.factor(community)), size = 5) +\n  geom_node_text(aes(label = name), repel = TRUE, size = 3) +\n  theme_void() +\n  labs(title = \"Community Detection in Communication Network\",\n       color = \"Community\")\n```\n:::\n\n### 7.5.2 Centrality Measure- All\n\nWe then proceeded to use the PageRank centrality algorithm to assign a numerical weight to each node to reflect its importance. The community attribute we previously calculated was then assigned to this graph.\n\n::: panel-tabset\n## PageRank Centrality Algorithm\n\n```{r, echo=FALSE}\nset.seed(1234) \n\n# --- Compute Centrality Measures ---\ng <- g %>%\n  mutate(\n    pagerank = centrality_pagerank(),\n    degree = centrality_degree(),\n    betweenness = centrality_betweenness(),\n    closeness = centrality_closeness()\n  )\n\n# Show top 10 nodes by PageRank\ng %>%\n  as_tibble() %>%\n  select(name, pagerank, degree, betweenness, closeness) %>%\n  arrange(desc(pagerank)) %>%\n  head(10)\n```\n\n## The Network\n\n```{r, echo=FALSE}\nset.seed(1234) \n\n# Visualize by Centrality\nggraph(g, layout = \"fr\") +\n  geom_edge_link(alpha = 0.3) +\n  geom_node_point(aes(size = pagerank, color = as.factor(community)), alpha = 0.8) +\n  geom_node_text(aes(label = name),\n                 repel = TRUE,\n                 size = 3,\n                 max.iter = 5000) + # <--- Increased this value \n  theme_void() +\n  labs(title = \"Network with PageRank Centrality\",\n       size = \"PageRank\", color = \"Community\")\n```\n\n## The Code\n\n``` r\nset.seed(1234) \n\n# --- STEP: Compute Centrality Measures ---\ng <- g %>%\n  mutate(\n    pagerank = centrality_pagerank(),\n    degree = centrality_degree(),\n    betweenness = centrality_betweenness(),\n    closeness = centrality_closeness()\n  )\n\n# Show top 10 nodes by PageRank\ng %>%\n  as_tibble() %>%\n  select(name, pagerank, degree, betweenness, closeness) %>%\n  arrange(desc(pagerank)) %>%\n  head(10)\n\n# Visualize by Centrality\nggraph(g, layout = \"fr\") +\n  geom_edge_link(alpha = 0.3) +\n  geom_node_point(aes(size = pagerank, color = as.factor(community)), alpha = 0.8) +\n  geom_node_text(aes(label = name),\n                 repel = TRUE,\n                 size = 3,\n                 max.iter = 5000) + # <--- Increased this value \n  theme_void() +\n  labs(title = \"Network with PageRank Centrality\",\n       size = \"PageRank\", color = \"Community\")\n```\n:::\n\n#### **7.5.2.1 Findings**:\n\n-   There were around 6 closely associated groups. Community 5 (Clepper and Miranda) appeared to be segmented from the central group, due to the non-involvement from the nature of the investigative work.\n-   From the graph, we extracted the 11 influential nodes to focus on:\n    -   Community 1: Reef Guardian, EcoVigil\n    -   Community 2: Neptune, Remora, Nadia, V. Miesel Shipping, Davis\n    -   Community 3: Mako\n    -   Community 4: Mrs. Money, Boss, The Middleman\n    -   Community 5: N/A as they were not very influential at global level\n    -   Community 6: N/A as they were not very influential at global level\n\n### 7.5.3 Wordclouds- Bigram\n\n::: panel-tabset\n## The Wordclouds\n\n```{r, echo=FALSE}\n# 1. Extract node community assignments\ng_node_communities <- g %>%\n  as_tibble() %>%\n  select(sender_name = name, community)\n\n# 2. Join communication content with community assignments\ncontent_with_community <- other_communications_df %>%\n  left_join(g_node_communities, by = c(\"sender_name\")) %>%\n  filter(!is.na(community), !is.na(content))\n\n# 3. Unnest tokens for unigrams\nunigrams <- content_with_community %>%\n  unnest_tokens(word, content, token = \"words\") %>%\n  anti_join(stop_words, by = \"word\") %>%\n  count(community, word, sort = TRUE)\n\n# 4. Unnest tokens for bigrams\nbigrams <- content_with_community %>%\n  unnest_tokens(bigram, content, token = \"ngrams\", n = 2) %>%\n  separate(bigram, into = c(\"word1\", \"word2\"), sep = \" \") %>%\n  filter(!word1 %in% stop_words$word,\n         !word2 %in% stop_words$word) %>%\n  unite(bigram, word1, word2, sep = \" \") %>%\n  count(community, bigram, sort = TRUE)\n\n# 5a. Plot word clouds per community\npar(mfrow = c(2, 3))  # 2 rows, 3 columns layout for 6 communities\nfor (i in sort(unique(bigrams$community))) {\n  words <- bigrams %>% filter(community == i)\n  \n  if (nrow(words) < 1) next  # Skip if no words\n  \n  suppressWarnings({\n    set.seed(432)  # Set seed for reproducibility\n    wordcloud(words = words$bigram,  # <-- FIXED here\n              freq = words$n,\n              max.words = min(20, nrow(words)),\n              scale = c(3, 0.5),\n              colors = brewer.pal(8, \"Dark2\"),\n              random.order = FALSE)\n  })\n  mtext(paste(\"Community\", i), side = 3, line = 1, adj = 0.5, cex = 1.5, col = \"black\")\n}\n```\n\n## The Code\n\n``` r\n# 1. Extract node community assignments\ng_node_communities <- g %>%\n  as_tibble() %>%\n  select(sender_name = name, community)\n\n# 2. Join communication content with community assignments\ncontent_with_community <- other_communications_df %>%\n  left_join(g_node_communities, by = c(\"sender_name\")) %>%\n  filter(!is.na(community), !is.na(content))\n\n# 3. Unnest tokens for unigrams\nunigrams <- content_with_community %>%\n  unnest_tokens(word, content, token = \"words\") %>%\n  anti_join(stop_words, by = \"word\") %>%\n  count(community, word, sort = TRUE)\n\n# 4. Unnest tokens for bigrams\nbigrams <- content_with_community %>%\n  unnest_tokens(bigram, content, token = \"ngrams\", n = 2) %>%\n  separate(bigram, into = c(\"word1\", \"word2\"), sep = \" \") %>%\n  filter(!word1 %in% stop_words$word,\n         !word2 %in% stop_words$word) %>%\n  unite(bigram, word1, word2, sep = \" \") %>%\n  count(community, bigram, sort = TRUE)\n\n# 5a. Plot word clouds per community\npar(mfrow = c(2, 3))  # 2 rows, 3 columns layout for 6 communities\nfor (i in sort(unique(bigrams$community))) {\n  words <- bigrams %>% filter(community == i)\n  \n  if (nrow(words) < 1) next  # Skip if no words\n  \n  suppressWarnings({\n    set.seed(432)  # Set seed for reproducibility\n    wordcloud(words = words$bigram,  # <-- FIXED here\n              freq = words$n,\n              max.words = min(20, nrow(words)),\n              scale = c(3, 0.5),\n              colors = brewer.pal(8, \"Dark2\"),\n              random.order = FALSE)\n  })\n  mtext(paste(\"Community\", i), side = 3, line = 1, adj = 0.5, cex = 1.5, col = \"black\")\n}\n```\n:::\n\n-   Certain words stood out more by their size in the unigram and bigrams. To view clearer frequencies and patterns among the community, we furthered the visualisations into circular barcharts of bigrams.\n\n### 7.5.4 Circular barchart for Top Bigrams per Community\n\n::: panel-tabset\n## The Circular Barchart\n\n```{r, echo=FALSE, message=FALSE, warning=FALSE, `fig-width`=10, `fig-height`=10}\nset.seed(1234)\n# --- Configuration ---\nnum_top_bigrams_per_community <- 8\nempty_bar_count <- 2 # gaps btw comm.\n#excluded_community <- 5 # too little in community 5\n\n# --- 1. Prepare the Combined Dataset ---\nall_communities_data <- bigrams %>%\n#  filter(community != excluded_community) %>%\n  group_by(community) %>%\n  arrange(desc(n)) %>%\n  slice_head(n = num_top_bigrams_per_community) %>%\n  ungroup()\n\nall_communities_data$community <- as.factor(all_communities_data$community)\n\nto_add <- data.frame(\n  bigram = NA,\n  n = NA,\n  community = rep(levels(all_communities_data$community), each = empty_bar_count)\n)\n\nplot_data <- rbind(all_communities_data, to_add) %>%\n  arrange(community)\n\nplot_data$id <- seq_len(nrow(plot_data)) # Keep ID as numeric here\n\n# --- 2. Prepare Label Data ---\nlabel_data <- plot_data\nnumber_of_bar <- nrow(label_data)\nlabel_data$angle <- 90 - 360 * (label_data$id - 0.5) / number_of_bar\nlabel_data$hjust <- ifelse(label_data$angle < -90, 1, 0)\nlabel_data$angle <- ifelse(label_data$angle < -90, label_data$angle + 180, label_data$angle)\n\n# --- 3. Prepare Data for Baselines (Community Dividers) ---\nbase_data <- plot_data %>%\n  group_by(community) %>%\n  summarize(\n    start = min(id, na.rm = TRUE), # Keep as numeric\n    end = max(id, na.rm = TRUE) - empty_bar_count # Keep as numeric\n  ) %>%\n  rowwise() %>%\n  mutate(\n    title_position = mean(c(start, end))\n  ) %>%\n  ungroup()\n\n# --- 4. Prepare Data for Grid Lines (Optional: Value Scales) ---\nmax_n_value <- max(plot_data$n, na.rm = TRUE)\ngrid_lines_values <- c(20, 40, 60, 80, 100)\ngrid_lines_values <- grid_lines_values[grid_lines_values <= max_n_value]\n\ngrid_segments_data <- plot_data %>%\n  group_by(community) %>%\n  summarize(\n    start_id = min(id, na.rm = TRUE), # Keep as numeric\n    end_id = max(id, na.rm = TRUE) - empty_bar_count # Keep as numeric\n  )\n\ngrid_data_final <- tibble()\nfor(val in grid_lines_values) {\n  temp_data <- grid_segments_data %>%\n    mutate(y_value = val)\n  grid_data_final <- bind_rows(grid_data_final, temp_data)\n}\n\n# --- Data for grid line LABELS ---\ngrid_label_data <- data.frame(\n  x_pos = max(plot_data$id, na.rm = TRUE) + 2, # Fixed x position outside the plot\n  y_pos = grid_lines_values,\n  label_text = as.character(grid_lines_values)\n)\n\n# --- 5. Make the Unified Plot ---\np <- ggplot(plot_data, aes(x = id, y = n, fill = community)) + # <--- x = id (numeric)\n  # Add background grid lines for value (e.g., 20, 40, 60, 80)\n  geom_segment(data = grid_data_final,\n               aes(x = start_id - 0.5, y = y_value, xend = end_id + 0.5, yend = y_value),\n               inherit.aes = FALSE,\n               color = \"grey\", alpha = 0.8, linewidth = 0.3) +\n\n  # Add text showing the value of each grid line at a fixed position\n  geom_text(data = grid_label_data,\n            aes(x = x_pos, y = y_pos, label = label_text),\n            inherit.aes = FALSE,\n            color = \"grey\", size = 3, angle = 0, fontface = \"bold\", hjust = 0) +\n\n  # Bars for the bigrams (main plot elements)\n  geom_bar(stat = \"identity\", alpha = 0.8, color = \"white\", linewidth = 0.1,\n           width = 1.4) + # <--- Add width=1 to remove space between bars if id is numeric\n\n  # Set limits for the y-axis, providing space for labels\n  ylim(-max_n_value * 0.7, max_n_value * 1.2) +\n\n  theme_minimal() +\n  theme(\n    legend.position = \"none\",\n    axis.text = element_blank(),\n    axis.title = element_blank(),\n    panel.grid = element_blank(),\n    plot.margin = unit(c(1.5, 1.5, 1.5, 1.5), \"cm\") # Top, Right, Bottom, Left margins\n  ) +\n  coord_polar(start = 0) +\n\n  # Add bigram labels\n  geom_text(\n    data = label_data,\n    aes(x = id, y = n + 10, label = bigram, hjust = hjust), # <--- x = id (numeric)\n    color = \"black\", fontface = \"bold\", alpha = 0.8, size = 2.8,\n    angle = label_data$angle, inherit.aes = FALSE\n  ) +\n\n  # Add base lines for each community segment\n  geom_segment(\n    data = base_data,\n    aes(x = start - 0.5, y = -10, xend = end + 0.5, yend = -10),\n    colour = \"black\", alpha = 0.8, linewidth = 0.6, inherit.aes = FALSE\n  ) +\n\n  # Add community group labels\n  geom_text(\n    data = base_data,\n    aes(x = title_position, y = -40, label = paste(\"Comm.\", community)),\n    colour = \"black\", alpha = 0.9, size = 2, fontface = \"bold\", inherit.aes = FALSE\n  )+\n  # --- Add the Title ---\n  labs(\n    title = \"Circular Bar Chart by Community\",\n    subtitle = \"Frequencies of key bigrams within each community\", # Updated subtitle\n    caption = paste0(\"AT | Generated: \", Sys.Date())\n  ) +\n  # Apply the Set2 Brewer palette\n  scale_fill_brewer(palette = \"Set2\") +\n  # --- Customize title appearance ---\n  theme(\n    plot.title = element_text(hjust = 0.5, size = 16, face = \"bold\", margin = margin(b = 10)),\n    plot.subtitle = element_text(hjust = 0.5, size = 12, margin = margin(b = 10)),\n    plot.caption = element_text(hjust = 1, size = 7, color = \"grey50\")\n  )\n\nprint(p)\n```\n\n## allThe Code\n\n``` r\n# --- Configuration ---\nnum_top_bigrams_per_community <- 8\nempty_bar_count <- 2 # gaps btw comm.\n#excluded_community <- 5 # too little in community 5\n\n# --- 1. Prepare the Combined Dataset ---\nall_communities_data <- bigrams %>%\n#  filter(community != excluded_community) %>%\n  group_by(community) %>%\n  arrange(desc(n)) %>%\n  slice_head(n = num_top_bigrams_per_community) %>%\n  ungroup()\n\nall_communities_data$community <- as.factor(all_communities_data$community)\n\nto_add <- data.frame(\n  bigram = NA,\n  n = NA,\n  community = rep(levels(all_communities_data$community), each = empty_bar_count)\n)\n\nplot_data <- rbind(all_communities_data, to_add) %>%\n  arrange(community)\n\nplot_data$id <- seq_len(nrow(plot_data)) # Keep ID as numeric here\n\n# --- 2. Prepare Label Data ---\nlabel_data <- plot_data\nnumber_of_bar <- nrow(label_data)\nlabel_data$angle <- 90 - 360 * (label_data$id - 0.5) / number_of_bar\nlabel_data$hjust <- ifelse(label_data$angle < -90, 1, 0)\nlabel_data$angle <- ifelse(label_data$angle < -90, label_data$angle + 180, label_data$angle)\n\n# --- 3. Prepare Data for Baselines (Community Dividers) ---\nbase_data <- plot_data %>%\n  group_by(community) %>%\n  summarize(\n    start = min(id, na.rm = TRUE), # Keep as numeric\n    end = max(id, na.rm = TRUE) - empty_bar_count # Keep as numeric\n  ) %>%\n  rowwise() %>%\n  mutate(\n    title_position = mean(c(start, end))\n  ) %>%\n  ungroup()\n\n# --- 4. Prepare Data for Grid Lines (Optional: Value Scales) ---\nmax_n_value <- max(plot_data$n, na.rm = TRUE)\ngrid_lines_values <- c(20, 40, 60, 80, 100)\ngrid_lines_values <- grid_lines_values[grid_lines_values <= max_n_value]\n\ngrid_segments_data <- plot_data %>%\n  group_by(community) %>%\n  summarize(\n    start_id = min(id, na.rm = TRUE), # Keep as numeric\n    end_id = max(id, na.rm = TRUE) - empty_bar_count # Keep as numeric\n  )\n\ngrid_data_final <- tibble()\nfor(val in grid_lines_values) {\n  temp_data <- grid_segments_data %>%\n    mutate(y_value = val)\n  grid_data_final <- bind_rows(grid_data_final, temp_data)\n}\n\n# --- Data for grid line LABELS ---\ngrid_label_data <- data.frame(\n  x_pos = max(plot_data$id, na.rm = TRUE) + 2, # Fixed x position outside the plot\n  y_pos = grid_lines_values,\n  label_text = as.character(grid_lines_values)\n)\n\n# --- 5. Make the Unified Plot ---\np <- ggplot(plot_data, aes(x = id, y = n, fill = community)) + # <--- x = id (numeric)\n  # Add background grid lines for value (e.g., 20, 40, 60, 80)\n  geom_segment(data = grid_data_final,\n               aes(x = start_id - 0.5, y = y_value, xend = end_id + 0.5, yend = y_value),\n               inherit.aes = FALSE,\n               color = \"grey\", alpha = 0.8, linewidth = 0.3) +\n\n  # Add text showing the value of each grid line at a fixed position\n  geom_text(data = grid_label_data,\n            aes(x = x_pos, y = y_pos, label = label_text),\n            inherit.aes = FALSE,\n            color = \"grey\", size = 3, angle = 0, fontface = \"bold\", hjust = 0) +\n\n  # Bars for the bigrams (main plot elements)\n  geom_bar(stat = \"identity\", alpha = 0.8, color = \"white\", linewidth = 0.1,\n           width = 1.4) + # <--- Add width=1 to remove space between bars if id is numeric\n\n  # Set limits for the y-axis, providing space for labels\n  ylim(-max_n_value * 0.7, max_n_value * 1.2) +\n\n  theme_minimal() +\n  theme(\n    legend.position = \"none\",\n    axis.text = element_blank(),\n    axis.title = element_blank(),\n    panel.grid = element_blank(),\n    plot.margin = unit(c(1.5, 1.5, 1.5, 1.5), \"cm\") # Top, Right, Bottom, Left margins\n  ) +\n  coord_polar(start = 0) +\n\n  # Add bigram labels\n  geom_text(\n    data = label_data,\n    aes(x = id, y = n + 10, label = bigram, hjust = hjust), # <--- x = id (numeric)\n    color = \"black\", fontface = \"bold\", alpha = 0.8, size = 2.8,\n    angle = label_data$angle, inherit.aes = FALSE\n  ) +\n\n  # Add base lines for each community segment\n  geom_segment(\n    data = base_data,\n    aes(x = start - 0.5, y = -10, xend = end + 0.5, yend = -10),\n    colour = \"black\", alpha = 0.8, linewidth = 0.6, inherit.aes = FALSE\n  ) +\n\n  # Add community group labels\n  geom_text(\n    data = base_data,\n    aes(x = title_position, y = -40, label = paste(\"Comm.\", community)),\n    colour = \"black\", alpha = 0.9, size = 2, fontface = \"bold\", inherit.aes = FALSE\n  )+\n  # --- Add the Title ---\n  labs(\n    title = \"Circular Bar Chart by Community\",\n    subtitle = \"Frequencies of key bigrams within each community\", # Updated subtitle\n    caption = paste0(\"AT | Generated: \", Sys.Date())\n  ) +\n  # Apply the Set2 Brewer palette\n  scale_fill_brewer(palette = \"Set2\") +\n  # --- Customize title appearance ---\n  theme(\n    plot.title = element_text(hjust = 0.5, size = 16, face = \"bold\", margin = margin(b = 10)),\n    plot.subtitle = element_text(hjust = 0.5, size = 12, margin = margin(b = 10)),\n    plot.caption = element_text(hjust = 1, size = 7, color = \"grey50\")\n  )\n\nprint(p)\n```\n:::\n\n### 7.5.5 Community Group Membership- All\n\nThe topic area was gathered from the bigram wordclouds and circular bar chart. The Group Name was created based on knowledge from the Members in the group and the topic area. These were the information from the 6 segmented groups:\n\n::: panel-tabset\n## The Table\n\n```{r, echo=FALSE}\nset.seed(1234)\n\n# 6. Create a tidy summary table of members per community\ngrouped_members <- g %>%\n  as_tibble() %>%\n  select(name, community) %>%\n  group_by(community) %>%\n  summarise(\n    Members = paste(sort(name), collapse = \", \"),\n    .groups = \"drop\"\n  ) %>%\n  mutate(\n    `Group Number` = community,\n    `Topic Area` = case_when(\n      community == 1 ~ \"green guardians, city council, paackland harbor, green guardians, nemo reef, water quality\",\n      community == 2 ~ \"nemo reef, miesel shipping, permit, cr 7844, delta 3\",\n      community == 3 ~ \"nemo reef, himark harbor, samantha blake, radio silence\",\n      community == 4 ~ \"money, 0500 meeting, nemo reef, intern reporting, conservation activity, financial projections\",\n      community == 5 ~ \"sam, kelly, loading equipment\",\n      community == 6 ~ \"miranda reporting, jensen, project poseidon, conservation vessels, nemo reef\",\n      TRUE ~ \"Other\"\n    ),\n    `Group Name` = case_when(\n      community == 1 ~ \"Conservationist Group\",\n      community == 2 ~ \"Sailor Shift\",\n      community == 3 ~ \"Maritime\",\n      community == 4 ~ \"Suspicious Characters\",\n      community == 5 ~ \"Sam & Kelly\",\n      community == 6 ~ \"Hacklee Herald\",\n      TRUE ~ \"Miscellaneous\"\n    )\n  ) %>%\n  select(`Group Number`, `Topic Area`, `Members`, `Group Name`)\n\n# Show the summary table in a clean format\nkable(grouped_members, caption = \"Community Group Membership Summary\", align = \"l\")\n```\n\n## The Code\n\n``` r\nset.seed(1234)\n\n# 6. Create a tidy summary table of members per community\ngrouped_members <- g %>%\n  as_tibble() %>%\n  select(name, community) %>%\n  group_by(community) %>%\n  summarise(\n    Members = paste(sort(name), collapse = \", \"),\n    .groups = \"drop\"\n  ) %>%\n  mutate(\n    `Group Number` = community,\n    `Topic Area` = case_when(\n      community == 1 ~ \"green guardians, city council, paackland harbor, green guardians, nemo reef, water quality\",\n      community == 2 ~ \"nemo reef, miesel shipping, permit, cr 7844, delta 3\",\n      community == 3 ~ \"nemo reef, himark harbor, samantha blake, radio silence\",\n      community == 4 ~ \"money, 0500 meeting, nemo reef, intern reporting, conservation activity, financial projections\",\n      community == 5 ~ \"sam, kelly, loading equipment\",\n      community == 6 ~ \"miranda reporting, jensen, project poseidon, conservation vessels, nemo reef\",\n      TRUE ~ \"Other\"\n    ),\n    `Group Name` = case_when(\n      community == 1 ~ \"Conservationist Group\",\n      community == 2 ~ \"Sailor Shift\",\n      community == 3 ~ \"Maritime\",\n      community == 4 ~ \"Suspicious Characters\",\n      community == 5 ~ \"Sam & Kelly\",\n      community == 6 ~ \"Hacklee Herald\",\n      TRUE ~ \"Miscellaneous\"\n    )\n  ) %>%\n  select(`Group Number`, `Topic Area`, `Members`, `Group Name`)\n\n# Show the summary table in a clean format\nkable(grouped_members, caption = \"Community Group Membership Summary\", align = \"l\")\n```\n:::\n\n#### **7.5.5.1 Findings:**\n\n-   We focused on the 11 nodes in the suspicious groups named:\n    -   Sailor Shift (Influential Nodes: Neptune, Remora, Nadia, V. Miesel Shipping, Davis);\n    -   Maritime (Influential Node: Mako);\n    -   Conservationist Group: (Influential Nodes: Reef Guardian, EcoVigil); and\n    -   Suspicious Characters (Influential Nodes: Mrs. Money, Boss, The Middleman).\n-   We held back on the slightly less influential nodes such as: Sam & Kelly, and Hacklee Herald which was where Clepper Jensen worked as a journalist.\n\n### 7.5.6 Interactive Chord Diagram by Community\n\nIn 7.1, we previously created a static chord diagram and heatmap to identify node pairs with higher interactions, and the interactions across entity subtypes.\n\nHere, the interactive chord diagram showed the correspondences among communities at every two hour intervals.\n\n```{r}\n#| code-fold: true\n#| code-summary: \"Show the code\"\n# Get community membership from graph object\ncommunity_df <- g %>%\n  as_tibble() %>%\n  select(name, community)\n```\n\n::: no-code-fold\n```{r, echo=FALSE, message=FALSE, warning=FALSE}\nlibrary(circlize)\nlibrary(dplyr)\nlibrary(tidyr)\nlibrary(RColorBrewer)\nlibrary(stringr)\nlibrary(lubridate)\nlibrary(htmltools) # Essential for building the HTML structure\nlibrary(jsonlite) # For passing R data to JavaScript safely\n\n# --- 1. Data Preprocessing and Setup ---\n\n# Bin by 2-hour interval\nother_communications_df <- other_communications_df %>%\n  mutate(timestamp = as.POSIXct(timestamp)) %>% # Ensure timestamp is POSIXct\n  mutate(timestamp_2hr = floor_date(timestamp, unit = \"2 hours\"))\n\n# Get all unique 2-hour time bins for the slider\nall_times <- sort(unique(other_communications_df$timestamp_2hr))\n\n# Define output directory for image frames\noutput_dir <- \"chord_frames\"\ndir.create(output_dir, showWarnings = FALSE) # Create the directory if it doesn't exist\n\n# Community name mapping (ensure this matches  'community_df' structure)\ncommunity_name_map <- c(\n  \"1\" = \"Conservationist Group\",\n  \"2\" = \"Sailor Shift\",\n  \"3\" = \"Maritime\",\n  \"4\" = \"Suspicious Characters\",\n  \"5\" = \"Sam & Kelly\",\n  \"6\" = \"Hacklee Herald\"\n)\n\n\n# Assuming community_df has a 'community' column that's numeric/factor\nif (exists(\"community_df\") && \"community\" %in% names(community_df)) {\n  num_unique_communities <- length(unique(community_df$community))\n  base_colors <- brewer.pal(max(3, num_unique_communities), \"Set2\") # Use Set2 for pastel\n  community_colors <- setNames(\n    base_colors[1:num_unique_communities], # Slice to exactly the number needed\n    as.character(sort(unique(community_df$community)))\n  )\n} else {\n  # Fallback if community_df is not defined or missing 'community' column\n  message(\"Warning: 'community_df' or 'community' column not found. Using default colors.\")\n  community_colors <- c(\n    \"1\" = \"#66C2A5\", \"2\" = \"#FC8D62\", \"3\" = \"#8DA0CB\", \"4\" = \"#E78AC3\",\n    \"5\" = \"#A6D854\", \"6\" = \"#FFD92F\", \"7\" = \"#E5C494\", \"8\" = \"#B3B3B3\"\n  )\n}\n\n\n# --- 2. Generate and Save Chord Diagrams as PNGs ---\n\n# Loop through each time bin, create a plot, and save it\nfor (i in seq_along(all_times)) {\n  selected_time <- all_times[i]\n  end_time <- selected_time + hours(2)\n\n  filtered_df <- other_communications_df %>%\n    filter(timestamp_2hr == selected_time)\n\n  # Prepare data for the chord diagram matrix\n  sent_df <- filtered_df %>%\n    filter(communication_type == \"sent\") %>%\n    count(sender_name, recipient_name, name = \"sent\")\n\n  received_df <- filtered_df %>%\n    filter(communication_type == \"received\") %>%\n    count(sender_name = recipient_name, recipient_name = sender_name, name = \"received\")\n\n  combined_df <- full_join(sent_df, received_df, by = c(\"sender_name\", \"recipient_name\")) %>%\n    mutate(across(c(sent, received), ~replace_na(., 0)),\n           total = sent + received)\n\n  # Skip this iteration if no data for the current time slice\n  if (nrow(combined_df) == 0 || sum(combined_df$total) == 0) {\n    message(paste(\"No communications for time:\", selected_time, \". Skipping frame.\"))\n\n    next\n  }\n\n  comm_matrix <- xtabs(total ~ sender_name + recipient_name, data = combined_df)\n\n  # Ensure sector_names from comm_matrix exist in community_df for color mapping\n  sector_names <- union(rownames(comm_matrix), colnames(comm_matrix))\n  \n  # Filter community_df to only relevant sectors and ensure distinct entries\n  sector_community_df <- community_df %>%\n    filter(name %in% sector_names) %>%\n    distinct(name, .keep_all = TRUE) %>%\n    arrange(match(name, sector_names))\n\n  # Map community colors to sector names based on 'community' column\n  grid_colors_current_frame <- setNames(\n    community_colors[as.character(sector_community_df$community)],\n    sector_community_df$name\n  )\n  # Ensure only colors for actual sectors in the matrix are used\n  grid_colors_current_frame <- grid_colors_current_frame[names(grid_colors_current_frame) %in% sector_names]\n\n\n  # Open PNG device for saving the plot\n  png(sprintf(\"%s/frame_%03d.png\", output_dir, i), width = 800, height = 800)\n  \n  # Clear existing circlize plot before drawing new one\n  circos.clear()\n  par(mar = c(6, 2, 10, 6)) # Adjust margins as needed for title and labels\n\n  # Draw the chord diagram\n  chordDiagram(\n    comm_matrix,\n    grid.col = grid_colors_current_frame,\n    transparency = 0.25,\n    annotationTrack = \"grid\",\n    preAllocateTracks = list(track.height = 0.1)\n  )\n\n  # Add labels to the sectors\n  circos.trackPlotRegion(\n    track.index = 1,\n    panel.fun = function(x, y) {\n      name <- get.cell.meta.data(\"sector.index\")\n      wrapped_name <- str_wrap(name, width = 12)\n      circos.text(\n        x = mean(get.cell.meta.data(\"xlim\")),\n        y = 0,\n        labels = wrapped_name,\n        facing = \"clockwise\",\n        niceFacing = TRUE,\n        adj = c(0, 0.5),\n        cex = 0.8\n      )\n    },\n    bg.border = NA\n  )\n\n  # Add a main title to the plot\n  title(\n    main = paste(\"Communication Flows\\n\", format(selected_time, \"%d %b %Y (%H:%M\"), \"to\", format(end_time, \"%H:%M)\")),\n    cex.main = 1.2,\n    font.main = 1,\n    line = 6\n  )\n  dev.off() # CRITICAL: Close the PNG device to save the file\n}\n\n# --- 3. Build the HTML Viewer with Embedded Images and JavaScript ---\n\n# Generate HTML <img> tags for each saved frame\n# Filter out any frames that might have been skipped if 'next' was used\n# Check which frame files actually exist\nexisting_frames <- list.files(output_dir, pattern = \"^frame_\\\\d{3}\\\\.png$\", full.names = TRUE)\n# Extract the numeric index from the filename to match with all_times\nframe_indices <- as.numeric(gsub(\"frame_(\\\\d{3})\\\\.png\", \"\\\\1\", basename(existing_frames)))\n\n# Only create image tags for the frames that were successfully generated\nimage_tags <- lapply(seq_along(existing_frames), function(idx) {\n  # The original 'i' (loop index) corresponds to the 'frame_indices'\n  original_time_idx <- frame_indices[idx]\n  tags$img(src = existing_frames[idx], # Use the full path here\n           style = if (idx == 1) \"display:block;\" else \"display:none;\", # Show first frame by default\n           class = \"chord-frame\",\n           alt = paste(\"Chord diagram for time slice\", format(all_times[original_time_idx], \"%d %b %Y %H:%M\")))\n})\n\n\n# JavaScript function to update which image frame is visible\n# We need to map the slider value (0 to num_frames-1) to the correct time index\n# because some frames might be skipped, causing gaps in numerical sequence.\njs_script <- HTML(sprintf(\"\n<script>\n  // Ensure the allTimes array correctly maps to the generated frames\n  const originalAllTimes = %s; // This is the full list of all_times\n  const generatedFrameIndices = %s; // This indicates which original_time_idx corresponds to a generated frame\n\n  function updateFrame(sliderIndex) {\n    const frames = document.querySelectorAll('.chord-frame');\n    frames.forEach((el, i) => {\n      // frames[i] corresponds to existing_frames[i] from R\n      // sliderIndex is 0-based for the slider\n      el.style.display = (i === sliderIndex) ? 'block' : 'none';\n    });\n\n    // Update the time display text based on the current frame's original time\n    const timeDisplay = document.getElementById('current-time-display');\n    if (timeDisplay && sliderIndex < generatedFrameIndices.length) {\n        // Get the original time index for the currently displayed frame\n        const actualTimeIndex = generatedFrameIndices[sliderIndex] - 1; // Convert 1-based to 0-based for originalAllTimes\n        \n        if (actualTimeIndex >= 0 && actualTimeIndex < originalAllTimes.length) {\n            const selectedTime = new Date(originalAllTimes[actualTimeIndex]);\n            const endTime = new Date(selectedTime.getTime() + 2 * 60 * 60 * 1000); // Add 2 hours in milliseconds\n\n            // Format dates and times for display\n            const formatDate = (date) => date.toLocaleDateString('en-US', { day: '2-digit', month: 'short', year: 'numeric' });\n            const formatTime = (date) => date.toLocaleTimeString('en-US', { hour: '2-digit', minute: '2-digit', hour12: false });\n            \n            timeDisplay.innerHTML = `Day: ${formatDate(selectedTime)} | Time: ${formatTime(selectedTime)} to ${formatTime(endTime)}`;\n        } else {\n            timeDisplay.innerHTML = 'No data for this time slice.';\n        }\n    }\n  }\n\n  // Initialize the display on page load\n  document.addEventListener('DOMContentLoaded', () => {\n    const slider = document.getElementById('frameSlider');\n    if (slider) {\n        updateFrame(parseInt(slider.value)); // Set initial frame based on slider's default value\n    }\n  });\n</script>\n\", jsonlite::toJSON(as.character(all_times)), jsonlite::toJSON(frame_indices))) # Pass all_times and frame_indices to JS\n\n\n# --- 4. Display the HTML content directly in the Quarto document ---\n# This is the key line to make Quarto embed the interactive viewer.\nbrowsable(\n  tagList(\n    js_script, # The JavaScript for interactivity\n    tags$head(\n      tags$style(HTML(\"\n        /* Basic styling for the image frames and slider container */\n        .chord-frame { width: 100%; max-width: 800px; height: auto; margin: auto; display: block; }\n        #slider-container { text-align: center; margin: 20px auto; max-width: 800px; }\n        .chord-title { text-align: center; font-size: 1.5em; margin-bottom: 15px; font-weight: bold; }\n        #frameSlider { width: 80%; max-width: 700px; margin: 10px auto; display: block; }\n        #current-time-display { font-weight: bold; margin-top: 10px; }\n      \"))\n    ), # Close tags$head\n\n    tags$body( \n      tags$div(class = \"chord-title\", \"Interactive Communication Flows Over Time\"),\n      tags$div(id = \"slider-container\",\n          tags$input(type = \"range\", min = \"0\", max = length(existing_frames) - 1, value = 0,\n                     id = \"frameSlider\", oninput = \"updateFrame(parseInt(this.value))\"),\n          tags$p(id = \"current-time-display\", style = \"font-weight:bold; margin-top: 10px;\"),\n          tags$p(\"Use the slider to view communication over time\")\n      ),\n      tags$div(id = \"chord-images-container\", image_tags) # Container for all image frames\n    )\n  )\n)\n```\n:::\n\n#### 7.5.6.1 Findings:\n\nWe noticed some cross community direct and indirect communication occured mainly among influential nodes, suggesting collaboration. These are **some** sample linkages with arrows regardless of sent or received:\n\n+-----------------------+-------------------------------------------------------------+\n| Community X           | Node Linkages (Community X -\\> Community X -\\> Community Y) |\n+=======================+=============================================================+\n| Suspicious Characters | Mrs. Money -\\> Intern -\\> The Lookout                       |\n|                       |                                                             |\n|                       | Liam -\\> Paackland Harbor -\\> The Middleman                 |\n|                       |                                                             |\n|                       | Glitters Team -\\> Boss -\\> Mako                             |\n|                       |                                                             |\n|                       | Glitters Team -\\> Samantha Blake -\\> Sailor Shifts Team     |\n+-----------------------+-------------------------------------------------------------+\n| Sailor Shift          | Neptune -\\> Elise -\\> Mako                                  |\n|                       |                                                             |\n|                       | Neptune -\\> Davis -\\> Mako                                  |\n|                       |                                                             |\n|                       | Remora -\\> Neptune -\\> Boss                                 |\n|                       |                                                             |\n|                       | Rodriguez -\\> Remora -\\> Mako                               |\n|                       |                                                             |\n|                       | Remora -\\> Small Fry -\\> Mako                               |\n|                       |                                                             |\n|                       | Davis -\\> Remora -\\> Paackland Harbor                       |\n|                       |                                                             |\n|                       | V. Miesel Shipping -\\> Neptune -\\> Mako                     |\n+-----------------------+-------------------------------------------------------------+\n| Sam & Kelly           | Kelly -\\> Sam - \\> The Lookout                              |\n+-----------------------+-------------------------------------------------------------+\n| Maritime              | Mako -\\> Himark Harbor -\\> Oceanus City Council             |\n+-----------------------+-------------------------------------------------------------+\n| Hacklee Herald        | N/A (Only Direct Community X to X communications)           |\n+-----------------------+-------------------------------------------------------------+\n| Conservationist Group | Reef Guardian -\\> Oceanus City Council -\\> Nadia            |\n|                       |                                                             |\n|                       | Reef Guardian -\\> Paackland Harbor -\\> Mako                 |\n|                       |                                                             |\n|                       | Oceanus City Council -\\> Liam -\\> Nadia                     |\n+-----------------------+-------------------------------------------------------------+\n\nWe also noticed that at times, certain individuals sent messages but there were no response back. This could possibly be due to the pseudonyms being used to send or reply to the same content. For instance, there was a message from Davis to Rodriguez on 14 Oct around 1200-1400 but there was no response by Rodriguez. By looking at the content field, we then found out that he was Small Fry due to the responses he provided to Davis which was originally addressed to Rodriguez.\n\n### 7.5.7 Community Detection- People & Vessels\n\nSince our nodes (apart from V. Miesel Shipping) were mostly of people and vessels, in order for us to drill even deeper into people and vessels, we recreated the process for only people and vessels.\n\n::: panel-tabset\n## Community Detection\n\n```{r,echo=FALSE}\nset.seed(1234)\n\n# --- STEP 1: Prepare the edge list ---\nedge_df_pv <- person_vessel_df %>%\n  select(sender_id, recipient_id) %>%\n  filter(!is.na(sender_id) & !is.na(recipient_id)) %>%\n  rename(from = sender_id, to = recipient_id) %>%\n  distinct()\n\n# Optional: remove self-loops\nedge_df_pv <- edge_df_pv %>% filter(from != to)\n\n# --- STEP 2: Create the graph object (undirected) ---\ng_pv <- tbl_graph(edges = edge_df_pv, directed = FALSE)\n\n# --- STEP 3: Run Louvain community detection ---\ng_pv <- g_pv %>%\n  mutate(community = group_louvain())\n\n# --- STEP 4: Visualize the graph ---\nggraph(g_pv, layout = \"fr\") +\n  geom_edge_link(alpha = 0.3) +\n  geom_node_point(aes(color = as.factor(community)), size = 5) +\n  geom_node_text(aes(label = name), repel = TRUE, size = 3) +\n  theme_void() +\n  labs(title = \"Community Detection in Communication Network\",\n       color = \"Community\")\n```\n\n## The Code\n\n``` r\nset.seed(1234)\n\n# --- STEP 1: Prepare the edge list ---\nedge_df_pv <- person_vessel_df %>%\n  select(sender_id, recipient_id) %>%\n  filter(!is.na(sender_id) & !is.na(recipient_id)) %>%\n  rename(from = sender_id, to = recipient_id) %>%\n  distinct()\n\n# Optional: remove self-loops\nedge_df_pv <- edge_df_pv %>% filter(from != to)\n\n# --- STEP 2: Create the graph object (undirected) ---\ng_pv <- tbl_graph(edges = edge_df_pv, directed = FALSE)\n\n# --- STEP 3: Run Louvain community detection ---\ng_pv <- g_pv %>%\n  mutate(community = group_louvain())\n\n# --- STEP 4: Visualize the graph ---\nggraph(g_pv, layout = \"fr\") +\n  geom_edge_link(alpha = 0.3) +\n  geom_node_point(aes(color = as.factor(community)), size = 5) +\n  geom_node_text(aes(label = name), repel = TRUE, size = 3) +\n  theme_void() +\n  labs(title = \"Community Detection in Communication Network\",\n       color = \"Community\")\n```\n:::\n\n### 7.5.8 Centrality Measure- People & Vessels\n\n::: panel-tabset\n## PageRank Centrality Algorithm\n\n```{r, echo=FALSE}\n# --- Compute Centrality Measures ---\nset.seed(1234)\ng_pv <- g_pv %>%\n  mutate(\n    pagerank = centrality_pagerank(),\n    degree = centrality_degree(),\n    betweenness = centrality_betweenness(),\n    closeness = centrality_closeness()\n  )\n\n# Show top 10 nodes by PageRank\ng_pv %>%\n  as_tibble() %>%\n  select(name, pagerank, degree, betweenness, closeness) %>%\n  arrange(desc(pagerank)) %>%\n  head(10)\n```\n\n## The Network\n\n```{r, echo=FALSE}\nset.seed(1234)\n\n# Visualize by Centrality\nggraph(g_pv, layout = \"fr\") +\n  geom_edge_link(alpha = 0.3) +\n  geom_node_point(aes(size = pagerank, color = as.factor(community)), alpha = 0.8) +\n  geom_node_text(aes(label = name), repel = TRUE, size = 3) +\n  theme_void() +\n  labs(title = \"Network with PageRank Centrality\",\n       size = \"PageRank\", color = \"Community\")\n```\n\n## The Code\n\n``` r\nset.seed(1234)\n\n# --- STEP: Compute Centrality Measures ---\ng_pv <- g_pv %>%\n  mutate(\n    pagerank = centrality_pagerank(),\n    degree = centrality_degree(),\n    betweenness = centrality_betweenness(),\n    closeness = centrality_closeness()\n  )\n\n# Show top 10 nodes by PageRank\ng_pv %>%\n  as_tibble() %>%\n  select(name, pagerank, degree, betweenness, closeness) %>%\n  arrange(desc(pagerank)) %>%\n  head(10)\n\n# Visualize by Centrality\nggraph(g_pv, layout = \"fr\") +\n  geom_edge_link(alpha = 0.3) +\n  geom_node_point(aes(size = pagerank, color = as.factor(community)), alpha = 0.8) +\n  geom_node_text(aes(label = name), repel = TRUE, size = 3) +\n  theme_void() +\n  labs(title = \"Network with PageRank Centrality\",\n       size = \"PageRank\", color = \"Community\")\n```\n:::\n\n#### **7.5.8.1 Findings:**\n\n-   There were 5 closely associated groups. Community 5 (Clepper and Miranda) appeared to be segmented from the central group, due to the non-involvement from the nature of their investigative work.\n-   From the graph, we extracted the 8 influential nodes to focus on:\n    -   Community 1: Mako\n    -   Community 2: Neptune, Remora, Nadia, Davis\n    -   Community 3: N/A as they were not very influential at global level\n    -   Community 4: Mrs. Money, Boss, The Middleman\n    -   Community 5: N/A as they were not very influential at global level\n\n### 7.5.9 Wordclouds- Bigrams\n\nWe focused on bigrams here to get more contextual data from two instead of one word.\n\n::: panel-tabset\n## The Wordclouds\n\n```{r, echo=FALSE}\n# 5b. Plot word clouds per community\nvalid_communities <- unique(g_pv %>% as_tibble() %>% pull(community))\n\npar(mfrow = c(2, 3))  # Still allocate 6 slots, but you can adjust this\nfor (i in sort(valid_communities)) {\n  words <- bigrams %>% filter(community == i)\n  \n  if (nrow(words) < 1) next\n  \n  suppressWarnings({\n    set.seed(432)  # Set seed for reproducibility\n    wordcloud(words = words$bigram,  # <-- FIXED here\n              freq = words$n,\n              max.words = min(30, nrow(words)),\n              scale = c(3, 0.5),\n              colors = brewer.pal(8, \"Dark2\"),\n              random.order = FALSE)\n  })\n  mtext(paste(\"Community\", i), side = 3, line = 1, adj = 0.5, cex = 1.5, col = \"black\")\n}\n```\n\n## The Code\n\n``` r\n# 5b. Plot word clouds per community\nvalid_communities <- unique(g_pv %>% as_tibble() %>% pull(community))\n\npar(mfrow = c(2, 3))  # Still allocate 6 slots, but you can adjust this\nfor (i in sort(valid_communities)) {\n  words <- bigrams %>% filter(community == i)\n  \n  if (nrow(words) < 1) next\n  \n  suppressWarnings({\n    set.seed(432)  # Set seed for reproducibility\n    wordcloud(words = words$bigram,  # <-- FIXED here\n              freq = words$n,\n              max.words = min(30, nrow(words)),\n              scale = c(3, 0.5),\n              colors = brewer.pal(8, \"Dark2\"),\n              random.order = FALSE)\n  })\n  mtext(paste(\"Community\", i), side = 3, line = 1, adj = 0.5, cex = 1.5, col = \"black\")\n}\n```\n:::\n\n### 7.5.10 Circular barchart for Top Bigrams per Community\n\n::: panel-tabset\n## The Circular Barchart\n\n```{r, echo=FALSE, message=FALSE, warning=FALSE, `fig-width`=8, `fig-height`=8}\nset.seed(1234)\n\nvalid_communities <- g_pv %>%\n  as_tibble() %>%\n  distinct(community) %>%\n  pull(community)\n\nbigrams <- bigrams %>% filter(community %in% valid_communities)\n\n# --- Configuration ---\nnum_top_bigrams_per_community <- 8\nempty_bar_count <- 2 # gaps btw comm.\n#excluded_community <- 5 # too little in community 5\n\n# --- 1. Prepare the Combined Dataset ---\nall_communities_data <- bigrams %>%\n#  filter(community != excluded_community) %>%\n  group_by(community) %>%\n  arrange(desc(n)) %>%\n  slice_head(n = num_top_bigrams_per_community) %>%\n  ungroup()\n\nall_communities_data$community <- as.factor(all_communities_data$community)\n\nto_add <- data.frame(\n  bigram = NA,\n  n = NA,\n  community = rep(levels(all_communities_data$community), each = empty_bar_count)\n)\n\nplot_data <- rbind(all_communities_data, to_add) %>%\n  arrange(community)\n\nplot_data$id <- seq_len(nrow(plot_data)) # Keep ID as numeric here\n\n# --- 2. Prepare Label Data ---\nlabel_data <- plot_data\nnumber_of_bar <- nrow(label_data)\nlabel_data$angle <- 90 - 360 * (label_data$id - 0.5) / number_of_bar\nlabel_data$hjust <- ifelse(label_data$angle < -90, 1, 0)\nlabel_data$angle <- ifelse(label_data$angle < -90, label_data$angle + 180, label_data$angle)\n\n# --- 3. Prepare Data for Baselines (Community Dividers) ---\nbase_data <- plot_data %>%\n  group_by(community) %>%\n  summarize(\n    start = min(id, na.rm = TRUE), # Keep as numeric\n    end = max(id, na.rm = TRUE) - empty_bar_count # Keep as numeric\n  ) %>%\n  rowwise() %>%\n  mutate(\n    title_position = mean(c(start, end))\n  ) %>%\n  ungroup()\n\n# --- 4. Prepare Data for Grid Lines (Optional: Value Scales) ---\nmax_n_value <- max(plot_data$n, na.rm = TRUE)\ngrid_lines_values <- c(20, 40, 60, 80, 100)\ngrid_lines_values <- grid_lines_values[grid_lines_values <= max_n_value]\n\ngrid_segments_data <- plot_data %>%\n  group_by(community) %>%\n  summarize(\n    start_id = min(id, na.rm = TRUE), # Keep as numeric\n    end_id = max(id, na.rm = TRUE) - empty_bar_count # Keep as numeric\n  )\n\ngrid_data_final <- tibble()\nfor(val in grid_lines_values) {\n  temp_data <- grid_segments_data %>%\n    mutate(y_value = val)\n  grid_data_final <- bind_rows(grid_data_final, temp_data)\n}\n\n# --- Data for grid line LABELS ---\ngrid_label_data <- data.frame(\n  x_pos = max(plot_data$id, na.rm = TRUE) + 2, # Fixed x position outside the plot\n  y_pos = grid_lines_values,\n  label_text = as.character(grid_lines_values)\n)\n\n# --- 5. Make the Unified Plot ---\np <- ggplot(plot_data, aes(x = id, y = n, fill = community)) + # <--- x = id (numeric)\n  # Add background grid lines for value (e.g., 20, 40, 60, 80)\n  geom_segment(data = grid_data_final,\n               aes(x = start_id - 0.5, y = y_value, xend = end_id + 0.5, yend = y_value),\n               inherit.aes = FALSE,\n               color = \"grey\", alpha = 0.8, linewidth = 0.3) +\n\n  # Add text showing the value of each grid line at a fixed position\n  geom_text(data = grid_label_data,\n            aes(x = x_pos, y = y_pos, label = label_text),\n            inherit.aes = FALSE,\n            color = \"grey\", size = 3, angle = 0, fontface = \"bold\", hjust = 0) +\n\n  # Bars for the bigrams (main plot elements)\n  geom_bar(stat = \"identity\", alpha = 0.8, color = \"white\", linewidth = 0.1,\n           width = 1) + # <--- Add width=1 to remove space between bars if id is numeric\n\n  # Set limits for the y-axis, providing space for labels\n  ylim(-max_n_value * 0.7, max_n_value * 1.2) +\n\n  theme_minimal() +\n  theme(\n    legend.position = \"none\",\n    axis.text = element_blank(),\n    axis.title = element_blank(),\n    panel.grid = element_blank(),\n    plot.margin = unit(c(1.5, 1.5, 1.5, 1.5), \"cm\") # Top, Right, Bottom, Left margins\n  ) +\n  coord_polar(start = 0) +\n\n  # Add bigram labels\n  geom_text(\n    data = label_data,\n    aes(x = id, y = n + 10, label = bigram, hjust = hjust), # <--- x = id (numeric)\n    color = \"black\", fontface = \"bold\", alpha = 0.8, size = 2.8,\n    angle = label_data$angle, inherit.aes = FALSE\n  ) +\n\n  # Add base lines for each community segment\n  geom_segment(\n    data = base_data,\n    aes(x = start - 0.5, y = -10, xend = end + 0.5, yend = -10),\n    colour = \"black\", alpha = 0.8, linewidth = 0.6, inherit.aes = FALSE\n  ) +\n\n  # Add community group labels\n  geom_text(\n    data = base_data,\n    aes(x = title_position, y = -40, label = paste(\"Comm.\", community)),\n    colour = \"black\", alpha = 0.9, size = 2, fontface = \"bold\", inherit.aes = FALSE\n  )+\n  # --- Add the Title ---\n  labs(\n    title = \"Circular Bar Chart by Community\",\n    subtitle = \"Frequencies of key bigrams within each community\", # Updated subtitle\n    caption = paste0(\"AT | Generated: \", Sys.Date())\n  ) +\n  # Apply the Set2 Brewer palette\n  scale_fill_brewer(palette = \"Set2\") +\n  # --- Customize title appearance ---\n  theme(\n    plot.title = element_text(hjust = 0.5, size = 16, face = \"bold\", margin = margin(b = 10)),\n    plot.subtitle = element_text(hjust = 0.5, size = 12, margin = margin(b = 10)),\n    plot.caption = element_text(hjust = 1, size = 7, color = \"grey50\")\n  )\n\nprint(p)\n```\n\n## The Code\n\n``` r\nset.seed(1234)\n\nset.seed(1234)\n\nvalid_communities <- g_pv %>%\n  as_tibble() %>%\n  distinct(community) %>%\n  pull(community)\n\nbigrams <- bigrams %>% filter(community %in% valid_communities)\n\n# --- Configuration ---\nnum_top_bigrams_per_community <- 8\nempty_bar_count <- 2 # gaps btw comm.\n#excluded_community <- 5 # too little in community 5\n\n# --- 1. Prepare the Combined Dataset ---\nall_communities_data <- bigrams %>%\n#  filter(community != excluded_community) %>%\n  group_by(community) %>%\n  arrange(desc(n)) %>%\n  slice_head(n = num_top_bigrams_per_community) %>%\n  ungroup()\n\nall_communities_data$community <- as.factor(all_communities_data$community)\n\nto_add <- data.frame(\n  bigram = NA,\n  n = NA,\n  community = rep(levels(all_communities_data$community), each = empty_bar_count)\n)\n\nplot_data <- rbind(all_communities_data, to_add) %>%\n  arrange(community)\n\nplot_data$id <- seq_len(nrow(plot_data)) # Keep ID as numeric here\n\n# --- 2. Prepare Label Data ---\nlabel_data <- plot_data\nnumber_of_bar <- nrow(label_data)\nlabel_data$angle <- 90 - 360 * (label_data$id - 0.5) / number_of_bar\nlabel_data$hjust <- ifelse(label_data$angle < -90, 1, 0)\nlabel_data$angle <- ifelse(label_data$angle < -90, label_data$angle + 180, label_data$angle)\n\n# --- 3. Prepare Data for Baselines (Community Dividers) ---\nbase_data <- plot_data %>%\n  group_by(community) %>%\n  summarize(\n    start = min(id, na.rm = TRUE), # Keep as numeric\n    end = max(id, na.rm = TRUE) - empty_bar_count # Keep as numeric\n  ) %>%\n  rowwise() %>%\n  mutate(\n    title_position = mean(c(start, end))\n  ) %>%\n  ungroup()\n\n# --- 4. Prepare Data for Grid Lines (Optional: Value Scales) ---\nmax_n_value <- max(plot_data$n, na.rm = TRUE)\ngrid_lines_values <- c(20, 40, 60, 80, 100)\ngrid_lines_values <- grid_lines_values[grid_lines_values <= max_n_value]\n\ngrid_segments_data <- plot_data %>%\n  group_by(community) %>%\n  summarize(\n    start_id = min(id, na.rm = TRUE), # Keep as numeric\n    end_id = max(id, na.rm = TRUE) - empty_bar_count # Keep as numeric\n  )\n\ngrid_data_final <- tibble()\nfor(val in grid_lines_values) {\n  temp_data <- grid_segments_data %>%\n    mutate(y_value = val)\n  grid_data_final <- bind_rows(grid_data_final, temp_data)\n}\n\n# --- Data for grid line LABELS ---\ngrid_label_data <- data.frame(\n  x_pos = max(plot_data$id, na.rm = TRUE) + 2, # Fixed x position outside the plot\n  y_pos = grid_lines_values,\n  label_text = as.character(grid_lines_values)\n)\n\n# --- 5. Make the Unified Plot ---\np <- ggplot(plot_data, aes(x = id, y = n, fill = community)) + # <--- x = id (numeric)\n  # Add background grid lines for value (e.g., 20, 40, 60, 80)\n  geom_segment(data = grid_data_final,\n               aes(x = start_id - 0.5, y = y_value, xend = end_id + 0.5, yend = y_value),\n               inherit.aes = FALSE,\n               color = \"grey\", alpha = 0.8, linewidth = 0.3) +\n\n  # Add text showing the value of each grid line at a fixed position\n  geom_text(data = grid_label_data,\n            aes(x = x_pos, y = y_pos, label = label_text),\n            inherit.aes = FALSE,\n            color = \"grey\", size = 3, angle = 0, fontface = \"bold\", hjust = 0) +\n\n  # Bars for the bigrams (main plot elements)\n  geom_bar(stat = \"identity\", alpha = 0.8, color = \"white\", linewidth = 0.1,\n           width = 1) + # <--- Add width=1 to remove space between bars if id is numeric\n\n  # Set limits for the y-axis, providing space for labels\n  ylim(-max_n_value * 0.7, max_n_value * 1.2) +\n\n  theme_minimal() +\n  theme(\n    legend.position = \"none\",\n    axis.text = element_blank(),\n    axis.title = element_blank(),\n    panel.grid = element_blank(),\n    plot.margin = unit(c(1.5, 1.5, 1.5, 1.5), \"cm\") # Top, Right, Bottom, Left margins\n  ) +\n  coord_polar(start = 0) +\n\n  # Add bigram labels\n  geom_text(\n    data = label_data,\n    aes(x = id, y = n + 10, label = bigram, hjust = hjust), # <--- x = id (numeric)\n    color = \"black\", fontface = \"bold\", alpha = 0.8, size = 2.8,\n    angle = label_data$angle, inherit.aes = FALSE\n  ) +\n\n  # Add base lines for each community segment\n  geom_segment(\n    data = base_data,\n    aes(x = start - 0.5, y = -10, xend = end + 0.5, yend = -10),\n    colour = \"black\", alpha = 0.8, linewidth = 0.6, inherit.aes = FALSE\n  ) +\n\n  # Add community group labels\n  geom_text(\n    data = base_data,\n    aes(x = title_position, y = -40, label = paste(\"Comm.\", community)),\n    colour = \"black\", alpha = 0.9, size = 2, fontface = \"bold\", inherit.aes = FALSE\n  )+\n  # --- Add the Title ---\n  labs(\n    title = \"Circular Bar Chart by Community\",\n    subtitle = \"Frequencies of key bigrams within each community\", # Updated subtitle\n    caption = paste0(\"AT | Generated: \", Sys.Date())\n  ) +\n  # Apply the Set2 Brewer palette\n  scale_fill_brewer(palette = \"Set2\") +\n  # --- Customize title appearance ---\n  theme(\n    plot.title = element_text(hjust = 0.5, size = 16, face = \"bold\", margin = margin(b = 10)),\n    plot.subtitle = element_text(hjust = 0.5, size = 12, margin = margin(b = 10)),\n    plot.caption = element_text(hjust = 1, size = 7, color = \"grey50\")\n  )\n\nprint(p)\n```\n:::\n\n### 7.5.11 Community Group Membership- People & Vessels\n\nThe topic area was gathered from the bigram wordclouds and circular bar chart. The Group Name was created based on knowledge from the Members in the group and the topic area. These are the information for the 5 segmented groups:\n\n::: panel-tabset\n## The Table\n\n```{r, echo=FALSE}\nset.seed(1234)\n# 6. Create a tidy summary table of members per community\ngrouped_members <- g_pv %>%\n  as_tibble() %>%\n  select(name, community) %>%\n  group_by(community) %>%\n  summarise(\n    Members = paste(sort(name), collapse = \", \"),\n    .groups = \"drop\"\n  ) %>%\n  mutate(\n    `Group Number` = community,\n    `Topic Area` = case_when(\n      community == 1 ~ \"nemo reef, himark harbor, samantha blake, city council\",\n      community == 2 ~ \"south dock, equipment transfer, security team, nemo reef, delta3, cr 7844\",\n      community == 3 ~ \"intern reporting, conservation vessels, nemo reef\",\n      community == 4 ~ \"10am tomorrow, 0500 tomorrow, funding channels, alternative funding\",\n      community == 5 ~ \"classification markings, project poseidon, clearance documents, harbor security\",\n      TRUE ~ \"Other\"\n    ),\n    `Group Name` = case_when(\n      community == 1 ~ \"Conservationist Group\",\n      community == 2 ~ \"Permit\",\n      community == 3 ~ \"Pseudonym\",\n      community == 4 ~ \"Suspicious\",\n      community == 5 ~ \"Hacklee Herald\",\n      TRUE ~ \"Miscellaneous\"\n    )\n  ) %>%\n  select(`Group Number`, `Topic Area`, `Members`, `Group Name`)\n\n# Show the summary table in a clean format\nkable(grouped_members, caption = \"Community Group Membership Summary\", align = \"l\")\n```\n\n## The Code\n\n``` r\nset.seed(1234)\n# 6. Create a tidy summary table of members per community\ngrouped_members <- g_pv %>%\n  as_tibble() %>%\n  select(name, community) %>%\n  group_by(community) %>%\n  summarise(\n    Members = paste(sort(name), collapse = \", \"),\n    .groups = \"drop\"\n  ) %>%\n  mutate(\n    `Group Number` = community,\n    `Topic Area` = case_when(\n      community == 1 ~ \"nemo reef, himark harbor, samantha blake, city council\",\n      community == 2 ~ \"south dock, equipment transfer, security team, nemo reef, delta3, cr 7844\",\n      community == 3 ~ \"intern reporting, conservation vessels, nemo reef\",\n      community == 4 ~ \"10am tomorrow, 0500 tomorrow, funding channels, alternative funding\",\n      community == 5 ~ \"classification markings, project poseidon, clearance documents, harbor security\",\n      TRUE ~ \"Other\"\n    ),\n    `Group Name` = case_when(\n      community == 1 ~ \"Conservationist Group\",\n      community == 2 ~ \"Permit\",\n      community == 3 ~ \"Pseudonym\",\n      community == 4 ~ \"Suspicious\",\n      community == 5 ~ \"Hacklee Herald\",\n      TRUE ~ \"Miscellaneous\"\n    )\n  ) %>%\n  select(`Group Number`, `Topic Area`, `Members`, `Group Name`)\n\n# Show the summary table in a clean format\nkable(grouped_members, caption = \"Community Group Membership Summary\", align = \"l\")\n```\n:::\n\n#### **7.5.11.1 Findings:**\n\n-   Movements and changes in membership since section 7.5.6:\n    -   Mako moved from Maritime to Conservationist.\n    -   Samantha Blake moved from the Suspicious Characters to Conservationist.\n    -   Sam and Kelly moved from their own Community to Pseudonym.\n    -   The Lookout moved from Conservationist Group to Pseudonym.\n    -   The Intern moved from Suspicious Characters to Pseudonym.\n    -   Sailor Shift community renamed to Permit\n-   From 11 nodes in section 7.5.6.1, we further narrowed down on the 8 nodes in the suspicious groups named:\n    -   Permit (Influential Nodes: Neptune, Remora, Nadia, Davis);\n    -   Conservationist Group (Influential Node: Mako);\n    -   Suspicious (Influential Nodes: Mrs. Money, Boss, The Middleman).\n-   We held back on the slightly less influential nodes such as: Hacklee Herald which was where Clepper Jensen worked as a journalist.\n\n### 7.5.12 Plotted Community Timeline- People & Vessels\n\nWe then decided to plot the timeline based on community colours to uncover patterns.\n\n```{r}\n#| code-fold: true\n#| code-summary: \"Show the code\"\n# --- FACTORING and DATETIME CLEANING ---\nperson_vessel_df_for_plot <- person_vessel_df %>%\n  mutate(\n    timestamp = as.POSIXct(timestamp),\n    comm_date = as.Date(timestamp),\n    comm_time_of_day = hms::as_hms(format(timestamp, \"%H:%M:%S\")),\n    sender_sub_type = factor(sender_sub_type, levels = c(\"Person\", \"Vessel\")),\n    communicating_pair_sorted = paste(pmin(sender_name, recipient_name), pmax(sender_name, recipient_name), sep = \" & \")\n  )\n\n# Get community membership from graph object\ncommunity_df <- g_pv %>%\n  as_tibble() %>%\n  select(name, community)\n\n# --- WRAPPING CONTENT AND TOOLTIP ---\nplot_data1 <- person_vessel_df_for_plot %>%\n  mutate(\n    timestamp = as.POSIXct(timestamp),\n    date = as.Date(timestamp),\n    time = format(timestamp, \"%H:%M:%S\"),\n    wrapped_content = str_wrap(content, width = 50),\n    tooltip_text = paste0(\n      \"<b>Date:</b> \", date, \"<br>\",\n      \"<b>Time:</b> \", time, \"<br>\",\n      \"<b>From:</b> \", sender_name, \"<br>\",\n      \"<b>To:</b> \", recipient_name, \"<br>\",\n      \"<b>Event_id:</b> \", event_id, \"<br><br>\",\n      \"<b>Content:</b><br>\", wrapped_content\n    )\n  )\n\n# Merge with plot_data1 using sender_id == name\nplot_data1 <- plot_data1 %>%\n  left_join(community_df, by = c(\"sender_id\" = \"name\"))\n\n# Plot\np <- ggplot(plot_data1, aes(x = comm_date, y = comm_time_of_day)) +\n  geom_point(aes(\n    color = as.factor(community),\n    shape = sender_sub_type,\n    text = tooltip_text\n  ), show.legend = c(color = TRUE, shape = FALSE),\n  size = 2, alpha = 0.7) +\n  scale_shape_manual(values = c(\"Person\" = 16, \"Vessel\" = 17)) +\n  facet_wrap(~ sender_sub_type, ncol = 1, scales = \"fixed\") +\n    scale_y_time(\n    limits = hms::as_hms(c(\"08:00:00\", \"14:00:00\")),  # reversed to show time top-to-bottom\n    breaks = hms::as_hms(c(\"08:00:00\", \"09:00:00\", \"10:00:00\", \"11:00:00\", \"12:00:00\", \"13:00:00\", \"14:00:00\")),\n    labels = c(\"08:00\", \"09:00\", \"10:00\", \"11:00\", \"12:00\", \"13:00\", \"14:00\")\n)+\n  scale_x_date(\n  date_breaks = \"1 day\",\n  date_labels = \"%d %b\"\n)+\n  labs(\n    title = \"Communication Events Over Time (Sender's Perspective)\",\n    x = \"Date\",\n    y = \"Time of Day\",\n    color = \"Community\"\n  ) +\n  theme_grey() +\n  theme(\n    axis.text.y = element_text(size = 6),\n    axis.title.y = element_text(size = 7),\n    axis.ticks.y = element_line(),\n    axis.text.x = element_text(size = 6, angle = 45, hjust = 1),\n    axis.title.x = element_text(margin = margin(t = 10), size = 7),\n    panel.spacing = unit(0.5, \"lines\"),  # Applies to both x and y spacing\n    strip.text = element_text(size = 8, face = \"bold\"),\n    legend.position = \"bottom\",\n    legend.text = element_text(size = 6),\n    legend.title = element_blank()\n  )\n\n# --- Convert to interactive plot ---\nggplotly(p, tooltip = \"tooltip_text\")\n```\n\n### 7.5.13 Discussion/ Interpretation:\n\nWe mainly focused on the conversations by 8 influential nodes and some related nodes:\n\n-   **Conservation Group** (Comm.1): Samantha Blake informed Mako to stop operations on 8 and 10th Oct. Serenity is a private luxury yacht. Osprey was likely a tourism vessel looking for charter from Mako for their tourists.\n\n-   **Permit** (Comm. 2): Neptune, Remora, Nadia, and Davis were working on Nemo Reef operation. This referred to the Music Video Production for Sailor Shift on 14 Oct.\n\n-   **Pseudonym** (Comm. 3): Other than communicating among themselves, The Lookout appeared to have also externally corresponded with Sentinel, Reef Guardian and Horizon (conservation based topics), while The Intern also externally corresponded with Mrs. Money.\n\n-   **Suspicious** (Comm. 4): The Middleman had access to Council documents. Mrs. Money had funding from sources that would not flag out to regulators for her operations. Mrs. Money was investigating V. Miesel's structures. On 5 Oct, Boss told Mrs. Money to disguise financial trails through tourism ventures and destroy evidence of Nemo Reef operations.\n\n-   **Hacklee Herald** (Comm. 5): Conversations between Clepper and his intern Miranda which ended on 11 Oct. Miranda mentioned an Oceanus City Council Member meeting with unmarked vessels at night.\n\n# **8) Tackling Question 3**\n\n# Question 3a)\n\n## 8.1 Entities Breakdown\n\n**Core Logic:**\n\n-   If two names appear as sender and recipient in the same message, they cannot belong to the same person — i.e., they're not aliases of each other.\n\n-   If two names sent a message at the exact time, they cannot belong to the same person.\n\nWe created Alluvial Diagrams to chart: real_identity → observed_name → community\n\n::: panel-tabset\n## Extraction of the list of Entity names\n\n```{r}\nunique_names <- sort(unique(c(other_communications_df$sender_name, \n                              other_communications_df$recipient_name)))\nunique_names\n\n```\n\n## Manual Mapping\n\n```{r}\nname_mapping <- tibble::tibble(\n  observed_name = c(\n    \"Boss\", \"City Officials\", \"Clepper Jensen\", \"Davis\", \"Defender\", \"EcoVigil\",\n    \"Elise\", \"Glitters Team\", \"Green Guardians\", \"Haacklee Harbor\", \"Himark Harbor\", \"Horizon\",\n    \"Kelly\", \"Knowles\", \"Liam Thorne\", \"Mako\", \"Marlin\", \"Miranda Jordan\",\n    \"Mrs. Money\", \"Nadia Conti\", \"Neptune\", \"Northern Light\", \"Oceanus City Council\", \"Osprey\",\n    \"Paackland Harbor\", \"Port Security\", \"Reef Guardian\", \"Remora\", \"Rodriguez\", \"Sailor Shift Team\",\n    \"Sam\", \"Samantha Blake\", \"Seawatch\", \"Sentinel\", \"Serenity\", \"Small Fry\",\n    \"The Accountant\", \"The Intern\", \"The Lookout\", \"The Middleman\", \"V. Miesel Shipping\"\n  ),\n  real_identity = c(\n    \"Nadia Conti\", \"Oceanus City Council\", \"Clepper Jensen\", \"Captain Davis\", \"Sentinel\", \"EcoVigil\",\n    \"Elise\", \"Sailor Shift Team\", \"Green Guardians\", \"Harbor Authority\",\"Harbor Authority\", \"Horizon\",\n    \"Kelly\", \"Knowles\", \"Liam Thorne\", \"Mako\", \"Small Fishing Vessel\", \"Miranda Jordan\",\n    \"Elise\", \"Nadia Conti\", \"Neptune\", \"Commercial Vessel\", \"Oceanus City Council\", \"Tourism Vessel\",\n    \"Harbor Authority\", \"Oceanus City Council\", \"Reef Guardian\", \"Remora\", \"Rodriguez\", \"Sailor Shift Team\",\n    \"Sam\", \"Samantha Blake\", \"Kelly\", \"Sentinel\", \"Private Luxury Yacht\", \"Rodriguez\",\n    \"Elise\", \"Sam\", \"Kelly\", \"Liam Thorne\", \"V. Miesel Shipping\"\n  ),\n  community = c(\n    \"V. Miesel Shipping\", \"City Council\", \"Haacklee Herald\", \"V. Miesel Shipping\", \"Local Conservationist Group\", \"Local Conservationist Group\",\n    \"V. Miesel Shipping\", \"Sailor Shift Team\", \"Local Conservationist Group\", \"Harbor Authority\", \"Harbor Authority\", \"Local Conservationist Group\",\n    \"Local Conservationist Group\", \"V. Miesel Shipping\", \"City Council\", \"V. Miesel Shipping\", \"Maritime\", \"Haacklee Herald\",\n    \"V. Miesel Shipping\", \"V. Miesel Shipping\", \"V. Miesel Shipping\", \"Maritime\", \"City Council\", \"Maritime\",\n    \"Harbor Authority\", \"City Council\", \"Local Conservationist Group\", \"V. Miesel Shipping\", \"V. Miesel Shipping\", \"Sailor Shift Team\",\n    \"V. Miesel Shipping\", \"Sailor Shift Team\", \"Local Conservationist Group\", \"Local Conservationist Group\", \"Maritime\", \"V. Miesel Shipping\",\n    \"V. Miesel Shipping\", \"V. Miesel Shipping\", \"Local Conservationist Group\", \"City Council\", \"V. Miesel Shipping\"\n  )\n)\n\nmulti_members <- tibble::tibble(\n  observed_name = c(\n    #  City Council members (additional to existing)\n    \"Commissioner Blake\", \"Commissioner Torres\", \"Council Knowles\", \"The Middleman\", \"Jensen from City Council\", \"Liam Thorne\",\n\n    # Sailor Shift Team (may already exist, but we ensure all)\n    \"Boss\", \"Council Knowles\", \"Davis\", \"Glitters Team\", \"Liam Thorne\", \"Mako\", \"Mrs. Money\", \"Nadia Conti\", \"Neptune\",\n    \"Remora\", \"Rodriguez\", \"Sam\", \"Samantha Blake\", \"Small Fry\", \"The Accountant\", \"The Intern\", \"The Middleman\", \"Elise\",\n\n    #  Influential Families\n    \"Council Knowles\", \"V. Miesel Shipping\",\n\n    #  Conservationist Group\n    \"Defender\", \"EcoVigil\", \"Green Guardians\", \"Horizon\", \"Kelly\", \"Reef Guardian\", \"Seawatch\", \"Sentinel\", \"The Lookout\"\n  ),\n  real_identity = c(\n    \"Commissioner Blake\", \"Commissioner Torres\", \"Council Knowles\", \"Liam Thorne\", \"Clepper Jensen\", \"Liam Thorne\",\n\n    \"Nadia Conti\", \"Council Knowles\", \"Captain Davis\", \"Sailor Shift Team\", \"Liam Thorne\", \"Mako\", \"Elise\", \"Nadia Conti\", \"Neptune\",\n    \"Remora\", \"Rodriguez\", \"Sam\", \"Samantha Blake\", \"Rodriguez\", \"Elise\", \"Sam\", \"Liam Thorne\", \"Elise\",\n\n    \"Council Knowles\", \"V. Miesel Shipping\",\n\n    \"Sentinel\", \"EcoVigil\", \"Green Guardians\", \"Horizon\", \"Kelly\", \"Reef Guardian\", \"The Lookout\", \"Sentinel\", \"Kelly\"\n  ),\n  community = c(\n    rep(\"City Council\", 6),\n    rep(\"Sailor Shift Team\", 18),\n    rep(\"Influential Families\", 2),\n    rep(\"Local Conservationist Group\", 9)\n  )\n)\n\n```\n:::\n\n## Entities- Interactive Alluvial Diagrams\n\nHover to see details for individual identities.\n\nReal Identity from analysis -\\> Observed Name from data -\\> Community\n\nThis will probably be a drop down for each name in Shiny.\n\n```{r}\n# --- Libraries ---\nlibrary(dplyr)\nlibrary(ggplot2)\nlibrary(ggalluvial)\nlibrary(stringr)\nlibrary(plotly)\n\n# --- 1. Build Alluvial Dataset ---\nalluvial_data <- name_mapping %>%\n  bind_rows(multi_members) %>% # Combine the two data sources\n  distinct() %>% # Remove any duplicate rows after combining\n  filter(!is.na(real_identity) & !is.na(community)) %>%\n  count(real_identity, observed_name, community, name = \"value\") %>%\n  mutate(tooltip = paste0( # Create the tooltip string\n    \"Real Identity: \", real_identity, \"<br>\",\n    \"Observed Name: \", observed_name, \"<br>\",\n    \"Community: \", community, \"<br>\",\n    \"Count: \", value\n  ))\n\n# --- 3. Create static ggplot object (original version) ---\np <- ggplot(alluvial_data,\n            aes(axis1 = real_identity, axis2 = observed_name, axis3 = community,\n                y = value,\n                text = tooltip # Map the custom tooltip string to the 'text' aesthetic\n            )) +\n  geom_alluvium(aes(fill = real_identity), width = 1/12, alpha = 0.8) +\n  geom_stratum(width = 1/12, fill = \"grey90\", color = \"black\", aes(text = NULL)) + # No dual-role fill here\n  geom_text(stat = \"stratum\", aes(label = after_stat(stratum)), size = 3.5, hjust = 0) +\n  scale_x_discrete(\n    limits = c(\"Real Identity\", \"Observed Name\", \"Community\"),\n    expand = c(.05, .25)\n  ) +\n  labs(\n    title = \"All Identity Flows\",\n    x = NULL, y = \"Link Count\"\n  ) +\n  theme_minimal() +\n  theme(\n    legend.position = \"none\", # No legend for fill here\n    panel.grid = element_blank(),\n    axis.text.y = element_blank(),\n    axis.ticks = element_blank(),\n    plot.margin = margin(10, 80, 10, 10),\n    axis.text.x = element_text(face = \"bold\")\n  )\n\n# --- 4. Convert to interactive Plotly object ---\n# 'tooltip = \"text\"' tells Plotly to use the content of the 'text' aesthetic\ninteractive_plot <- ggplotly(p, tooltip = \"text\", height = 800, width = 1000)\ninteractive_plot # This line will print the Plotly object in  Quarto output\n\n```\n\n# Question 3b)\n\nWe created a graph with the character's original name, pseudonyms, and supplemented with any background information we learnt of. For instance, we learnt that Davis was a captain, or that Serenity was a private luxury yacht.Here, it is easier to determine who is using which pseudonyms by clicking on the real identity drop down panel which will then only segregate to the individual's Real Identity, Observed Name, and Community.\n\n# Question 3c)\n\nUnderstanding pseudonyms significantly reshapes our interpretation of the events in Oceanus. Without resolving aliases, the communication network appears fragmented — it may seem like dozens of separate individuals are involved. However, by mapping pseudonyms to real identities, we discover that a small number of actors are coordinating more activity than initially apparent. For example, a person using multiple pseudonyms may appear in many places at once — suggesting high influence or deception. This reveals orchestrated behavior, such as coordinated logistics, manipulation of event timelines, or masking involvement in controversial operations.\n\n# **9) Tackling Question 4**\n\n# Question 4a)\n\n## 9.1 Nadia's Ego Network- Louvain community\n\n::: panel-tabset\n## Ego Network\n\n```{r, echo=FALSE}\nset.seed(1234)\n\n# Assume g_full includes Nadia — not g from other_communications_df\ng_igraph <- as.igraph(g)\n\n# Confirm Nadia exists\nif (!\"Nadia Conti\" %in% V(g_igraph)$name) stop(\"Nadia Conti not found in the graph.\")\n\n# Get ego subgraph\nnadia_ego_igraph <- make_ego_graph(g_igraph, order = 1, nodes = which(V(g_igraph)$name == \"Nadia Conti\"), mode = \"all\")[[1]]\n\n# Convert to tidygraph\nnadia_ego_graph <- as_tbl_graph(nadia_ego_igraph)\n\n# Convert to undirected for Louvain\nnadia_ego_graph <- nadia_ego_graph %>% \n  to_undirected() %>% \n  activate(nodes) %>%\n  mutate(\n    community = group_louvain(),\n    pagerank = centrality_pagerank()\n  )\n\n# Plot Nadia's ego network\nggraph(nadia_ego_graph, layout = \"fr\") +\n  geom_edge_link(alpha = 0.4) +\n  geom_node_point(aes(size = pagerank, color = as.factor(community)), alpha = 0.9) +\n  geom_node_text(aes(label = name), repel = TRUE, size = 3) +\n  scale_color_brewer(palette = \"Set2\") +\n  theme_void() +\n  labs(\n    title = \"Nadia Conti’s Ego Network\",\n    subtitle = \"Nodes sized by PageRank, colored by Louvain community\",\n    color = \"Community\",\n    size = \"PageRank\"\n  )\n```\n\n## The Code\n\n``` r\nset.seed(1234)\n\n# Assume g_full includes Nadia — not g from other_communications_df\ng_igraph <- as.igraph(g)\n\n# Confirm Nadia exists\nif (!\"Nadia Conti\" %in% V(g_igraph)$name) stop(\"Nadia Conti not found in the graph.\")\n\n# Get ego subgraph\nnadia_ego_igraph <- make_ego_graph(g_igraph, order = 1, nodes = which(V(g_igraph)$name == \"Nadia Conti\"), mode = \"all\")[[1]]\n\n# Convert to tidygraph\nnadia_ego_graph <- as_tbl_graph(nadia_ego_igraph)\n\n# Convert to undirected for Louvain\nnadia_ego_graph <- nadia_ego_graph %>% \n  to_undirected() %>% \n  activate(nodes) %>%\n  mutate(\n    community = group_louvain(),\n    pagerank = centrality_pagerank()\n  )\n\n# Plot Nadia's ego network\nggraph(nadia_ego_graph, layout = \"fr\") +\n  geom_edge_link(alpha = 0.4) +\n  geom_node_point(aes(size = pagerank, color = as.factor(community)), alpha = 0.9) +\n  geom_node_text(aes(label = name), repel = TRUE, size = 3) +\n  scale_color_brewer(palette = \"Set2\") +\n  theme_void() +\n  labs(\n    title = \"Nadia Conti’s Ego Network\",\n    subtitle = \"Nodes sized by PageRank, colored by Louvain community\",\n    color = \"Community\",\n    size = \"PageRank\"\n  )\n```\n:::\n\n-   We wanted to find out if there were sub communities within Nadia's direct network that worked closely together.\n-   The orange community were possibly involved in Sailor Shifts's music video, while the green community were likely regarding ensuring compliance to authorities such as officials, the harbour and conservation team.\n-   Nadia, Elise, and Marlin were the orange nodes that directly linked to the green nodes.\n\n## 9.2 Nadia's Sent and Received Ego Networks- VizNetwork\n\n### 9.2.1 Data Preparation\n\n::: panel-tabset\n## Preparation- Nodes & Edges\n\n```{r, echo=FALSE}\n# --- 2. Clean and Prepare Nodes ---\nmc3_nodes_cleaned <- mc3_nodes_raw %>%\n  mutate(id = as.character(id)) %>%\n  filter(!is.na(id)) %>%\n  distinct(id, .keep_all = TRUE) %>%\n  # Rename 'type' to 'supertype' to reduce confusion with communication type\n  rename(supertype = type) %>%\n  # Select only columns that are needed and are consistently present\n  select(id, name, sub_type, content, timestamp) # Keep timestamp as character for now\n\n# --- 3. Clean and Prepare Edges ---\n# Rename 'type' in edges to 'edge_type' to avoid conflict with node 'supertype'\nmc3_edges_cleaned <- mc3_edges_raw %>%\n  rename(from_id = source,\n         to_id = target,\n         edge_type = type) %>% # Renamed 'type' to 'edge_type'\n  mutate(across(c(from_id, to_id), as.character)) %>%\n  # Filter out any edges where from_id or to_id are not in cleaned nodes\n  filter(from_id %in% mc3_nodes_cleaned$id,\n         to_id %in% mc3_nodes_cleaned$id)\n\n# --- 4. Identify Nadia Conti's ID and Sub_type ---\nnadia_info <- mc3_nodes_cleaned %>%\n  filter(name == \"Nadia Conti\") %>%\n  select(id, sub_type) # Corrected: Select sub_type here, not supertype\n\nnadia_id <- nadia_info %>% pull(id)\nnadia_sub_type <- nadia_info %>% pull(sub_type) # New variable for Nadia's sub_type\n\n\nif (length(nadia_id) == 0) {\n  stop(\"Nadia Conti not found in the nodes data. Please check the 'name' column or the ID.\")\n} else if (length(nadia_id) > 1) {\n  warning(\"Multiple entries found for Nadia Conti. Using the first one.\")\n  nadia_id <- nadia_id[1]\n  nadia_sub_type <- nadia_sub_type[1] # Ensure sub_type is also taken for the first one\n}\n\nprint(paste(\"Nadia Conti's ID:\", nadia_id))\nprint(paste(\"Nadia Conti's Sub_type:\", nadia_sub_type))\n\n# --- 5. Extract Nadia's Sent Communications ---\n# Logic: Nadia (source) --sent--> Event_Communication (target) --received--> Recipient (target)\nnadia_sent_communications <- mc3_edges_cleaned %>%\n  filter(from_id == nadia_id, edge_type == \"sent\") %>%\n  # Join with nodes to get content and timestamp of the Event_Communication node\n  left_join(mc3_nodes_cleaned %>% select(id, content, timestamp),\n            by = c(\"to_id\" = \"id\")) %>%\n  rename(event_id = to_id, event_content = content, event_timestamp = timestamp) %>%\n  # Now, find the recipient of this communication event\n  left_join(mc3_edges_cleaned %>%\n              filter(edge_type == \"received\") %>%\n              select(event_id_match = from_id, recipient_id = to_id),\n            by = c(\"event_id\" = \"event_id_match\")) %>%\n  # Join with nodes to get the recipient's name AND sub_type\n  left_join(mc3_nodes_cleaned %>% select(id, name, sub_type), # Select sub_type here\n            by = c(\"recipient_id\" = \"id\")) %>%\n  rename(recipient_name = name, recipient_sub_type = sub_type) %>% # Rename sub_type\n  # Select and rename final columns for sent communications\n  select(\n    communication_type = edge_type, # This will be \"sent\"\n    sender_id = from_id,\n    recipient_id,\n    recipient_name,\n    recipient_sub_type, # Include in final select\n    event_id,\n    content = event_content,\n    timestamp = event_timestamp # Timestamp is still character here\n  ) %>%\n  mutate(\n    sender_name = !!nadia_id, # Explicitly set sender_name to Nadia's ID/name using !!\n    sender_sub_type = !!nadia_sub_type # Assign Nadia's sub_type as a constant value using !!\n  )\n\nprint(\"--- Nadia's Sent Communications ---\")\nprint(kable(head(nadia_sent_communications, 10), format = \"markdown\", align = \"l\"))\n\n\n# --- 6. Extract Nadia's Received Communications ---\n# Logic: Sender (source) --sent--> Event_Communication (target) --received--> Nadia (target)\nnadia_received_communications <- mc3_edges_cleaned %>%\n  filter(to_id == nadia_id, edge_type == \"received\") %>%\n  # The source of this edge is the Event_Communication node\n  rename(event_id = from_id) %>%\n  # Join with nodes to get content and timestamp of the Event_Communication node\n  left_join(mc3_nodes_cleaned %>% select(id, content, timestamp),\n            by = c(\"event_id\" = \"id\")) %>%\n  rename(event_content = content, event_timestamp = timestamp) %>%\n  # Now, find the original sender of this communication event\n  left_join(mc3_edges_cleaned %>%\n              filter(edge_type == \"sent\") %>%\n              select(event_id_match = to_id, sender_id = from_id),\n            by = c(\"event_id\" = \"event_id_match\")) %>%\n  # Join with nodes to get the sender's name AND sub_type\n  left_join(mc3_nodes_cleaned %>% select(id, name, sub_type), # Select sub_type here\n            by = c(\"sender_id\" = \"id\")) %>%\n  rename(sender_name = name, sender_sub_type = sub_type) %>% # Rename sub_type\n  # Select and rename final columns for received communications\n  select(\n    communication_type = edge_type, # This will be \"received\"\n    sender_id,\n    sender_name,\n    sender_sub_type, # Include in final select\n    recipient_id = to_id,\n    event_id,\n    content = event_content,\n    timestamp = event_timestamp\n  ) %>%\n  mutate(\n    recipient_name = !!nadia_id, # Explicitly set recipient_name to Nadia's ID/name using !!\n    recipient_sub_type = !!nadia_sub_type # Assign Nadia's sub_type as a constant value using !!\n  )\n\nprint(\"--- Nadia's Received Communications ---\")\nprint(kable(head(nadia_received_communications, 10), format = \"markdown\", align = \"l\"))\n\n# --- 7. Combine Sent and Received Communications for Full Timeline ---\nnadia_full_communications_timeline <- bind_rows(\n  nadia_sent_communications,\n  nadia_received_communications\n) %>%\n  arrange(timestamp) %>%\n  # CRITICAL FIX: Explicitly convert timestamp to POSIXct after bind_rows\n  # Use as.POSIXct with the observed format string\n  mutate(timestamp = as.POSIXct(timestamp, format = \"%Y-%m-%d %H:%M:%S\")) %>%\n  # NEW: Create a sorted communicating pair for consistent coloring\n  rowwise() %>% # Process row by row\n  mutate(communicating_pair_sorted = paste(sort(c(sender_name, recipient_name)), collapse = \"_\")) %>%\n  ungroup() # Return to normal data frame operations\n\nprint(\"--- Nadia's Full Communication Timeline (Combined) ---\")\nprint(kable(head(nadia_full_communications_timeline, 10), format = \"markdown\", align = \"l\"))\n\n# --- 8. Prepare Data for Ego Network Visualization (Direct Person-to-Person/Entity) ---\n# Build nodes and edges directly from nadia_full_communications_timeline,\n# focusing on direct sender-recipient connections.\n# Nodes for the ego network graph: Collect all unique sender and recipient IDs\nall_ego_person_entity_ids <- nadia_full_communications_timeline %>%\n  select(id = sender_id) %>%\n  bind_rows(nadia_full_communications_timeline %>% select(id = recipient_id)) %>%\n  distinct(id) %>%\n  filter(!is.na(id)) # Ensure no NA IDs\n\n# Filter mc3_nodes_cleaned to get attributes for these person/entity nodes\nego_nodes_for_graph <- mc3_nodes_cleaned %>%\n  filter(id %in% all_ego_person_entity_ids$id) %>%\n  filter(!is.na(id)) %>% # Ensure no NA IDs in nodes for graph\n  # Add attributes for visualization\n  mutate(\n    is_nadia = ifelse(id == nadia_id, TRUE, FALSE),\n    # Create a new column for legend grouping that includes Nadia as a distinct category\n    node_legend_group = ifelse(is_nadia, \"Nadia Conti\", sub_type),\n    node_size = ifelse(is_nadia, 20, 18), # Further increased node sizes: Nadia 20, others 10\n    display_name = ifelse(is_nadia, \"Nadia Conti\", name) # Use actual name for others\n  ) %>%\n  filter(!is.na(sub_type)) # Ensure nodes have a sub_type for consistent plotting\n\n# Calculate communication counts for each node for hover text\nnode_comm_summary <- nadia_full_communications_timeline %>%\n  group_by(id = sender_id) %>%\n  summarise(sent_count = n(), .groups = 'drop') %>%\n  full_join(nadia_full_communications_timeline %>%\n              group_by(id = recipient_id) %>%\n              summarise(received_count = n(), .groups = 'drop'),\n            by = \"id\") %>%\n  mutate(\n    sent_count = replace_na(sent_count, 0),\n    received_count = replace_na(received_count, 0)\n  )\n\n# Join communication summary and create hover text for nodes\nego_nodes_for_graph <- ego_nodes_for_graph %>%\n  left_join(node_comm_summary, by = \"id\") %>%\n  mutate(\n    hover_text = paste(\n      \"Name:\", display_name, \"<br>\",\n      \"Type:\", node_legend_group, \"<br>\",\n      \"Sent Communications:\", sent_count, \"<br>\",\n      \"Received Communications:\", received_count\n    )\n  )\n\n# Edges for the ego network graph: Direct Sender -> Recipient edges\n# Aggregate to count occurrences for edge thickness\nego_edges_for_graph <- nadia_full_communications_timeline %>%\n  # Group by sender, recipient, their names, and communication type to count interactions\n  group_by(from = sender_id, to = recipient_id, sender_name, recipient_name, communication_type) %>%\n  summarise(\n    count_of_comm = n(), # Number of times this specific communication happened\n    content_sample = paste(head(content, 1), collapse = \"; \"), # Sample content\n    timestamp_min = min(timestamp, na.rm = TRUE),\n    timestamp_max = max(timestamp, na.rm = TRUE),\n    .groups = 'drop'\n  ) %>%\n  # Add the 'nadia_role_in_comm' column for coloring based on Nadia's perspective\n  mutate(\n    nadia_role_in_comm = case_when(\n      from == nadia_id & communication_type == \"sent\" ~ \"Nadia Sent\",\n      to == nadia_id & communication_type == \"received\" ~ \"Nadia Received\",\n      TRUE ~ \"Other Communication\" # For communications not directly involving Nadia as sender/recipient\n    )\n  ) %>%\n  # Ensure 'from' and 'to' are character and non-NA\n  mutate(\n    from = as.character(from),\n    to = as.character(to)\n  ) %>%\n  filter(!is.na(from) & !is.na(to)) %>%\n  # Filter out edges where 'from' or 'to' IDs are NOT in the final ego_nodes_for_graph\n  filter(from %in% ego_nodes_for_graph$id, to %in% ego_nodes_for_graph$id) %>%\n  # Create hover text for edges\n  mutate(\n    hover_text = paste(\n      \"From:\", sender_name, \"<br>\",\n      \"To:\", recipient_name, \"<br>\",\n      \"Type:\", communication_type, \"<br>\",\n      \"Count:\", count_of_comm, \"<br>\",\n      \"First:\", format(timestamp_min, \"%Y-%m-%d %H:%M:%S\"), \"<br>\",\n      \"Last:\", format(timestamp_max, \"%Y-%m-%d %H:%M:%S\"), \"<br>\",\n      \"Content Sample:\", content_sample\n    )\n  )\n\n# Create the tbl_graph object for the ego network\nnadia_ego_network_graph <- tbl_graph(nodes = ego_nodes_for_graph, edges = ego_edges_for_graph, directed = TRUE)\n\nprint(\"--- Checking: Number of nodes and edges in Nadia's Ego Network Graph ---\")\nprint(paste(\"Nodes:\", gorder(nadia_ego_network_graph), \"Edges:\", gsize(nadia_ego_network_graph)))\nprint(\"---------------------------------------------------------------------\")\n```\n\n## The Code\n\n``` r\n# --- 2. Clean and Prepare Nodes ---\nmc3_nodes_cleaned <- mc3_nodes_raw %>%\n  mutate(id = as.character(id)) %>%\n  filter(!is.na(id)) %>%\n  distinct(id, .keep_all = TRUE) %>%\n  # Rename 'type' to 'supertype' to reduce confusion with communication type\n  rename(supertype = type) %>%\n  # Select only columns that are needed and are consistently present\n  select(id, name, sub_type, content, timestamp) # Keep timestamp as character for now\n\n# --- 3. Clean and Prepare Edges ---\n# Rename 'type' in edges to 'edge_type' to avoid conflict with node 'supertype'\nmc3_edges_cleaned <- mc3_edges_raw %>%\n  rename(from_id = source,\n         to_id = target,\n         edge_type = type) %>% # Renamed 'type' to 'edge_type'\n  mutate(across(c(from_id, to_id), as.character)) %>%\n  # Filter out any edges where from_id or to_id are not in cleaned nodes\n  filter(from_id %in% mc3_nodes_cleaned$id,\n         to_id %in% mc3_nodes_cleaned$id)\n\n# --- 4. Identify Nadia Conti's ID and Sub_type ---\nnadia_info <- mc3_nodes_cleaned %>%\n  filter(name == \"Nadia Conti\") %>%\n  select(id, sub_type) # Corrected: Select sub_type here, not supertype\n\nnadia_id <- nadia_info %>% pull(id)\nnadia_sub_type <- nadia_info %>% pull(sub_type) # New variable for Nadia's sub_type\n\n\nif (length(nadia_id) == 0) {\n  stop(\"Nadia Conti not found in the nodes data. Please check the 'name' column or the ID.\")\n} else if (length(nadia_id) > 1) {\n  warning(\"Multiple entries found for Nadia Conti. Using the first one.\")\n  nadia_id <- nadia_id[1]\n  nadia_sub_type <- nadia_sub_type[1] # Ensure sub_type is also taken for the first one\n}\n\nprint(paste(\"Nadia Conti's ID:\", nadia_id))\nprint(paste(\"Nadia Conti's Sub_type:\", nadia_sub_type))\n\n# --- 5. Extract Nadia's Sent Communications ---\n# Logic: Nadia (source) --sent--> Event_Communication (target) --received--> Recipient (target)\nnadia_sent_communications <- mc3_edges_cleaned %>%\n  filter(from_id == nadia_id, edge_type == \"sent\") %>%\n  # Join with nodes to get content and timestamp of the Event_Communication node\n  left_join(mc3_nodes_cleaned %>% select(id, content, timestamp),\n            by = c(\"to_id\" = \"id\")) %>%\n  rename(event_id = to_id, event_content = content, event_timestamp = timestamp) %>%\n  # Now, find the recipient of this communication event\n  left_join(mc3_edges_cleaned %>%\n              filter(edge_type == \"received\") %>%\n              select(event_id_match = from_id, recipient_id = to_id),\n            by = c(\"event_id\" = \"event_id_match\")) %>%\n  # Join with nodes to get the recipient's name AND sub_type\n  left_join(mc3_nodes_cleaned %>% select(id, name, sub_type), # Select sub_type here\n            by = c(\"recipient_id\" = \"id\")) %>%\n  rename(recipient_name = name, recipient_sub_type = sub_type) %>% # Rename sub_type\n  # Select and rename final columns for sent communications\n  select(\n    communication_type = edge_type, # This will be \"sent\"\n    sender_id = from_id,\n    recipient_id,\n    recipient_name,\n    recipient_sub_type, # Include in final select\n    event_id,\n    content = event_content,\n    timestamp = event_timestamp # Timestamp is still character here\n  ) %>%\n  mutate(\n    sender_name = !!nadia_id, # Explicitly set sender_name to Nadia's ID/name using !!\n    sender_sub_type = !!nadia_sub_type # Assign Nadia's sub_type as a constant value using !!\n  )\n\nprint(\"--- Nadia's Sent Communications ---\")\nprint(kable(head(nadia_sent_communications, 10), format = \"markdown\", align = \"l\"))\n\n\n# --- 6. Extract Nadia's Received Communications ---\n# Logic: Sender (source) --sent--> Event_Communication (target) --received--> Nadia (target)\nnadia_received_communications <- mc3_edges_cleaned %>%\n  filter(to_id == nadia_id, edge_type == \"received\") %>%\n  # The source of this edge is the Event_Communication node\n  rename(event_id = from_id) %>%\n  # Join with nodes to get content and timestamp of the Event_Communication node\n  left_join(mc3_nodes_cleaned %>% select(id, content, timestamp),\n            by = c(\"event_id\" = \"id\")) %>%\n  rename(event_content = content, event_timestamp = timestamp) %>%\n  # Now, find the original sender of this communication event\n  left_join(mc3_edges_cleaned %>%\n              filter(edge_type == \"sent\") %>%\n              select(event_id_match = to_id, sender_id = from_id),\n            by = c(\"event_id\" = \"event_id_match\")) %>%\n  # Join with nodes to get the sender's name AND sub_type\n  left_join(mc3_nodes_cleaned %>% select(id, name, sub_type), # Select sub_type here\n            by = c(\"sender_id\" = \"id\")) %>%\n  rename(sender_name = name, sender_sub_type = sub_type) %>% # Rename sub_type\n  # Select and rename final columns for received communications\n  select(\n    communication_type = edge_type, # This will be \"received\"\n    sender_id,\n    sender_name,\n    sender_sub_type, # Include in final select\n    recipient_id = to_id,\n    event_id,\n    content = event_content,\n    timestamp = event_timestamp\n  ) %>%\n  mutate(\n    recipient_name = !!nadia_id, # Explicitly set recipient_name to Nadia's ID/name using !!\n    recipient_sub_type = !!nadia_sub_type # Assign Nadia's sub_type as a constant value using !!\n  )\n\nprint(\"--- Nadia's Received Communications ---\")\nprint(kable(head(nadia_received_communications, 10), format = \"markdown\", align = \"l\"))\n\n# --- 7. Combine Sent and Received Communications for Full Timeline ---\nnadia_full_communications_timeline <- bind_rows(\n  nadia_sent_communications,\n  nadia_received_communications\n) %>%\n  arrange(timestamp) %>%\n  # CRITICAL FIX: Explicitly convert timestamp to POSIXct after bind_rows\n  # Use as.POSIXct with the observed format string\n  mutate(timestamp = as.POSIXct(timestamp, format = \"%Y-%m-%d %H:%M:%S\")) %>%\n  # NEW: Create a sorted communicating pair for consistent coloring\n  rowwise() %>% # Process row by row\n  mutate(communicating_pair_sorted = paste(sort(c(sender_name, recipient_name)), collapse = \"_\")) %>%\n  ungroup() # Return to normal data frame operations\n\nprint(\"--- Nadia's Full Communication Timeline (Combined) ---\")\nprint(kable(head(nadia_full_communications_timeline, 10), format = \"markdown\", align = \"l\"))\n\n# --- 8. Prepare Data for Ego Network Visualization (Direct Person-to-Person/Entity) ---\n# Build nodes and edges directly from nadia_full_communications_timeline,\n# focusing on direct sender-recipient connections.\n# Nodes for the ego network graph: Collect all unique sender and recipient IDs\nall_ego_person_entity_ids <- nadia_full_communications_timeline %>%\n  select(id = sender_id) %>%\n  bind_rows(nadia_full_communications_timeline %>% select(id = recipient_id)) %>%\n  distinct(id) %>%\n  filter(!is.na(id)) # Ensure no NA IDs\n\n# Filter mc3_nodes_cleaned to get attributes for these person/entity nodes\nego_nodes_for_graph <- mc3_nodes_cleaned %>%\n  filter(id %in% all_ego_person_entity_ids$id) %>%\n  filter(!is.na(id)) %>% # Ensure no NA IDs in nodes for graph\n  # Add attributes for visualization\n  mutate(\n    is_nadia = ifelse(id == nadia_id, TRUE, FALSE),\n    # Create a new column for legend grouping that includes Nadia as a distinct category\n    node_legend_group = ifelse(is_nadia, \"Nadia Conti\", sub_type),\n    node_size = ifelse(is_nadia, 20, 18), # Further increased node sizes: Nadia 20, others 10\n    display_name = ifelse(is_nadia, \"Nadia Conti\", name) # Use actual name for others\n  ) %>%\n  filter(!is.na(sub_type)) # Ensure nodes have a sub_type for consistent plotting\n\n# Calculate communication counts for each node for hover text\nnode_comm_summary <- nadia_full_communications_timeline %>%\n  group_by(id = sender_id) %>%\n  summarise(sent_count = n(), .groups = 'drop') %>%\n  full_join(nadia_full_communications_timeline %>%\n              group_by(id = recipient_id) %>%\n              summarise(received_count = n(), .groups = 'drop'),\n            by = \"id\") %>%\n  mutate(\n    sent_count = replace_na(sent_count, 0),\n    received_count = replace_na(received_count, 0)\n  )\n\n# Join communication summary and create hover text for nodes\nego_nodes_for_graph <- ego_nodes_for_graph %>%\n  left_join(node_comm_summary, by = \"id\") %>%\n  mutate(\n    hover_text = paste(\n      \"Name:\", display_name, \"<br>\",\n      \"Type:\", node_legend_group, \"<br>\",\n      \"Sent Communications:\", sent_count, \"<br>\",\n      \"Received Communications:\", received_count\n    )\n  )\n\n# Edges for the ego network graph: Direct Sender -> Recipient edges\n# Aggregate to count occurrences for edge thickness\nego_edges_for_graph <- nadia_full_communications_timeline %>%\n  # Group by sender, recipient, their names, and communication type to count interactions\n  group_by(from = sender_id, to = recipient_id, sender_name, recipient_name, communication_type) %>%\n  summarise(\n    count_of_comm = n(), # Number of times this specific communication happened\n    content_sample = paste(head(content, 1), collapse = \"; \"), # Sample content\n    timestamp_min = min(timestamp, na.rm = TRUE),\n    timestamp_max = max(timestamp, na.rm = TRUE),\n    .groups = 'drop'\n  ) %>%\n  # Add the 'nadia_role_in_comm' column for coloring based on Nadia's perspective\n  mutate(\n    nadia_role_in_comm = case_when(\n      from == nadia_id & communication_type == \"sent\" ~ \"Nadia Sent\",\n      to == nadia_id & communication_type == \"received\" ~ \"Nadia Received\",\n      TRUE ~ \"Other Communication\" # For communications not directly involving Nadia as sender/recipient\n    )\n  ) %>%\n  # Ensure 'from' and 'to' are character and non-NA\n  mutate(\n    from = as.character(from),\n    to = as.character(to)\n  ) %>%\n  filter(!is.na(from) & !is.na(to)) %>%\n  # Filter out edges where 'from' or 'to' IDs are NOT in the final ego_nodes_for_graph\n  filter(from %in% ego_nodes_for_graph$id, to %in% ego_nodes_for_graph$id) %>%\n  # Create hover text for edges\n  mutate(\n    hover_text = paste(\n      \"From:\", sender_name, \"<br>\",\n      \"To:\", recipient_name, \"<br>\",\n      \"Type:\", communication_type, \"<br>\",\n      \"Count:\", count_of_comm, \"<br>\",\n      \"First:\", format(timestamp_min, \"%Y-%m-%d %H:%M:%S\"), \"<br>\",\n      \"Last:\", format(timestamp_max, \"%Y-%m-%d %H:%M:%S\"), \"<br>\",\n      \"Content Sample:\", content_sample\n    )\n  )\n\n# Create the tbl_graph object for the ego network\nnadia_ego_network_graph <- tbl_graph(nodes = ego_nodes_for_graph, edges = ego_edges_for_graph, directed = TRUE)\n\nprint(\"--- Checking: Number of nodes and edges in Nadia's Ego Network Graph ---\")\nprint(paste(\"Nodes:\", gorder(nadia_ego_network_graph), \"Edges:\", gsize(nadia_ego_network_graph)))\nprint(\"---------------------------------------------------------------------\")\n```\n:::\n\n### 9.2.2 Nadia's Sent and Received Ego Networks\n\n### 9.2.2.1 Sent Communications Network\n\n::: no-code-fold\n```{r, echo=FALSE}\n\n# Define custom colors for node types (reusing from previous code)\nnode_legend_colors_plot <- c(\n  \"Person\" = \"#88CCEE\",      # Blue\n  \"Vessel\" = \"#D55E00\",      # Orange\n  \"Organization\" = \"#117733\", # Green\n  \"Location\" = \"#AA4499\",   # Purple\n  \"Nadia Conti\" = \"red\"      # Special color for Nadia\n)\n\n# Define custom shapes for node subtypes\nnode_legend_shapes_plot <- c(\n  \"Person\" = \"dot\",        # Circle for visNetwork\n  \"Vessel\" = \"triangle\",\n  \"Organization\" = \"square\",\n  \"Location\" = \"diamond\",\n  \"Nadia Conti\" = \"star\"   # Star shape for Nadia in visNetwork\n)\n\n# Separate the edges into two sets: Nadia Sent and Nadia Received\nedges_sent <- ego_edges_for_graph %>%\n  filter(nadia_role_in_comm == \"Nadia Sent\")\n\nedges_received <- ego_edges_for_graph %>%\n  filter(nadia_role_in_comm == \"Nadia Received\")\n\n# Function to build visNetwork plot for a given edge set\nbuild_visnetwork_plot <- function(edge_df, title_label) {\n  # Prepare nodes from edge list\n  node_ids <- unique(c(edge_df$from, edge_df$to))\n\n  nodes <- ego_nodes_for_graph %>%\n    filter(id %in% node_ids) %>%\n    mutate(\n      label = ifelse(display_name == \"Nadia Conti\", \"\", display_name),\n      title = paste0(\n        \"<b>\", display_name, \"</b><br>\",\n        \"Type: \", node_legend_group, \"<br>\",\n        \"Sent: \", sent_count, \"<br>\",\n        \"Received: \", received_count\n      ),\n      group = ifelse(display_name == \"Nadia Conti\", \"Nadia Conti\", node_legend_group)\n    ) %>%\n    select(id, label, title, group, value = node_size)\n\n  # Prepare edges with arrow and tooltip\n  edges <- edge_df %>%\n    filter(!is.na(from) & !is.na(to)) %>%\n    mutate(\n      arrows = \"to\",\n      title = paste0(\n        \"<b>From:</b> \", sender_name, \"<br>\",\n        \"<b>To:</b> \", recipient_name, \"<br>\",\n        \"<b>Type:</b> \", communication_type, \"<br>\",\n        \"<b>Count:</b> \", count_of_comm, \"<br>\",\n        \"<b>First:</b> \", format(timestamp_min, \"%Y-%m-%d %H:%M:%S\"), \"<br>\",\n        \"<b>Last:</b> \", format(timestamp_max, \"%Y-%m-%d %H:%M:%S\"), \"<br>\",\n      \"<b>Content Sample:</b><br><div style='max-width:300px;white-space:normal;'>\", content_sample, \"</div>\"\n      )\n    ) %>%\n    select(from, to, arrows, title, width = count_of_comm)\n\n  # Create visNetwork\n  visNetwork(nodes, edges, width = \"100%\", height = \"600px\") %>%\n    visEdges(smooth = FALSE, arrows = list(to = list(enabled = TRUE, scaleFactor = 1.5))) %>%\n    visOptions(highlightNearest = TRUE, nodesIdSelection = TRUE) %>%\n    visIgraphLayout(layout = \"layout_with_fr\") %>%\n    visNodes(font = list(size = 14)) %>%\n    visGroups(groupname = \"Person\", color = node_legend_colors_plot[[\"Person\"]], shape = node_legend_shapes_plot[[\"Person\"]]) %>%\n    visGroups(groupname = \"Vessel\", color = node_legend_colors_plot[[\"Vessel\"]], shape = node_legend_shapes_plot[[\"Vessel\"]]) %>%\n    visGroups(groupname = \"Organization\", color = node_legend_colors_plot[[\"Organization\"]], shape = node_legend_shapes_plot[[\"Organization\"]]) %>%\n    visGroups(groupname = \"Location\", color = node_legend_colors_plot[[\"Location\"]], shape = node_legend_shapes_plot[[\"Location\"]]) %>%\n    visGroups(groupname = \"Nadia Conti\", color = node_legend_colors_plot[[\"Nadia Conti\"]], shape = node_legend_shapes_plot[[\"Nadia Conti\"]]) %>%\n      visLegend(\n    addNodes = legend_df,\n    ncol = 2,\n    position = \"left\",\n    main = \"Entity (Sub)Types\",\n    useGroups = FALSE) %>%\n    visLayout(randomSeed = 123) %>%\n    visNetwork::visExport() %>%\n    visNetwork::visPhysics(enabled = TRUE) %>%\n    visNetwork::visInteraction(navigationButtons = TRUE) %>%\n    visNetwork::visEvents(stabilizationIterationsDone = \"function () {this.setOptions({physics:false});}\")\n}\n\n# Build and show visNetwork plots\nbuild_visnetwork_plot(edges_sent, \"Nadia Sent Ego Network\")\n```\n:::\n\n```{r, results=FALSE}\n#| code-fold: true\n#| code-summary: \"Show the code\"\n# Define custom colors for node types (reusing from previous code)\nnode_legend_colors_plot <- c(\n  \"Person\" = \"#88CCEE\",      # Blue\n  \"Vessel\" = \"#D55E00\",      # Orange\n  \"Organization\" = \"#117733\", # Green\n  \"Location\" = \"#AA4499\",   # Purple\n  \"Nadia Conti\" = \"red\"      # Special color for Nadia\n)\n\n# Define custom shapes for node subtypes\nnode_legend_shapes_plot <- c(\n  \"Person\" = \"dot\",        # Circle for visNetwork\n  \"Vessel\" = \"triangle\",\n  \"Organization\" = \"square\",\n  \"Location\" = \"diamond\",\n  \"Nadia Conti\" = \"star\"   # Star shape for Nadia in visNetwork\n)\n\n# Separate the edges into two sets: Nadia Sent and Nadia Received\nedges_sent <- ego_edges_for_graph %>%\n  filter(nadia_role_in_comm == \"Nadia Sent\")\n\nedges_received <- ego_edges_for_graph %>%\n  filter(nadia_role_in_comm == \"Nadia Received\")\n\n# Function to build visNetwork plot for a given edge set\nbuild_visnetwork_plot <- function(edge_df, title_label) {\n  # Prepare nodes from edge list\n  node_ids <- unique(c(edge_df$from, edge_df$to))\n\n  nodes <- ego_nodes_for_graph %>%\n    filter(id %in% node_ids) %>%\n    mutate(\n      label = ifelse(display_name == \"Nadia Conti\", \"\", display_name),\n      title = paste0(\n        \"<b>\", display_name, \"</b><br>\",\n        \"Type: \", node_legend_group, \"<br>\",\n        \"Sent: \", sent_count, \"<br>\",\n        \"Received: \", received_count\n      ),\n      group = ifelse(display_name == \"Nadia Conti\", \"Nadia Conti\", node_legend_group)\n    ) %>%\n    select(id, label, title, group, value = node_size)\n\n  # Prepare edges with arrow and tooltip\n  edges <- edge_df %>%\n    filter(!is.na(from) & !is.na(to)) %>%\n    mutate(\n      arrows = \"to\",\n      title = paste0(\n        \"<b>From:</b> \", sender_name, \"<br>\",\n        \"<b>To:</b> \", recipient_name, \"<br>\",\n        \"<b>Type:</b> \", communication_type, \"<br>\",\n        \"<b>Count:</b> \", count_of_comm, \"<br>\",\n        \"<b>First:</b> \", format(timestamp_min, \"%Y-%m-%d %H:%M:%S\"), \"<br>\",\n        \"<b>Last:</b> \", format(timestamp_max, \"%Y-%m-%d %H:%M:%S\"), \"<br>\",\n      \"<b>Content Sample:</b><br><div style='max-width:300px;white-space:normal;'>\", content_sample, \"</div>\"\n      )\n    ) %>%\n    select(from, to, arrows, title, width = count_of_comm)\n\n  # Create visNetwork\n  visNetwork(nodes, edges, width = \"100%\", height = \"600px\") %>%\n    visEdges(smooth = FALSE, arrows = list(to = list(enabled = TRUE, scaleFactor = 1.5))) %>%\n    visOptions(highlightNearest = TRUE, nodesIdSelection = TRUE) %>%\n    visIgraphLayout(layout = \"layout_with_fr\") %>%\n    visNodes(font = list(size = 14)) %>%\n    visGroups(groupname = \"Person\", color = node_legend_colors_plot[[\"Person\"]], shape = node_legend_shapes_plot[[\"Person\"]]) %>%\n    visGroups(groupname = \"Vessel\", color = node_legend_colors_plot[[\"Vessel\"]], shape = node_legend_shapes_plot[[\"Vessel\"]]) %>%\n    visGroups(groupname = \"Organization\", color = node_legend_colors_plot[[\"Organization\"]], shape = node_legend_shapes_plot[[\"Organization\"]]) %>%\n    visGroups(groupname = \"Location\", color = node_legend_colors_plot[[\"Location\"]], shape = node_legend_shapes_plot[[\"Location\"]]) %>%\n    visGroups(groupname = \"Nadia Conti\", color = node_legend_colors_plot[[\"Nadia Conti\"]], shape = node_legend_shapes_plot[[\"Nadia Conti\"]]) %>%\n      visLegend(\n    addNodes = legend_df,\n    ncol = 2,\n    position = \"left\",\n    main = \"Entity (Sub)Types\",\n    useGroups = FALSE) %>%\n    visLayout(randomSeed = 123) %>%\n    visNetwork::visExport() %>%\n    visNetwork::visPhysics(enabled = TRUE) %>%\n    visNetwork::visInteraction(navigationButtons = TRUE) %>%\n    visNetwork::visEvents(stabilizationIterationsDone = \"function () {this.setOptions({physics:false});}\")\n}\n\n# Build and show visNetwork plots\nbuild_visnetwork_plot(edges_sent, \"Nadia Sent Ego Network\")\n```\n\n### 9.2.2.2 Received Communications Network\n\n::: no-code-fold\n```{r, echo=FALSE}\n\nbuild_visnetwork_plot(edges_received, \"Nadia Received Ego Network\")\n```\n:::\n\n```{r, results=FALSE}\n#| code-fold: true\n#| code-summary: \"Show the code\"\nbuild_visnetwork_plot(edges_received, \"Nadia Received Ego Network\")\n```\n\n### **9.2.3 Findings**:\n\nWe then wanted to find more about the correspondences. The first graph illustrated Nadia's sent communications and the second graph were her received communications. Hover over nodes to see the sent or received count from the perspective of the entity. Hover over arrowheads to see the number, direction, count, first and last correspondence time, type of sent or received, and content of one communication. Nadia sent only 8 but received 18 communications (possibly indicative of using a pseudonym):\n\n-   Nodes involved: Nadia, Davis, Elise, Haacklee Habor, Liam, Marlin, Neptune, Oceanus City Council, Remora, Rodriguez, Sailor Shifts Team, Sentinel, V. Miesel Shipping.\n\n-   Sent more direct communications to Liam (2) and Neptune (2), relative to others.\n\n-   Received more from Davis (5), Elise (3), and Liam (2), relative to others.\n\n-   The next step would be to find out the suspicious characters/ activities.\n\n## 9.3 Nadia's Ego Network: 3-hops degree centrality\n\nTo uncover more details, we designed n-hops degree centrality here. We input 3 hops to hover over the nodes and look into the communications in a wider network. 3-hop exposes overlapping communites (Nadia communicating with someone who coordinates between groups). The \"bridges\" may show their value in 3-hops. It also increases the change of detecting complete or near complete cliques. We understand that should there be requirements for details, we could look into n-hops and more.\n\n::: no-code-fold\n```{r, echo=FALSE}\n#| code-fold: true\n#| code-summary: \"Show the code\"\n\n\n# --- Define event and relationship subtypes (optional, for filtering or labeling) ---\nevent_subtypes <- c(\n  \"Communication\", \"Monitoring\", \"VesselMovement\", \"Assessment\",\n  \"Collaborate\", \"Endorsement\", \"TourActivity\", \"TransponderPing\",\n  \"Harbor Report\", \"Fishing\", \"Criticize\"\n)\n\nrelationship_subtypes <- c(\n  \"Coordinates\", \"AccessPermission\", \"Operates\", \"Colleagues\",\n  \"Suspicious\", \"Reports\", \"Jurisdiction\", \"Unfriendly\", \"Friends\"\n)\n\n# --- Define node colors and shapes by type or key sub-type ---\nnode_legend_colors_plot <- c(\n  \"Person\" = \"#88CCEE\",\n  \"Vessel\" = \"#D55E00\",\n  \"Organization\" = \"#117733\",\n  \"Location\" = \"#AA4499\",\n  \"Group\" = \"#CC79A7\",\n  \"Event\" = \"#DDCC77\",\n  \"Relationship\" = \"#AF8DC3\"\n)\n\nnode_legend_shapes_plot <- c(\n  \"Person\" = \"dot\",\n  \"Vessel\" = \"triangle\",\n  \"Organization\" = \"square\",\n  \"Location\" = \"diamond\",\n  \"Group\" = \"circle\",\n  \"Event\" = \"star\",\n  \"Relationship\" = \"square\"\n)\n\nSTYLES <- list(\n  node_label_dark = \"black\",\n  font_family = \"Roboto Condensed\"\n)\n\n# ---- 2. Define function to extract ego subgraph ----\nextract_ego_subgraph <- function(center_node = \"Nadia Conti\", hops = 3) {\n  # Construct igraph object\n  g <- graph_from_data_frame(\n    d = mc3_edges_final %>% select(from = from_id, to = to_id),\n    vertices = mc3_nodes_final %>% select(id) %>% distinct() %>% rename(name = id),\n    directed = TRUE\n  )\n\n  # Extract ego network\n  ego_graph <- make_ego_graph(g, order = hops, nodes = center_node, mode = \"all\")[[1]]\n  node_ids <- V(ego_graph)$name\n  edge_df <- as_data_frame(ego_graph, what = \"edges\")\n\n  # Prepare node metadata for visNetwork\n  ego_nodes <- mc3_nodes_final %>%\n    filter(id %in% node_ids) %>%\n    mutate(\n      label = ifelse(is.na(name), id, name),\n      tooltip_extra = case_when(\n        type == \"Event\" & sub_type == \"Communication\" ~ content,\n        type == \"Event\" & sub_type == \"Monitoring\" ~ findings,\n        type == \"Event\" & sub_type == \"VesselMovement\" ~ destination,\n        type == \"Event\" & sub_type == \"Assessment\" ~ results,\n        type == \"Relationship\" & sub_type == \"Coordinates\" ~ coordination_type,\n        type == \"Relationship\" & sub_type == \"Operates\" ~ operational_role,\n        type == \"Relationship\" & sub_type == \"Jurisdiction\" ~ jurisdiction_type,\n        TRUE ~ NA_character_\n      ),\n      title = paste0(\n        \"<b>\", label, \"</b><br>\",\n        \"Type: \", type, \"<br>\",\n        \"Sub-type: \", sub_type, \"<br>\",\n        ifelse(!is.na(tooltip_extra), paste0(\"<br><b>Details:</b> \", tooltip_extra), \"\")\n      ),\n      group = case_when(\n        sub_type %in% names(node_legend_colors_plot) ~ sub_type,\n        type %in% names(node_legend_colors_plot) ~ type,\n        TRUE ~ \"Other\"\n      )\n    ) %>%\n    select(id, label, group, title) %>%\n    distinct(id, .keep_all = TRUE)\n\n  list(nodes = ego_nodes, edges = edge_df)\n}\n\n# ---- 3. Extract Nadia Conti's 3-hop ego network ----\nego_data <- extract_ego_subgraph(\"Nadia Conti\", hops = 3)\nnodes <- ego_data$nodes\nedges <- ego_data$edges\n\n# (Optional) Save output\nnadia_ego_nodes_2hop <- nodes\nnadia_ego_edges_2hop <- edges\n\n# ---- 4. Build visNetwork plot ----\nnet <- visNetwork(nodes, edges, width = \"100%\", height = \"600px\") %>%\n  visEdges(arrows = list(to = list(enabled = TRUE, scaleFactor = 1.5))) %>%\n  visOptions(highlightNearest = TRUE, nodesIdSelection = TRUE) %>%\n  visIgraphLayout(layout = \"layout_with_fr\") %>%\n  visNodes(font = list(\n    size = 14,\n    color = STYLES$node_label_dark,\n    face = STYLES$font_family,\n    vadjust = -15\n  ))\n\n# ---- 5. Apply color/shape for known groups ----\nused_groups <- intersect(unique(nodes$group), names(node_legend_colors_plot))\n\nfor (group_name in used_groups) {\n  net <- net %>% visGroups(\n    groupname = group_name,\n    color = node_legend_colors_plot[[group_name]],\n    shape = node_legend_shapes_plot[[group_name]]\n  )\n}\n\n# ---- 6. Add legend dynamically ----\nlegend_df <- tibble::tibble(\n  label = used_groups,\n  shape = node_legend_shapes_plot[used_groups],\n  color = node_legend_colors_plot[used_groups]\n) %>%\n  distinct(label, .keep_all = TRUE)\n\nnet <- net %>% visLegend(\n  addNodes = legend_df,\n  ncol = 2,\n  position = \"left\",\n  main = \"Entity (Sub)Types\",\n  useGroups = FALSE\n)\n\n# ---- 7. Render the network ----\nnet\n\n\n\n```\n:::\n\n```{r, results=FALSE}\n#| code-fold: true\n#| code-summary: \"Show the code\"\n\n# --- Define event and relationship subtypes (optional, for filtering or labeling) ---\nevent_subtypes <- c(\n  \"Communication\", \"Monitoring\", \"VesselMovement\", \"Assessment\",\n  \"Collaborate\", \"Endorsement\", \"TourActivity\", \"TransponderPing\",\n  \"Harbor Report\", \"Fishing\", \"Criticize\"\n)\n\nrelationship_subtypes <- c(\n  \"Coordinates\", \"AccessPermission\", \"Operates\", \"Colleagues\",\n  \"Suspicious\", \"Reports\", \"Jurisdiction\", \"Unfriendly\", \"Friends\"\n)\n\n# --- Define node colors and shapes by type or key sub-type ---\nnode_legend_colors_plot <- c(\n  \"Person\" = \"#88CCEE\",\n  \"Vessel\" = \"#D55E00\",\n  \"Organization\" = \"#117733\",\n  \"Location\" = \"#AA4499\",\n  \"Group\" = \"#CC79A7\",\n  \"Event\" = \"#DDCC77\",\n  \"Relationship\" = \"#AF8DC3\"\n)\n\nnode_legend_shapes_plot <- c(\n  \"Person\" = \"dot\",\n  \"Vessel\" = \"triangle\",\n  \"Organization\" = \"square\",\n  \"Location\" = \"diamond\",\n  \"Group\" = \"circle\",\n  \"Event\" = \"star\",\n  \"Relationship\" = \"square\"\n)\n\nSTYLES <- list(\n  node_label_dark = \"black\",\n  font_family = \"Roboto Condensed\"\n)\n\n# ---- 2. Define function to extract ego subgraph ----\nextract_ego_subgraph <- function(center_node = \"Nadia Conti\", hops = 3) {\n  # Construct igraph object\n  g <- graph_from_data_frame(\n    d = mc3_edges_final %>% select(from = from_id, to = to_id),\n    vertices = mc3_nodes_final %>% select(id) %>% distinct() %>% rename(name = id),\n    directed = TRUE\n  )\n\n  # Extract ego network\n  ego_graph <- make_ego_graph(g, order = hops, nodes = center_node, mode = \"all\")[[1]]\n  node_ids <- V(ego_graph)$name\n  edge_df <- as_data_frame(ego_graph, what = \"edges\")\n\n  # Prepare node metadata for visNetwork\n  ego_nodes <- mc3_nodes_final %>%\n    filter(id %in% node_ids) %>%\n    mutate(\n      label = ifelse(is.na(name), id, name),\n      tooltip_extra = case_when(\n        type == \"Event\" & sub_type == \"Communication\" ~ content,\n        type == \"Event\" & sub_type == \"Monitoring\" ~ findings,\n        type == \"Event\" & sub_type == \"VesselMovement\" ~ destination,\n        type == \"Event\" & sub_type == \"Assessment\" ~ results,\n        type == \"Relationship\" & sub_type == \"Coordinates\" ~ coordination_type,\n        type == \"Relationship\" & sub_type == \"Operates\" ~ operational_role,\n        type == \"Relationship\" & sub_type == \"Jurisdiction\" ~ jurisdiction_type,\n        TRUE ~ NA_character_\n      ),\n      title = paste0(\n        \"<b>\", label, \"</b><br>\",\n        \"Type: \", type, \"<br>\",\n        \"Sub-type: \", sub_type, \"<br>\",\n        ifelse(!is.na(tooltip_extra), paste0(\"<br><b>Details:</b> \", tooltip_extra), \"\")\n      ),\n      group = case_when(\n        sub_type %in% names(node_legend_colors_plot) ~ sub_type,\n        type %in% names(node_legend_colors_plot) ~ type,\n        TRUE ~ \"Other\"\n      )\n    ) %>%\n    select(id, label, group, title) %>%\n    distinct(id, .keep_all = TRUE)\n\n  list(nodes = ego_nodes, edges = edge_df)\n}\n\n# ---- 3. Extract Nadia Conti's 3-hop ego network ----\nego_data <- extract_ego_subgraph(\"Nadia Conti\", hops = 3)\nnodes <- ego_data$nodes\nedges <- ego_data$edges\n\n# (Optional) Save output\nnadia_ego_nodes_2hop <- nodes\nnadia_ego_edges_2hop <- edges\n\n# ---- 4. Build visNetwork plot ----\nnet <- visNetwork(nodes, edges, width = \"100%\", height = \"600px\") %>%\n  visEdges(arrows = list(to = list(enabled = TRUE, scaleFactor = 1.5))) %>%\n  visOptions(highlightNearest = TRUE, nodesIdSelection = TRUE) %>%\n  visIgraphLayout(layout = \"layout_with_fr\") %>%\n  visNodes(font = list(\n    size = 14,\n    color = STYLES$node_label_dark,\n    face = STYLES$font_family,\n    vadjust = -15\n  ))\n\n# ---- 5. Apply color/shape for known groups ----\nused_groups <- intersect(unique(nodes$group), names(node_legend_colors_plot))\n\nfor (group_name in used_groups) {\n  net <- net %>% visGroups(\n    groupname = group_name,\n    color = node_legend_colors_plot[[group_name]],\n    shape = node_legend_shapes_plot[[group_name]]\n  )\n}\n\n# ---- 6. Add legend dynamically ----\nlegend_df <- tibble::tibble(\n  label = used_groups,\n  shape = node_legend_shapes_plot[used_groups],\n  color = node_legend_colors_plot[used_groups]\n) %>%\n  distinct(label, .keep_all = TRUE)\n\nnet <- net %>% visLegend(\n  addNodes = legend_df,\n  ncol = 2,\n  position = \"left\",\n  main = \"Entity (Sub)Types\",\n  useGroups = FALSE\n)\n\n# ---- 7. Render the network ----\nnet\n\n\n```\n\n#### **9.3.1 Findings**:\n\n-   Nodes from 1-hop: Nadia, Davis, Elise, Haacklee Habor, Liam, Marlin, Neptune, Oceanus City Council, Remora, Rodriguez, Sailor Shifts Team, Sentinel, V. Miesel Shipping.\n\n-   Additional nodes from 3-hop: Conservation vessels, EcoVigil, Sam, The Accountant, Mako, Nemo Reef.\n\n-   We would then use these 3-hop nodes to drill in deeper to find suspicious relationships between nodes.\n\n# Question 4b)\n\n## **9.4 Summary of Nadia's Actions**\n\n### 9.4.1 Sequential Timeline in Table (3-hop)\n\n::: panel-tabset\n## The Suspicious Entities\n\n```{r, echo=FALSE}\n# Extract Nadia Conti's 3-hop ego network\n\n# ---- Step 1: Create igraph from edge list ----\ng <- graph_from_data_frame(\n  d = mc3_edges_final %>% select(from = from_id, to = to_id),\n  vertices = mc3_nodes_final %>% select(id) %>% distinct() %>% rename(name = id),\n  directed = TRUE\n)\n\n# ---- Step 2: Extract 3-hop ego network for Nadia Conti ----\nego_graph <- make_ego_graph(g, order = 3, nodes = \"Nadia Conti\", mode = \"all\")[[1]]\nnode_ids <- V(ego_graph)$name\nedge_df <- as_data_frame(ego_graph, what = \"edges\")\n\n# ---- Step 3: Enrich ego nodes with labels and metadata ----\nnadia_ego_nodes_3hop <- mc3_nodes_final %>%\n  filter(id %in% node_ids) %>%\n  mutate(\n    label = ifelse(is.na(name), id, name),\n    tooltip_extra = case_when(\n      type == \"Event\" & sub_type == \"Communication\" ~ content,\n      type == \"Event\" & sub_type == \"Monitoring\" ~ findings,\n      type == \"Event\" & sub_type == \"VesselMovement\" ~ destination,\n      type == \"Event\" & sub_type == \"Assessment\" ~ results,\n      type == \"Relationship\" & sub_type == \"Coordinates\" ~ coordination_type,\n      type == \"Relationship\" & sub_type == \"Operates\" ~ operational_role,\n      type == \"Relationship\" & sub_type == \"Jurisdiction\" ~ jurisdiction_type,\n      TRUE ~ NA_character_\n    )\n  )\n\n# ---- Step 4: Enrich edges with sender/recipient names and types ----\nnadia_ego_edges_3hop <- edge_df %>%\n  left_join(nadia_ego_nodes_3hop %>% select(id, sender_name = label, sender_sub_type = sub_type), by = c(\"from\" = \"id\")) %>%\n  left_join(nadia_ego_nodes_3hop %>% select(id, recipient_name = label, recipient_sub_type = sub_type), by = c(\"to\" = \"id\"))\n\n# ---- Step 5: Create detailed communication dataframe ----\nnadia_ego_comm_df_3hop <- edge_df %>%\n  left_join(\n    nadia_ego_nodes_3hop %>%\n      select(id, name, sub_type),\n    by = c(\"from\" = \"id\")\n  ) %>%\n  rename(\n    sender_id = from,\n    sender_name = name,\n    sender_type = sub_type\n  ) %>%\n  left_join(\n    nadia_ego_nodes_3hop %>%\n      select(id, name, sub_type, content, findings, destination, results,\n             coordination_type, operational_role, jurisdiction_type, timestamp),\n    by = c(\"to\" = \"id\")\n  ) %>%\n  rename(\n    recipient_id = to,\n    recipient_name = name,\n    recipient_type = sub_type\n  ) %>%\n  mutate(\n    details = coalesce(content, findings, destination, results,\n                       coordination_type, operational_role, jurisdiction_type),\n    timestamp = suppressWarnings(ymd_hms(timestamp))\n  ) %>%\n  select(\n    sender_id, sender_name, sender_type,\n    recipient_id, recipient_name, recipient_type,\n    timestamp, details\n  )\n\n# ---- Step 6: Filter for 'suspicious' in any relevant field ----\nsuspicious_links <- nadia_ego_comm_df_3hop %>%\n  filter(\n    grepl(\"suspicious\", sender_id, ignore.case = TRUE) |\n    grepl(\"suspicious\", sender_type, ignore.case = TRUE) |\n    grepl(\"suspicious\", recipient_id, ignore.case = TRUE) |\n    grepl(\"suspicious\", recipient_type, ignore.case = TRUE)\n  ) %>%\n  select(\n    sender_id, sender_name, sender_type,\n    recipient_id, recipient_name, recipient_type\n  )\n\n\n# ---- Step 7: View suspicious interactions ----\nunique_ids <- unique(c(suspicious_links$sender_id, suspicious_links$recipient_id))\nprint(unique_ids)\n\n```\n\n## The Code\n\n``` r\n# Extract Nadia Conti's 3-hop ego network\n#| code-fold: true\n#| code-summary: \"Show the code\"\n\n# ---- Step 1: Create igraph from edge list ----\ng <- graph_from_data_frame(\n  d = mc3_edges_final %>% select(from = from_id, to = to_id),\n  vertices = mc3_nodes_final %>% select(id) %>% distinct() %>% rename(name = id),\n  directed = TRUE\n)\n\n# ---- Step 2: Extract 3-hop ego network for Nadia Conti ----\nego_graph <- make_ego_graph(g, order = 3, nodes = \"Nadia Conti\", mode = \"all\")[[1]]\nnode_ids <- V(ego_graph)$name\nedge_df <- as_data_frame(ego_graph, what = \"edges\")\n\n# ---- Step 3: Enrich ego nodes with labels and metadata ----\nnadia_ego_nodes_3hop <- mc3_nodes_final %>%\n  filter(id %in% node_ids) %>%\n  mutate(\n    label = ifelse(is.na(name), id, name),\n    tooltip_extra = case_when(\n      type == \"Event\" & sub_type == \"Communication\" ~ content,\n      type == \"Event\" & sub_type == \"Monitoring\" ~ findings,\n      type == \"Event\" & sub_type == \"VesselMovement\" ~ destination,\n      type == \"Event\" & sub_type == \"Assessment\" ~ results,\n      type == \"Relationship\" & sub_type == \"Coordinates\" ~ coordination_type,\n      type == \"Relationship\" & sub_type == \"Operates\" ~ operational_role,\n      type == \"Relationship\" & sub_type == \"Jurisdiction\" ~ jurisdiction_type,\n      TRUE ~ NA_character_\n    )\n  )\n\n# ---- Step 4: Enrich edges with sender/recipient names and types ----\nnadia_ego_edges_3hop <- edge_df %>%\n  left_join(nadia_ego_nodes_3hop %>% select(id, sender_name = label, sender_sub_type = sub_type), by = c(\"from\" = \"id\")) %>%\n  left_join(nadia_ego_nodes_3hop %>% select(id, recipient_name = label, recipient_sub_type = sub_type), by = c(\"to\" = \"id\"))\n\n# ---- Step 5: Create detailed communication dataframe ----\nnadia_ego_comm_df_3hop <- edge_df %>%\n  left_join(\n    nadia_ego_nodes_3hop %>%\n      select(id, name, sub_type),\n    by = c(\"from\" = \"id\")\n  ) %>%\n  rename(\n    sender_id = from,\n    sender_name = name,\n    sender_type = sub_type\n  ) %>%\n  left_join(\n    nadia_ego_nodes_3hop %>%\n      select(id, name, sub_type, content, findings, destination, results,\n             coordination_type, operational_role, jurisdiction_type, timestamp),\n    by = c(\"to\" = \"id\")\n  ) %>%\n  rename(\n    recipient_id = to,\n    recipient_name = name,\n    recipient_type = sub_type\n  ) %>%\n  mutate(\n    details = coalesce(content, findings, destination, results,\n                       coordination_type, operational_role, jurisdiction_type),\n    timestamp = suppressWarnings(ymd_hms(timestamp))\n  ) %>%\n  select(\n    sender_id, sender_name, sender_type,\n    recipient_id, recipient_name, recipient_type,\n    timestamp, details\n  )\n\n# ---- Step 6: Filter for 'suspicious' in any relevant field ----\nsuspicious_links <- nadia_ego_comm_df_3hop %>%\n  filter(\n    grepl(\"suspicious\", sender_id, ignore.case = TRUE) |\n    grepl(\"suspicious\", sender_type, ignore.case = TRUE) |\n    grepl(\"suspicious\", recipient_id, ignore.case = TRUE) |\n    grepl(\"suspicious\", recipient_type, ignore.case = TRUE)\n  ) %>%\n  select(\n    sender_id, sender_name, sender_type,\n    recipient_id, recipient_name, recipient_type\n  )\n\n\n# ---- Step 7: View suspicious interactions ----\nunique_ids <- unique(c(suspicious_links$sender_id, suspicious_links$recipient_id))\nprint(unique_ids)\n```\n:::\n\n-   Elise, EcoVigil, Elise, Davis, Liam, Mako, Neptune, Sam, Remora, Rodriguez, Sailor Shifts Team, Sentinel, The Accountant, Oceanus City Council, V. Miesel Shipping possibly found something suspicious or were involved in something suspicious.\n\n### 9.4.2 Plotted Timeline (3-hop)- Only suspicious communications\n\nThese are the suspicious communications extracted from 9.4.1.\n\n```{r}\n#| code-fold: true\n#| code-summary: \"Show the code\"\n\n# ---- Step 1: Define fixed suspicious Event_Communication IDs ----\nevent_ids_to_extract <- c(\n  \"Event_Communication_222\", \"Event_Communication_270\",\n  \"Event_Communication_272\", \"Event_Communication_370\",\n  \"Event_Communication_485\", \"Event_Communication_535\",\n  \"Event_Communication_565\", \"Event_Communication_574\",\n  \"Event_Communication_601\", \"Event_Communication_612\",\n  \"Event_Communication_639\", \"Event_Communication_677\",\n  \"Event_Communication_724\", \"Event_Communication_726\",\n  \"Event_Communication_753\", \"Event_Communication_761\",\n  \"Event_Communication_833\", \"Event_Communication_916\",\n  \"Event_Communication_951\"\n)\n\n# ---- Step 2: Match to master communication events ----\nmatched_comms_df <- other_communications_df %>%\n  filter(event_id %in% event_ids_to_extract)\n\n# ---- Step 3: Prepare data for plotting ----\nmatched_comms_df_for_plot <- matched_comms_df %>%\n  mutate(\n    timestamp = as.POSIXct(timestamp),\n    comm_date = as.Date(timestamp),\n    comm_time_of_day = hms::as_hms(format(timestamp, \"%H:%M:%S\")),\n    sender_sub_type = factor(sender_sub_type, levels = c(\"Person\", \"Vessel\", \"Organization\", \"Location\")),\n    communicating_pair_sorted = paste(pmin(sender_name, recipient_name), pmax(sender_name, recipient_name), sep = \" & \")\n  )\n\n# ---- Step 4: Add tooltip labels ----\nplot_data <- matched_comms_df_for_plot %>%\n  mutate(\n    wrapped_content = str_wrap(content, width = 50),\n    tooltip_text = paste0(\n      \"<b>Date:</b> \", comm_date, \"<br>\",\n      \"<b>Time:</b> \", format(comm_time_of_day, \"%H:%M:%S\"), \"<br>\",\n      \"<b>Event ID:</b> \", event_id, \"<br><br>\",\n      \"<b>From:</b> \", sender_name, \"<br>\",\n      \"<b>To:</b> \", recipient_name, \"<br><br>\",\n      \"<b>Content:</b><br>\", wrapped_content\n    )\n  )\n\n# ---- Step 5: Generate timeline plot ----\np <- ggplot(plot_data, aes(x = comm_date, y = comm_time_of_day)) +\n  geom_point(aes(\n    color = sender_name,\n    shape = sender_sub_type,\n    text = tooltip_text\n  ), show.legend = c(color = TRUE, shape = FALSE), size = 2, alpha = 0.7) +\n\n  scale_shape_manual(values = c(\n    \"Person\" = 16,\n    \"Vessel\" = 17,\n    \"Organization\" = 15,\n    \"Location\" = 18\n  )) +\n\n  scale_y_time(\n    limits = hms::as_hms(c(\"08:00:00\", \"14:00:00\")),\n    breaks = hms::as_hms(c(\"08:00:00\", \"09:00:00\", \"10:00:00\", \"11:00:00\", \"12:00:00\", \"13:00:00\", \"14:00:00\")),\n    labels = c(\"08:00\", \"09:00\", \"10:00\", \"11:00\", \"12:00\", \"13:00\", \"14:00\")\n  ) +\n\n  scale_x_date(\n    date_breaks = \"1 day\",\n    date_labels = \"%d %b\"\n  ) +\n\n  facet_wrap(~ sender_sub_type, ncol = 1, scales = \"fixed\") +\n\n  labs(\n    title = \"Suspicious Communications Timeline (Nadia's 3-hop Ego Network)\",\n    x = \"Date\",\n    y = \"Time of Day\",\n    color = \"Sender\"\n  ) +\n\n  theme_grey() +\n  theme(\n    axis.text.y = element_text(size = 6),\n    axis.title.y = element_text(size = 7),\n    axis.text.x = element_text(size = 6, angle = 45, hjust = 1),\n    axis.title.x = element_text(margin = margin(t = 10), size = 7),\n    panel.spacing = unit(0.5, \"lines\"),\n    strip.text = element_text(size = 8, face = \"bold\"),\n    legend.position = \"bottom\",\n    legend.text = element_text(size = 6),\n    legend.title = element_text(size = 7)\n  )\n\n# ---- Step 6: Convert to interactive plot ----\nggplotly(p, tooltip = \"text\")\n\n```\n\n### Plotted Timeline (3-hop)- Full communications\n\n```{r}\n#| code-fold: true\n#| code-summary: \"Show the code\"\n\n# ---- Step 1: Extract Communication Event IDs from Nadia's 3-hop ego network ----\nevent_ids_to_extract <- nadia_ego_comm_df_3hop %>%\n  filter(str_starts(sender_id, \"Event_Communication_\")) %>%\n  pull(sender_id) %>%\n  unique()\n\n# ---- Step 2: Match to master communication events ----\nmatched_comms_df <- other_communications_df %>%\n  filter(event_id %in% event_ids_to_extract)\n\n# ---- Step 3: Prepare data for plotting ----\nmatched_comms_df_for_plot <- matched_comms_df %>%\n  mutate(\n    timestamp = as.POSIXct(timestamp),\n    comm_date = as.Date(timestamp),\n    comm_time_of_day = hms::as_hms(format(timestamp, \"%H:%M:%S\")),\n    sender_sub_type = factor(sender_sub_type, levels = c(\"Person\", \"Vessel\", \"Organization\", \"Location\")),\n    communicating_pair_sorted = paste(pmin(sender_name, recipient_name), pmax(sender_name, recipient_name), sep = \" & \")\n  )\n\n# ---- Step 4: Add tooltip labels ----\nplot_data <- matched_comms_df_for_plot %>%\n  mutate(\n    wrapped_content = str_wrap(content, width = 50),\n    tooltip_text = paste0(\n      \"<b>Date:</b> \", comm_date, \"<br>\",\n      \"<b>Time:</b> \", format(comm_time_of_day, \"%H:%M:%S\"), \"<br>\",\n      \"<b>Event ID:</b> \", event_id, \"<br><br>\",\n      \"<b>From:</b> \", sender_name, \"<br>\",\n      \"<b>To:</b> \", recipient_name, \"<br><br>\",\n      \"<b>Content:</b><br>\", wrapped_content\n    )\n  )\n\n# ---- Step 5: Generate timeline plot ----\np <- ggplot(plot_data, aes(x = comm_date, y = comm_time_of_day)) +\n  geom_point(aes(\n    color = sender_name,\n    shape = sender_sub_type,\n    text = tooltip_text\n  ), show.legend = c(color = TRUE, shape = FALSE), size = 2, alpha = 0.7) +\n\n  scale_shape_manual(values = c(\n    \"Person\" = 16,\n    \"Vessel\" = 17,\n    \"Organization\" = 15,\n    \"Location\" = 18\n  )) +\n\n  scale_y_time(\n    limits = hms::as_hms(c(\"08:00:00\", \"14:00:00\")),\n    breaks = hms::as_hms(c(\"08:00:00\", \"09:00:00\", \"10:00:00\", \"11:00:00\", \"12:00:00\", \"13:00:00\", \"14:00:00\")),\n    labels = c(\"08:00\", \"09:00\", \"10:00\", \"11:00\", \"12:00\", \"13:00\", \"14:00\")\n  ) +\n\n  scale_x_date(\n    date_breaks = \"1 day\",\n    date_labels = \"%d %b\"\n  ) +\n\n  facet_wrap(~ sender_sub_type, ncol = 1, scales = \"fixed\") +\n\n  labs(\n    title = \"Nadia's 3-hop Communications Timeline (Sender Perspective)\",\n    x = \"Date\",\n    y = \"Time of Day\",\n    color = \"Sender\"\n  ) +\n\n  theme_grey() +\n  theme(\n    axis.text.y = element_text(size = 6),\n    axis.title.y = element_text(size = 7),\n    axis.text.x = element_text(size = 6, angle = 45, hjust = 1),\n    axis.title.x = element_text(margin = margin(t = 10), size = 7),\n    panel.spacing = unit(0.5, \"lines\"),\n    strip.text = element_text(size = 8, face = \"bold\"),\n    legend.position = \"bottom\",\n    legend.text = element_text(size = 6),\n    legend.title = element_text(size = 7)\n  )\n\n# ---- Step 6: Convert to interactive plot ----\nggplotly(p, tooltip = \"text\")\n\n```\n\n## **9.5 Discussion/Interpretation (1 & 3 hop data):**\n\nThere were certain questions we posted to ourselves and came out with the answers.\n\n### 9.5.1 The Community and Ego Network:\n\n#### Question and Answer Analysis\n\n+--------------------------------------------------------------------------------------------------------------------------------------------------------------+---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+\n| Question                                                                                                                                                     | Answer                                                                                                                                                                                                  |\n+:=============================================================================================================================================================+:========================================================================================================================================================================================================+\n| Who were Nadia’s direct communication contacts (1-hop degree centrality)? Are any of them known to be suspicious or involved in illicit activities?          | From the thicker width in the Ego network, it appeared that Nadia often communicated with **Liam**, **Elise**, and **Davis**.                                                                           |\n|                                                                                                                                                              |                                                                                                                                                                                                         |\n|                                                                                                                                                              | Liam appeared to be The **Middleman** within Nadia’s direct community from the Louvain Community Network.                                                                                               |\n|                                                                                                                                                              |                                                                                                                                                                                                         |\n|                                                                                                                                                              | From the filtered table on suspicious relationships, **Elise**, **Liam**, **EcoVigil**, **Sentinel**, **Oceanus City Council**, and **V. Miesel Shipping** were noted to have suspicious relationships. |\n|                                                                                                                                                              |                                                                                                                                                                                                         |\n|                                                                                                                                                              | Their conversations were the area of focus to uncover their roles, relationships and identities.                                                                                                        |\n+--------------------------------------------------------------------------------------------------------------------------------------------------------------+---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+\n| Were there any other ‘Event’ or ‘Relationship’ nodes directly connected to Nadia in this communication network that hinted at suspicious people/ activities? | Based on information from question 2, **Rodriguez** was previously involved in **mining activities** that affected the environment. ‘**Mining**’ as a topic and his conversations would be tracked.     |\n+--------------------------------------------------------------------------------------------------------------------------------------------------------------+---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+\n\n### 9.5.2 The Communication Timeline and Content:\n\nIn the `nadia_full_communications_timeline` table, the actual content of her direct two-way communications were investigated over the course of 9 days. There were certain suspicious entities, keywords, coded language, or unusual topics detected that were suspicious. We have tabled out the segmented suspicious and non-suspicious entities for investigation and elimination.\n\n::: panel-tabset\n### Not in the Network but Mentioned in the Content\n\n+-----------------+------------------------+---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+---------------+\n| Entity          | Form of Subject Matter | Rationale                                                                                                                                                                                         | Event ID      |\n+=================+========================+===================================================================================================================================================================================================+===============+\n| Nemo Reef       | Location               | Likely conservation area which was picked by the characters for illicit activities.                                                                                                               | 331, 943      |\n+-----------------+------------------------+---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+---------------+\n| Permit #CR-7844 | Item                   | Likely a permit to show tourism activity as a cover for suspicious activities. Rodriguez is likely linked to vessels Mako, Neptune, and Remora operating under this permit with a tourism facade. | 582, 847, 805 |\n+-----------------+------------------------+---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+---------------+\n| EcoVigil        | Vessel                 | EcoVigil will likely affect Nadia's operations when they use their ROV. Nadia recommended to V. Miesel to accelerate the planned operation. They were likely working for different sides.         | 753, 847      |\n+-----------------+------------------------+---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+---------------+\n\n### Suspicious Entity\n\n+--------------------------------------+--------------+-----------+-------------------------------------------------------------------------------------------------------------------------------------------------+--------------------+\n| Suspicious Entity                    | Sub Type     | Community | Rationale                                                                                                                                       | Event ID           |\n+======================================+==============+===========+=================================================================================================================================================+====================+\n| Haacklee Harbor                      | Location     | 2         | Nadia's communication to Haacklee Harbor is suspicious when she wanted the documents destroyed and the special corridor to Nemo Reef cancelled. | 331                |\n+--------------------------------------+--------------+-----------+-------------------------------------------------------------------------------------------------------------------------------------------------+--------------------+\n| Liam aka The Middleman               | Person       | 2         | Nadia wanted him to double his usual fee to ensure Harbor Master remains cooperative. Identity revealed through:                                | 529, 795, 847      |\n+--------------------------------------+--------------+-----------+-------------------------------------------------------------------------------------------------------------------------------------------------+--------------------+\n| Davis                                | Person       | 1         | Nadia told him to create a clean paper trail. She will provide permits.                                                                         | 521                |\n+--------------------------------------+--------------+-----------+-------------------------------------------------------------------------------------------------------------------------------------------------+--------------------+\n| Elise aka Mrs. Money                 | Person       | 1         | Nadia warned Elise that conservation vessels might complicate their operation. Identity revealed through:                                       | 708, 528, 538, 677 |\n+--------------------------------------+--------------+-----------+-------------------------------------------------------------------------------------------------------------------------------------------------+--------------------+\n| Rodriguez aka Small Fry              | Person       | 1         | Linked to Mako, which is operating under a permit with a tourism facade.                                                                        | 805                |\n+--------------------------------------+--------------+-----------+-------------------------------------------------------------------------------------------------------------------------------------------------+--------------------+\n| Remora                               | Vessel       | 1         | Remora reported a tourism facade to Nadia and planned underwater lighting placements in Nemo Reef while monitoring conservation vessels.        | 943                |\n+--------------------------------------+--------------+-----------+-------------------------------------------------------------------------------------------------------------------------------------------------+--------------------+\n| Neptune                              | Vessel       | 1         | Nadia told Neptune to stay under the radar.                                                                                                     | 538                |\n+--------------------------------------+--------------+-----------+-------------------------------------------------------------------------------------------------------------------------------------------------+--------------------+\n| V. Miesel HQ                         | Organisation | 1         | Organisation was aware of the suspicious permit and The Middleman.                                                                              | 846, 847           |\n+--------------------------------------+--------------+-----------+-------------------------------------------------------------------------------------------------------------------------------------------------+--------------------+\n| Sailor Shifts Team aka Glitters Team | Organisation | 1         | Nadia provided crew members for the setup related to the permit.                                                                                | 520                |\n+--------------------------------------+--------------+-----------+-------------------------------------------------------------------------------------------------------------------------------------------------+--------------------+\n\n### Non Suspicious Entity\n\n+-----------------------+--------------+-----------+--------------------------------------------------------------------------------------------------------------------------+----------+\n| Non Suspicious Entity | Sub Type     | Community | Rationale                                                                                                                | Event ID |\n+=======================+==============+===========+==========================================================================================================================+==========+\n| Oceanus City Council  | Organisation | 2         | Oceanus City Council as a whole is not suspicious as an organisation as Liam stated this organisation suspected nothing. | 535      |\n+-----------------------+--------------+-----------+--------------------------------------------------------------------------------------------------------------------------+----------+\n| Sentinel              | Vessel       | 2         | Sentinel Vessel suspected ulterior motives as the water quality was fine.                                                | 677      |\n+-----------------------+--------------+-----------+--------------------------------------------------------------------------------------------------------------------------+----------+\n| Marlin                | Vessel       | 2         | Marlin inquired about unusual vessel routes near eastern shoals, Nadia and Davis might need to address this.             | 584      |\n+-----------------------+--------------+-----------+--------------------------------------------------------------------------------------------------------------------------+----------+\n:::\n\n## **9.6 Querying Keywords**\n\nBased on our knowledge, we decided to connect to external information. We used knowledge from Nadia's current network and communication with keyword search of our queries.\n\n### 9.6.1 Plotted Timeline (Word Query: Permit related)\n\n```{r}\n#| code-fold: true\n#| code-summary: \"Show the code\"\n\n# -- Step 1: Define keywords\nkeywords <- c(\"permit\", \"1045\", \"7844\")\npattern <- paste0(\"\\\\b(\", paste(keywords, collapse = \"|\"), \")\\\\b\")\n\n# -- Step 2: Filter messages with keyword match (case-insensitive)\nkeyword_matches_df <- other_communications_df %>%\n  mutate(content_lower = tolower(content)) %>%\n  filter(str_detect(content_lower, pattern))\n\n# -- Step 3: Extract and annotate keyword matches\nplot_data <- keyword_matches_df %>%\n  mutate(\n    matched_keywords = str_extract_all(content_lower, pattern),\n    timestamp = suppressWarnings(as.POSIXct(timestamp)),\n    comm_date = as.Date(timestamp),\n    comm_time_of_day = suppressWarnings(hms::as_hms(format(timestamp, \"%H:%M:%S\"))),\n    wrapped_content = str_wrap(content, width = 50)\n  ) %>%\n  unnest(matched_keywords) %>%\n  mutate(\n    matched_keywords = recode(matched_keywords,\n      \"permit\" = \"Permit\",\n      \"1045\" = \"# 1045\",\n      \"7844\" = \"# 7844\"\n    ),\n    tooltip_text = paste0(\n      \"<b>Date:</b> \", comm_date,\n      \"<br><b>Time:</b> \", format(comm_time_of_day, \"%H:%M:%S\"),\n      \"<br><b>Event ID:</b> \", event_id,\n      \"<br><b>Content:</b><br>\", wrapped_content\n    )\n  )\n\n# -- Step 4: Plot timeline\np <- ggplot(plot_data, aes(x = comm_date, y = comm_time_of_day)) +\n  geom_point(aes(\n    color = matched_keywords,\n    shape = sender_sub_type,\n    text = tooltip_text,\n    group = matched_keywords\n  ), size = 2.5, alpha = 0.7, show.legend = TRUE) +\n  scale_shape_manual(values = c(\n    \"Person\" = 16,\n    \"Vessel\" = 17,\n    \"Organization\" = 15,\n    \"Location\" = 18\n  )) +\n  facet_wrap(~ matched_keywords, ncol = 1, scales = \"fixed\") +\n  scale_y_time(\n    limits = hms::as_hms(c(\"08:00:00\", \"13:00:00\")),\n    breaks = hms::as_hms(c(\"08:00:00\", \"09:00:00\", \"10:00:00\", \"11:00:00\", \"12:00:00\", \"13:00:00\")),\n    labels = c(\"08:00\", \"09:00\", \"10:00\", \"11:00\", \"12:00\", \"13:00\")\n  ) +\n  scale_x_date(date_breaks = \"1 day\", date_labels = \"%d %b\") +\n  labs(\n    title = \"Interactive Timeline: Keyword Mentions by Day and Time\",\n    x = \"Date\",\n    y = \"Time of Day\",\n    shape = \"Sender Type\",\n    color = \"Keyword\"\n  ) +\n  theme_grey() +\n  theme(\n    axis.text.y = element_text(size = 6),\n    axis.title.y = element_text(size = 7),\n    axis.ticks.y = element_line(),\n    axis.text.x = element_text(size = 6, angle = 45, hjust = 1),\n    axis.title.x = element_text(margin = margin(t = 10), size = 7),\n    panel.spacing = unit(0.5, \"lines\"),\n    strip.text = element_text(size = 8, face = \"bold\"),\n    legend.position = \"bottom\",\n    legend.text = element_text(size = 6),\n    legend.title = element_blank()\n  )\n\n# -- Step 5: Convert to plotly\nggplotly(p, tooltip = \"text\")\n\n\n```\n\n### 9.6.1.1 Findings in sequential order:\n\n-   There were overlaps as the blue permit also included the red NR-1045 permit and green CR-7844 permit.\n\n```{r}\n#| code-fold: true\n#| code-summary: \"Show the code\"\n\nlibrary(reactable)\nlibrary(dplyr)\nlibrary(stringr)\nlibrary(readr) # Used for read_lines\n\n# 1. Prepare data from the text provided\ndata_text <- \"\nDate & Time | Event Description\n------------|---------------------------------------------------------------------------------------------------------------\n2 Oct (12:16pm) | Rodriguez was from the Sailor Shifts Team.\n5 Oct (10:54am) | Jensen from City Council approved Nemo Reef permit.\n6 Oct (9:57am) | Remora told Sailor Shifts Team that Nadia got Commissioner Torres to sign off the permit.\n6 Oct (10:45am) | Mako acknowledged NR-1045 permit to Nemo Reef.\n6 Oct (12:33pm) | Mako was lead vessel to Neptune and Remora as authorised by V. Miesel Shipping.\n7 Oct (9:40am) | Mako was operating under permit NR-1045 for conservation research.\n8 Oct (10:24am) | Mako was operating under V. Miesel's special marine research permit CR-7844 approved by Oceanus City Council.\n8 Oct (10:30am) | Mako informed Remora that both of them were operating under permit CR-7844 and have a 5 day deadline.\n8 Oct (10:40am) | Remora was approved by Paackland Harbor to operate with extended hours under permit NR-1045.\n9 Oct (11:53am) | Mako requesed for additional crew from v Miesel Shipping for the 24hr operations over next 5 days.\n11 Oct (6:00am) | Nemo Reef closure mandated by Oceanus City Council.\n11 Oct (8:57am) | All research permits must be submitted within 72 hours.\n11 Oct (10:05am) | V. Miesel Shipping informed Remora that 30% of her crew to be reassigned to Neptune.\n12 Oct (10:01am) | Davis as Captain oversaw crew reallocation.\n12 Oct (11:19am) | Nadia secured documentation for CR-7844.\n12 Oct (12:52pm) | Harbor closure for 3 days from 13 Oct 06:00.\n\"\n\n# Parse the data into a data frame\n# Use read_lines to handle the multi-line string\ndata_lines <- read_lines(data_text)\n\n# Remove the header separator line and any empty lines\ndata_lines <- data_lines[!grepl(\"^---|===\", data_lines) & data_lines != \"\"]\n\n# The first non-separator line is the header\ncol_names_raw <- str_split(data_lines[1], \"\\\\|\")[[1]]\ncol_names <- str_trim(col_names_raw)\n\n# The rest are data rows\ndata_content <- data_lines[-1]\n\n# Create data frame by splitting lines and putting into a tibble\ndf <- tibble(line = data_content) %>%\n  mutate(\n    `Date & Time` = str_trim(str_extract(line, \"^[^|]+\")),\n    `Event Description` = str_trim(str_extract(line, \"(?<=\\\\|).+$\"))\n  ) %>%\n  select(`Date & Time`, `Event Description`) # Ensure correct column order and names\n\n# 2. Create the reactable table with desired features\n\nreactable(\n  df,\n  filterable = TRUE, # Enable column-specific filters (from the tutorial)\n  searchable = TRUE, # Enable global search box (from the tutorial)\n  paginationType = \"numbers\", # Display page numbers (corrected from \"pages\")\n  defaultPageSize = 5, # Show 5 rows per page\n  showPageSizeOptions = TRUE, # Allow users to change page size\n  pageSizeOptions = c(5, 10, 15, 20, 50), # Options for page sizes\n  striped = TRUE, # Add alternating row colors (from the tutorial)\n  highlight = TRUE, # Highlight row on hover (from the tutorial)\n  columns = list(\n    `Date & Time` = colDef(\n      name = \"Date & Time\",\n      minWidth = 120, # Adjust width to fit content\n      align = \"left\"\n    ),\n    `Event Description` = colDef(\n      name = \"Event Description\",\n      minWidth = 500, # Ensure enough width for event descriptions\n      align = \"left\"\n    )\n  ),\n  # Apply a custom theme for better aesthetics (inspired by the tutorial)\n  theme = reactableTheme(\n    borderColor = \"#dfe2e5\",\n    stripedColor = \"#f6f8fa\",\n    highlightColor = \"#f0f5f9\",\n    cellPadding = \"8px 12px\",\n    style = list(fontFamily = \"Verdana, Geneva, sans-serif\", fontSize = \"14px\"),\n    headerStyle = list(\n      \"&.rt-th:hover\" = list(backgroundColor = \"#e0e6eb\"),\n      fontSize = \"15px\",\n      fontWeight = 600,\n      color = \"#333\", # Darker header text for contrast\n      background = \"#f7f7f7\" # Slightly grey background for header\n    ),\n    rowSelectedStyle = list(backgroundColor = \"#e6f2ff\", \"&:hover\" = list(backgroundColor = \"#e6f2ff\")),\n    # Styles for search/filter inputs (from tutorial's theme example)\n    searchInputStyle = list(width = \"100%\", margin = \"5px 0\", padding = \"5px\"),\n    filterInputStyle = list(width = \"100%\", margin = \"2px 0\", padding = \"4px\")\n  )\n)\n```\n\n-   Since there were little communications on 13 Oct, we looked into other word queries.\n\n-   Using information obtained from question 2 and 4, we had in mind certain keywords to query for.\n\n### 9.6.2 Plotted Timeline (Word Query: Music Video Related)\n\n```{r}\n#| code-fold: true\n#| code-summary: \"Show the code\"\nlibrary(dplyr)\nlibrary(stringr)\nlibrary(ggplot2)\nlibrary(plotly)\nlibrary(hms)\nlibrary(tidyr)\n\n# -- Step 1: Define keywords\nkeywords <- c(\"mine\", \"mining\", \"music video\", \"lighting\", \"reef operation\")\npattern <- paste0(\"\\\\b(\", paste(keywords, collapse = \"|\"), \")\\\\b\")\n\n# -- Step 2: Filter messages\nsearch_target_content <- tolower(other_communications_df$content)\n\nkeyword_matches_df <- other_communications_df %>%\n  filter(str_detect(search_target_content, pattern))\n\n# -- Step 3: Extract keywords\nplot_data <- keyword_matches_df %>%\n  mutate(matched_keywords = str_extract_all(tolower(content), pattern)) %>%\n  unnest(matched_keywords) %>%\n  mutate(matched_keywords = str_to_title(matched_keywords)) %>%\n  arrange(matched_keywords, timestamp) %>%\n  mutate(\n    timestamp = as.POSIXct(timestamp),\n    comm_date = as.Date(timestamp),\n    comm_time_of_day = hms::as_hms(format(timestamp, \"%H:%M:%S\")),\n    wrapped_content = str_wrap(content, width = 50),\n    tooltip_text = paste0(\n      \"<b>Date:</b> \", comm_date,\n      \"<br><b>Time:</b> \", comm_time_of_day,\n      \"<br><b>Event ID:</b> \", event_id,\n      \"<br><b>From:</b> \", sender_name,\n      \"<br><b>To:</b> \", recipient_name,\n      \"<br><b>Content:</b><br>\", wrapped_content\n    )\n  )\n\n# -- Step 4: Plot\np <- ggplot(plot_data, aes(x = comm_date, y = comm_time_of_day)) +\n  geom_point(aes(\n    color = matched_keywords,\n    shape = sender_sub_type,\n    text = tooltip_text,\n    group = matched_keywords  # ensures matched_keywords is in layer\n  ), size = 2.5, alpha = 0.7, show.legend = TRUE) +\n  scale_shape_manual(values = c(\n    \"Person\" = 16,\n    \"Vessel\" = 17,\n    \"Organization\" = 15,\n    \"Location\" = 18\n  )) +\n  facet_wrap(~ matched_keywords, ncol = 1, scales = \"fixed\") +\n  scale_y_time(\n    limits = hms::as_hms(c(\"08:00:00\", \"13:00:00\")),\n    breaks = hms::as_hms(c(\"08:00:00\", \"09:00:00\", \"10:00:00\", \"11:00:00\", \"12:00:00\", \"13:00:00\")),\n    labels = c(\"08:00\", \"09:00\", \"10:00\", \"11:00\", \"12:00\", \"13:00\")\n  ) +\n  scale_x_date(date_breaks = \"1 day\", date_labels = \"%d %b\") +\n  labs(\n    title = \"Interactive Timeline: Keyword Mentions by Day and Time\",\n    x = \"Date\",\n    y = \"Time of Day\",\n    shape = \"Sender Type\",\n    color = \"Keyword\"\n  ) +\n  theme_grey() +\n  theme(\n    axis.text.y = element_text(size = 6),\n    axis.title.y = element_text(size = 7),\n    axis.ticks.y = element_line(),\n    axis.text.x = element_text(size = 6, angle = 45, hjust = 1),\n    axis.title.x = element_text(margin = margin(t = 10), size = 7),\n    panel.spacing = unit(0.5, \"lines\"),  # Applies to both x and y spacing\n    strip.text = element_text(size = 8, face = \"bold\"),\n    legend.position = \"bottom\",\n    legend.text = element_text(size = 6),\n    legend.title = element_blank()\n  )\n\n# -- Step 5: Convert to plotly\nggplotly(p, tooltip = \"text\")\n```\n\n### 9.6.2.1 Findings through Questions & Answers:\n\n#### **Question and Answer Analysis**\n\n+------------------------------------------------------------------------------------------------------------------------------+------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+\n| **Question**                                                                                                                 | **Answer**                                                                                                                                                                                                                                                                                                                               |\n+==============================================================================================================================+==========================================================================================================================================================================================================================================================================================================================================+\n| Which vessel was the suspicious permit #CR-7844 prepared for?                                                                | From question 2 and 4, we know this is V. Miesel's Marine Research Permit, and prepared for Mako (lead vessel), Neptune, and Remora.                                                                                                                                                                                                     |\n|                                                                                                                              |                                                                                                                                                                                                                                                                                                                                          |\n| (See 9.6.1.1)                                                                                                                |                                                                                                                                                                                                                                                                                                                                          |\n+------------------------------------------------------------------------------------------------------------------------------+------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+\n| What suspicious activity was performed at Nemo Reef? Which day was it?                                                       | 14 Oct 2040 for a music video production.                                                                                                                                                                                                                                                                                                |\n|                                                                                                                              |                                                                                                                                                                                                                                                                                                                                          |\n| (See 9.6.2)                                                                                                                  |                                                                                                                                                                                                                                                                                                                                          |\n+------------------------------------------------------------------------------------------------------------------------------+------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+\n| Why is underwater lighting placement needed at Nemo Reef?                                                                    | For a music video production.                                                                                                                                                                                                                                                                                                            |\n|                                                                                                                              |                                                                                                                                                                                                                                                                                                                                          |\n| (See 9.6.2)                                                                                                                  |                                                                                                                                                                                                                                                                                                                                          |\n+------------------------------------------------------------------------------------------------------------------------------+------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+\n| What were the expedited approvals and secretive logistics?                                                                   | Permits for Nemo Reef through NR-1045 and CR-788 were expedited. The secretive logistics were the crates and equipment on the vessels for the music video production.                                                                                                                                                                    |\n|                                                                                                                              |                                                                                                                                                                                                                                                                                                                                          |\n| (See 9.6.1 and 9.6.2)                                                                                                        |                                                                                                                                                                                                                                                                                                                                          |\n+------------------------------------------------------------------------------------------------------------------------------+------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+\n| Who were the high-level Oceanus officials, Sailor Shift’s team, local influential families, and local conservationist group? | **Oceanus Officials**: Commissioner Blake, Commissioner Torres, Council Knowles, The Middleman, Jensen, Liam Thorne                                                                                                                                                                                                                      |\n|                                                                                                                              |                                                                                                                                                                                                                                                                                                                                          |\n| (Various Ids)                                                                                                                | **Sailor Shift’s Team**: Boss, Council Knowles, Davis, Glitters Team, Liam Thorne, Mako, Mrs. Money, Nadia, Neptune, Remora, Rodriguez, Sam, Samantha Blake, Small Fry, The Accountant, The Intern, The Middleman                                                                                                                        |\n|                                                                                                                              |                                                                                                                                                                                                                                                                                                                                          |\n|                                                                                                                              | **Local Influential Families**: Council Knowles, V. Miesel Shipping                                                                                                                                                                                                                                                                      |\n|                                                                                                                              |                                                                                                                                                                                                                                                                                                                                          |\n|                                                                                                                              | **Local Conservationist Group**: Defender, EcoVigil, Green Guardians, Horizon, Kelly, Reef Guardians, Seawatch, Sentinel, The Lookout                                                                                                                                                                                                    |\n+------------------------------------------------------------------------------------------------------------------------------+------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+\n| Was the music video production activity legal?                                                                               | There was no environmental damage or mining involved in the music production. However, an environmental assessment was not conducted prior. Clepper may assess that his suspicions about Nadia Conti's illicit activity may not be straightforward and could depend on whether an assessment was mandatory before commercial activities. |\n|                                                                                                                              |                                                                                                                                                                                                                                                                                                                                          |\n| (Id 979)                                                                                                                     |                                                                                                                                                                                                                                                                                                                                          |\n+------------------------------------------------------------------------------------------------------------------------------+------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+\n\n# **10) Recreation of Story-Line**\n\nHere we attempted to summarise the story-line.\n\n```{r}\n#| code-fold: true\n#| code-summary: \"Show the code\"\n# --- Step 0: Define Event Data for Annotations ---\nevent_dates <- as.Date(c(\"2040-10-01\", \"2040-10-03\", \"2040-10-04\", \"2040-10-05\",\n                         \"2040-10-06\", \"2040-10-08\", \"2040-10-09\", \"2040-10-11\",\n                         \"2040-10-12\", \"2040-10-14\"))\n\nevent_labels_full <- c(\n  \"The Middleman told The Boss (Nadia) about a potential loophole in Nemo Reef protection zone\",\n  \"Tourism vessels were offering authorised access. Their violations were addressed at City Council meeting\",\n  \"Nadia told Mako to abort Nemo Reef mission as conservation vessels were close\",\n  \"News of Nadia assisting to get permit for Nemo Reef signed by Jensen from City Council on 4/10 spreaded\",\n  \"V. Miesel Shipping HQ told Neptune that Mako is lead vessel\",\n  \"Neptune told Mako they were under special marine research permit CR-7844\",\n  \"Neptune's underwater concrete forms in fragile crates discovered\",\n  \"37 'authorised maintenance vessels' documented despite Nemo Reef closure\",\n  \"Crew reallocated from Remona to Neptune overseen by Captain Davis\",\n  \"Music video production after Nemo Reef equipment transfer\"\n)\n\nevent_labels_short <- c(\n  \"Loophole\", \"Tourism\", \"Mako\", \"Permit\\nResults\", \"#NR-1045\",\n  \"#CR-7844\", \"Underwater\\nStructure\", \"37 Vessels\", \"Shifted Crew\", \"MV\\nProduction\"\n)\n\n# --- Step 1: Calculate Daily Message Frequencies ---\nfreq_df <- other_communications_df %>%\n  mutate(comm_date = as.Date(timestamp)) %>%\n  count(comm_date, name = \"message_count\") %>%\n  # Complete the date range to include all days, filling missing counts with 0\n  complete(comm_date = seq(min(comm_date), max(comm_date), by = \"day\"),\n           fill = list(message_count = 0))\n\n# --- Step 2: Build Event Annotation Table ---\nevent_df <- tibble(\n  date = event_dates,\n  label = gsub(\"\\n\", \"<br>\", event_labels_short), # Replace \\n with <br> for HTML tooltips\n  tooltip_raw = str_wrap(event_labels_full, width = 40) # Wrap long text for tooltips\n)\n\ncore_events <- event_df %>%\n  left_join(freq_df, by = c(\"date\" = \"comm_date\")) %>%\n  group_by(date) %>%\n  mutate(\n    offset = row_number(), # For stacking multiple events on the same day\n    # Adjust value for arrow positioning relative to message count\n    value = as.numeric(message_count) + 0.5 * offset,\n    date_jitter = date + (offset - 1) * 0.1 # Slight horizontal jitter if multiple events\n  ) %>%\n  ungroup() %>%\n  mutate(\n    # Create rich HTML tooltip content for Plotly\n    tooltip = paste0(\n      \"📅 <b>Date:</b> \", date,\n      \"<br>✉️ <b>Messages:</b> \", message_count,\n      \"<br>📝 <b>Core Event:</b> \", tooltip_raw\n    )\n  )\n\n# --- Step 3: Create the ggplot2 Plot ---\np <- ggplot(freq_df, aes(x = comm_date, y = message_count)) +\n  # Line plot for message frequency\n  geom_line(color = \"navyblue\") +\n  # Segments (arrows) pointing from the line to the event annotations\n  geom_segment(\n    data = core_events,\n    aes(x = date, xend = date, y = value - 1, yend = value + 0.5), # Adjust yend for arrow tip\n    arrow = arrow(length = unit(0.15, \"inches\")), color = \"grey40\"\n  ) +\n  # Points for the events (these will have the interactive tooltips)\n  geom_point(\n    data = core_events,\n    aes(x = date, y = value + 0.5, text = tooltip), # 'text' aesthetic is key for Plotly tooltips\n    color = \"firebrick\", size = 3\n  ) +\n  # Text labels for the short event names\n  geom_text(\n    data = core_events,\n    aes(x = date, y = value + 2, label = label), # Position text above the point/arrow\n    color = \"black\", fontface = \"bold\", size = 2.5, vjust = 0\n  ) +\n  # X-axis scale for dates\n  scale_x_date(date_breaks = \"1 day\", date_labels = \"%b %d\") +\n  # Labels and titles\n  labs(\n    title = \"Message Frequency Over Time\",\n    x = \"Date\", y = \"Message Count\"\n  ) +\n  # Ensure annotations are not clipped by plot limits\n  coord_cartesian(clip = \"off\") +\n  # Minimal theme for a clean look\n  theme_grey(base_size = 10) +\n  # Further theme adjustments\n  theme(\n    axis.text.x = element_text(angle = 45, hjust = 1),\n    plot.title = element_text(face=\"bold\"),\n    plot.margin = margin(30, 30, 10, 10), # Adjust plot margins if needed\n  )\n\n# --- Step 4: Convert to Interactive Plotly Object ---\n# The 'tooltip = \"text\"' argument tells Plotly to use the 'text' aesthetic\n# for the hover information, which we created as 'tooltip' in core_events.\np_interactive <- ggplotly(p, tooltip = \"text\")\n\n# --- Step 5: Display the Interactive Plot ---\np_interactive\n```\n\nHover over the red points to see the details. Here, we provided a high level summary on the core event on the preparation and production of the music video Nadia was involved in for a period of 2 weeks, and also provided a snippet to the sub-event of the tourism vessels breaching protocols earlier in the week.\n\n# **11) References**\n\n-   Datastorm (2021) [visNetwork](https://datastorm-open.github.io/visNetwork/)\n\n-   Dr. Kam Tin Seong (2025) [Lesson 9: Visualising and Analysis Network Data](https://isss608-ay2024-25apr.netlify.app/outline/lesson09_outline)\n\n-   R-Graph (2025) [Reactable](https://r-graph-gallery.com/package/reactable.html)\n","srcMarkdownNoYaml":"\n\n# **Prototyping our \"🌊Covert Reef🪸\" Project**\n\nsus\n\n# **0) Visual Thematic Overview**\n\nStart off with wordclouds at the top of the webpage to serve as a precursor to key themes:\n\n-   Shows a visually prominent wordcloud immediately at the top of the page;\n-   Previews key terms from the dataset (as a “hook”) to engage users and provide a thematic overview;\n-   Shiny compatible\n\n```{r}\nlibrary(shiny)\nlibrary(wordcloud)\nlibrary(RColorBrewer)\n\n# Data and color palette\nword <- c(\"vessels\", \"mining\", \"funding\", \"music\", \"reef\", \"conservation\", \"turtles\",\n          \"fuel\", \"permit\", \"?\", \"suspicious\", \"tourism\", \"lighting\", \"meetings\",\n          \"council\", \"harbor\", \"relationships\", \"communications\", \"operation\", \"underwater\")\nfreq <- c(5, 8, 7, 8, 9, 5, 6, 10, 8, 4, 3, 3, 5, 2, 3, 2, 5, 8, 3, 4)\nword_data_wc <- data.frame(word = word, freq = freq)\n\nocean_colors_lp <- c(\n  \"#1B1B3A\", \"#0072B2\", \"#009E73\", \"#D55E00\", \"#CC79A7\",\n  \"#882255\", \"#AA4499\", \"#004D40\", \"#333333\"\n)\n\n# Define UI\nui <- fluidPage(\n  titlePanel(\" \"),\n  plotOutput(\"wordcloudPlot\", height = \"500px\")  # Increased height\n)\n\n# Define Server\nserver <- function(input, output, session) {\n  output$wordcloudPlot <- renderPlot({\n    par(bg = \"#f0f0fb\")  # Set background inside renderPlot\n\n    wordcloud(\n      words = word_data_wc$word,\n      freq = word_data_wc$freq,\n      min.freq = 1,\n      max.words = 200,\n      random.order = FALSE,\n      colors = ocean_colors_lp,\n      rot.per = 0.20,\n      scale = c(4, 0.8)\n    )\n  })\n}\n\n# Launch App\nshinyApp(ui, server)\n\n```\n\n# **1) Setup and Preparatory Work**\n\n## **1.1 Loading Packages to prepare for SHINY**\n\n## **Packages supported in R CRAN:**\n\n+----------------------------------------------------------------------------------------------------------------------------+------------------------------------------------------------------------------------------------------------------------------+\n| **Utility Tools**                                                                                                          | **Graphing Tools**                                                                                                           |\n+============================================================================================================================+==============================================================================================================================+\n| -   [jsonlite](https://cran.r-project.org/web/packages/jsonlite/index.html) - To parse JSON                                | -   [patchwork](https://cran.r-project.org/web/packages/patchwork/index.html) - For combining ggplot plots                   |\n|                                                                                                                            |                                                                                                                              |\n| -   [tidyverse](https://www.tidyverse.org/) - Data science tools                                                           | -   [ggraph](https://ggraph.data-imaginist.com/) - For plotting network data                                                 |\n|                                                                                                                            |                                                                                                                              |\n| -   [ggtext](https://cran.r-project.org/web/packages/ggtext/index.html) - Tools for text formatting                        | -   [tidygraph](https://cran.r-project.org/web/packages/tidygraph/index.html) - For graph manipulations                      |\n|                                                                                                                            |                                                                                                                              |\n| -   [knitr](https://cran.r-project.org/web/packages/knitr/index.html) - For better table displays                          | -   [igraph](https://cran.r-project.org/web/packages/igraph/index.html) - Contains functions for network analysis            |\n|                                                                                                                            |                                                                                                                              |\n| -   [lubridate](https://cran.r-project.org/web/packages/lubridate/vignettes/lubridate.html) - For processing date and time | -   [ggiraph](https://cran.r-project.org/web/packages/ggiraph/index.html) - Interactive plots                                |\n|                                                                                                                            |                                                                                                                              |\n| -   [hms](https://cran.r-project.org/web/packages/hms/index.html) - For durations                                          | -   [plotly](https://cran.r-project.org/web/packages/plotly/index.html) - Interactive plots                                  |\n|                                                                                                                            |                                                                                                                              |\n| -   [scales](https://cran.r-project.org/web/packages/scales/index.html) - For breaks and labels                            | -   [wordcloud](https://cran.r-project.org/web/packages/wordcloud/index.html)- For frequency representation of words         |\n|                                                                                                                            |                                                                                                                              |\n| -   [tidytext](https://cran.r-project.org/web/packages/tidytext/index.html) - For functions text mining                    | -   [ggh4x](https://cran.r-project.org/web/packages/ggh4x/index.html) - For axis, strip, and facet customizations            |\n|                                                                                                                            |                                                                                                                              |\n| -   [tm](https://cran.r-project.org/web/packages/tm/index.html) - For text mining                                          | -   [visNetwork](https://cran.r-project.org/web/packages/visNetwork/index.html) - For interactive visualisation of networks. |\n|                                                                                                                            |                                                                                                                              |\n| -   [SnowBallC](https://cran.r-project.org/web/packages/SnowballC/index.html) - For Porter's word stemming                 | -   [RColorBrewer](https://cran.r-project.org/web/packages/RColorBrewer/index.html) - Colour schemes for graphics            |\n|                                                                                                                            |                                                                                                                              |\n| -   [SmartEDA](https://cran.r-project.org/web/packages/SmartEDA/index.html) - EDA with some graphing                       | -   [circlize](https://cran.r-project.org/web/packages/circlize/index.html) - For circular plots                             |\n|                                                                                                                            |                                                                                                                              |\n| -   [reactable](https://cran.r-project.org/web/packages/reactable/index.html) - For interactive data tables                | -   [ggalluvial](https://cran.r-project.org/web/packages/alluvial/index.html) - For alluvial diagrams                        |\n|                                                                                                                            |                                                                                                                              |\n| -   [highcharter](https://cran.r-project.org/web/packages/highcharter/index.html)- For wrapper function                    | -   [networkD3](https://cran.r-project.org/web/packages/networkD3/index.html)- For D3-based interactive network graphs       |\n|                                                                                                                            |                                                                                                                              |\n| -   [conflicted](https://cran.r-project.org/web/packages/conflicted/index.html) - For managing namespace conflicts         | -   [leaflet](https://cran.r-project.org/web/packages/leaflet/index.html)- For interactive maps                              |\n+----------------------------------------------------------------------------------------------------------------------------+------------------------------------------------------------------------------------------------------------------------------+\n\n-   We will use the code chunk below uses p_load() of pacman package to check if packages are installed in the computer. If they are, then they will be launched into R. Though it is not added here in pacman due to conflicts, networkD3, highcharter, leaflet, conflicted will also be added on Shiny.\n\n```{r}\n#| code-fold: true \n#| code-summary: \"Show the code\" \npacman::p_load(jsonlite, tidyverse, ggtext,   \n               knitr, lubridate, hms, scales,   \n               tidytext, tm, SnowballC,   \n               patchwork, ggraph,    \n               tidygraph, igraph, ggiraph,    \n               SmartEDA, plotly, wordcloud,    \n               ggh4x, visNetwork, RColorBrewer, \n               circlize, ggalluvial, reactable)  \n```\n\n## **🧰 Part of Tidyverse**\n\n::: {.card style=\"background-color: #f5f9ff; padding: 1rem; border-left: 5px solid #6482eb; margin-bottom: 1rem;\"}\n-   [stringr](https://cran.r-project.org/web/packages/stringr/index.html) - For wrapping text and string manipulation\n\n-   [readr](https://cran.r-project.org/web/packages/readr/index.html) - For reading rectangular data (CSV, TSV, etc)\n\n-   [dplyr](https://cran.r-project.org/web/packages/dplyr/index.html) - For transforming, filtering, summarising data\n\n-   [ggplot2](https://cran.r-project.org/web/packages/ggplot2/index.html) - For building data visualisation\n:::\n\n## 🔄**Workarounds:**\n\nThese are some workarounds required for Shiny application:\n\n::: {.card style=\"background-color: #f5f9ff; padding: 1rem; border-left: 5px solid #6482eb; margin-bottom: 1rem;\"}\n-   magick - For graphics and image processing will be replaced by renderImage() + impageOutput()\n\n-   We will use renderWordcloud2() (from the wordcloud2 package) and wordcloud2Output() in our UI.\n:::\n\n## 🆚**Settle Conflict Issues:**\n\n::: {.card style=\"background-color: #f5f9ff; padding: 1rem; border-left: 5px solid #6482eb; margin-bottom: 1rem;\"}\n-   conflicts_prefer(shinydashboard::box)\n-   conflicts_prefer(dplyr::filter)\n-   conflicts_prefer(dplyr::lag)\n-   conflicts_prefer(networkD3::JS)\n:::\n\n## **1.2 Loading Data**\n\nIn the code chunk below, fromJSON() of jsonlite package was used to import mc3.json file into R and save the output object.\n\n```{r}\n#| code-fold: true\n#| code-summary: \"Show the code\"\nmc3_data <- fromJSON(\"data/mc3_graph.json\")\nmc3_schema <- fromJSON(\"data/MC3_schema.json\")\n```\n\nIt contains graph data, where nodes can be accessed via `nodes` and edges via `links`. This dataset had many columns but we filtered the relevant data during wrangling.\n\n## **1.3 Defining common variables**\n\nWe will also set some values for consistency throughout all graphs.\n\n::: panel-tabset\n## Style and Colours\n\n```{r}\nnode_legend_colors_plot <- c(\n  \"Person\" = \"#88CCEE\",\n  \"Vessel\" = \"#D55E00\",\n  \"Organization\" = \"#117733\",\n  \"Location\" = \"#AA4499\",\n  \"Group\"= \"#CC79A7\",\n  \"Event\" = \"#DDCC77\",\n  \"Relationship\" = \"#AF8DC3\",\n  \"Nadia Conti\" = \"red\"\n)\n\nnode_legend_shapes_plot <- c(\n  \"Person\" = \"dot\",\n  \"Vessel\" = \"triangle\",\n  \"Organization\" = \"square\",\n  \"Location\" = \"diamond\",\n  \"Group\" = \"circle plus\",\n  \"Event\" = \"star\",\n  \"Relationship\" = \"square x\",\n  \"Nadia Conti\" = \"star\"\n)\n\nSTYLES <- list(\n  node_label_dark = \"black\",\n  font_family = \"Roboto Condensed\"\n)\n```\n:::\n\n## **1.4 Inspecting knowledge graph structure**\n\nIn the code chunk below glimpse() is used to reveal the structure of mc3_data knowledge graph.\n\n::: panel-tabset\n## The Code\n\n``` r\nglimpse(mc3_data)\n```\n\n## The Result\n\n```{r, echo=FALSE}\nglimpse(mc3_data)\n```\n:::\n\n## **1.5 Extracting the edges and nodes tables**\n\nNext, `as_tibble()` of **tibble** package package is used to extract the nodes and links tibble data frames from *mc3* tibble dataframe into two separate tibble dataframes called *mc3_nodes_raw* and *mc3_edges_raw* respectively.\n\n::: panel-tabset\n## The Code\n\n```{r}\nmc3_nodes_raw <- as_tibble(mc3_data$nodes)\nmc3_edges_raw <- as_tibble(mc3_data$edges)\n```\n\nWe also looked into the nodes and edges structure.\n\n## Nodes structure\n\n```{r}\nExpData(data=mc3_nodes_raw,type=2)\n```\n\n## Edges structure\n\n```{r}\nExpData(data=mc3_edges_raw,type=2)\n```\n:::\n\n# **2) Initial EDA for Nodes and Edges**\n\n## **2.1 Nodes via Shiny**\n\n::: panel-tabset\n## Nodes\n\nIn the code chunk below, ExpCatViz() of SmartEDA package is used to reveal the frequency distribution of all categorical fields in mc3_nodes tibble dataframe.\n\n```{r}\nlibrary(shiny)\nlibrary(ggplot2)\n\n# Run ExpCatViz once at the top to avoid recomputing\nExpCatViz(data=mc3_nodes_raw,\n          col=\"navyblue\")\n\n```\n\n## Drilling into Node sub_type\n\nCode chunk below uses ggplot2 functions to reveal the frequency distribution of *sub_type* field of *mc3_nodes_raw*.\n\n```{r}\n# Step 1: Count and reorder\nmc3_nodes_ordered <- mc3_nodes_raw %>%\n  count(sub_type) %>%\n  arrange((n)) %>%\n  mutate(sub_type = factor(sub_type, levels = sub_type))\n\n# Step 2: Plot with navy bars, sorted, and horizontal\nggplot(mc3_nodes_ordered, aes(x = sub_type, y = n)) +\n  geom_col(fill = \"navy\") +\n  coord_flip() +\n  labs(x = \"Sub_type\", y = \"Count\",\n    title = \"Distribution of Subtypes\") +\n  theme_minimal()\n```\n\n## Entity subtypes\n\nIn the code chunk below, the Entity subtypes are filtered.\n\n```{r}\n# Step 1: Filter for type == \"Entity\", count sub_type, sort \nrelationship_subtypes <- mc3_nodes_raw %>%\n  filter(type == \"Entity\") %>%\n  count(sub_type) %>%\n  arrange(n) %>%\n  mutate(sub_type = factor(sub_type, levels = sub_type)) \n\n# Step 2: Plot\nggplot(relationship_subtypes, aes(x = sub_type, y = n)) +\n  geom_col(fill = \"navy\") +\n  coord_flip() +\n  labs(\n    x = \"Entity Subtype\",\n    y = \"Count\",\n    title = \"Distribution of Entity Subtypes\"\n  ) +\n  theme_minimal()\n```\n\n## Event subtypes\n\nIn the code chunk below, the Event subtypes are filtered.\n\n```{r}\n# Step 1: Filter for type == \"Event\", count sub_type, sort \nrelationship_subtypes <- mc3_nodes_raw %>%\n  filter(type == \"Event\") %>%\n  count(sub_type) %>%\n  arrange(n) %>%\n  mutate(sub_type = factor(sub_type, levels = sub_type)) \n\n# Step 2: Plot\nggplot(relationship_subtypes, aes(x = sub_type, y = n)) +\n  geom_col(fill = \"navy\") +\n  coord_flip() +\n  labs(\n    x = \"Event Subtype\",\n    y = \"Count\",\n    title = \"Distribution of Event Subtypes\"\n  ) +\n  theme_minimal()\n```\n\n## Relationship subtypes\n\nIn the code chunk below, the relationship subtypes are filtered.\n\n```{r}\n# Step 1: Filter for type == \"Relationship\", count sub_type, sort \nrelationship_subtypes <- mc3_nodes_raw %>%\n  filter(type == \"Relationship\") %>%\n  count(sub_type) %>%\n  arrange(n) %>%\n  mutate(sub_type = factor(sub_type, levels = sub_type))\n\n# Step 2: Plot\nggplot(relationship_subtypes, aes(x = sub_type, y = n)) +\n  geom_col(fill = \"navy\") +\n  coord_flip() +\n  labs(\n    x = \"Relationship Subtype\",\n    y = \"Count\",\n    title = \"Distribution of Relationship Subtypes\"\n  ) +\n  theme_minimal()\n```\n:::\n\n## 2.1.1 Findings from EDA\n\n::: panel-tabset\n## Nodes\n\nWe will use the EDA findings to determine data to focus on or eliminate. From the bar charts and the original data on mc3_nodes_raw, it was observed that:\n\n-   Nodes were one of three types (Entity, Event, Relationship), where each of these types have their sub_types. Majority were of event type, followed by relationship, and entity.\n\n    -   There were 25 subtypes. Communications made up the bulk of the sub_type for Events. Coordinates made up the bulk of the sub_type for Relationship. The additional node sub_types not mentioned in the VAST 2025 MC3 Data Description under Node Attributes were: fishing, communication and coordinates.\n\n## Event Types\n\n-   Observations of EDA from Event types:\n\n    -   `Findings` field were filled when there were `monitoring_type`.\n\n    -   `Content` refers to radio communication content.\n\n    -   `Results` field were filled when there were `assessment_type` performed.\n\n    -   When there is an `enforcement_type` of enforcement operations or warnings, there might be an `outcome` at times.\n\n    -   When there is a `movement_type`, there might be a place of `destination` at times.\n\n## Relationship Types\n\n-   Observations of EDA from Relationship types:\n\n    -   When the subtype was coordinate, there were data in the field named `coordination_types`.\n\n    -   When the subtype was operate, there were data in the field named `operational_roles`.\n\n    -   When there is a `jurisdiction_type`, there might be an `authority_level`.\n\n    -   There are only restricted or special access data within `permission_types`.\n\n    -   When there is a `report_type` of data transmission or environmental report, there might be a `submission_date`.\n\n## Entity Types\n\n-   Observations of EDA from Entity types:\n\n    -   The 5 id under Group sub-types were not very useful information.\n\n## Course of Action\n\n-   Elimination and directed focus:\n\n    -   Relative to the entire dataset, there were little `assessment_type` (3%), `movement_type` (2%), `enforcement_type` (2%), `permission_type` (4%), `report_type` (2%), `authority_level` (1%). We will direct our focus on other areas instead of these.\n\n    -   There were no to little useful data in the fields named: `activity_type`, `references`, `dates`, `time`, and `friendship_type`. These were not utilised.\n\n    -   We directed our focus on Event_Communication, Event_Monitoring, and Event_VesselMovement.\n:::\n\n## **2.2 Edges**\n\nThe code chunk below used ExpCATViz() of SmartEDA package to reveal the frequency distribution of all categorical fields in mc3_edges_raw tibble dataframe.\n\n::: panel-tabset\n## Frequency Distribution of Categorical Fields\n\n```{r}\nExpCatViz(data=mc3_edges_raw,\n          col=\"navyblue\")\n```\n\nEntities are connected by edges to other Entities via an Event or Relationship node. The one exception to this is the Communication Event subtype, which is additionally linked to either an Event or Relationship node. The type field denotes the connector or edge type for the Entities, Event, and Relationship nodes. The edges are one of these: received, evidence_for, sent, NA.\n\n## Filter by type == sent\n\n```{r}\n# Step 1: Filter for type == \"sent\"\nfiltered_edges <- mc3_edges_raw %>%\n  filter(type == \"sent\") %>%\n  count(source) %>%\n  arrange(desc(n)) %>%\n  mutate(source = factor(source, levels = rev(unique(source))))  # descending \n\n# Step 2: Plot\nggplot(filtered_edges, aes(x = source, y = n)) +\n  geom_col(fill = \"navy\") +\n  coord_flip() +\n  labs(\n    title = \"Distribution of 'sent' Edges type by Source\",\n    x = \"Source\",\n    y = \"Count\"\n  ) +\n  theme_minimal()\n```\n:::\n\n**What we understood from the information provided by Vast Challenge on Directional Edges:**\n\n-   For relationship as colleagues node or friends node, the node will have arrows/ edges pointing towards the relationship node.\n\n-   For other relationships and events, the direction would be following the source and target.\n\n# **3) Data Preparation**\n\n## **3.1 Data Cleaning and Wrangling**\n\n::: panel-tabset\n## Cleaning and wrangling nodes\n\n-   convert values in id field into character data type,\n\n-   exclude records with `id` value are na,\n\n-   exclude records with similar id values,\n\n-   exclude `thing_collected` , `time` , `date`, `friendship_type` field, and\n\n-   save the cleaned tibble dataframe into a new tibble datatable called `mc3_nodes_cleaned`.\n\n```{r}\nmc3_nodes_cleaned <- mc3_nodes_raw %>%\n  mutate(id = as.character(id)) %>%\n  filter(!is.na(id)) %>%\n  distinct(id, .keep_all = TRUE) %>%\n  select(-thing_collected, -time, -date, -friendship_type)\n```\n\n## Unique Node Count\n\n```{r, echo=FALSE}\n# Find the number of unique types in each column and sort descending\nunique_counts <- mc3_nodes_cleaned %>%\n  summarise_all(n_distinct) %>%\n  pivot_longer(cols = everything(), names_to = \"column\", values_to = \"unique_count\") %>%\n  arrange(desc(unique_count))  # sort by unique_count in descending order\n\n# Print the result\nprint(unique_counts)\n```\n\n## Cleaning and wrangling edges\n\n-   renamed `source` and `target` fields to `from_id` and `to_id` respectively,\n\n-   converted values in `from_id` and `to_id` fields to character data type,\n\n-   excluded values in `from_id` and `to_id` which not found in the id field of mc3_nodes_cleaned,\n\n-   excluded records whereby `from_id` and/or `to_id` values are missing, and\n\n-   saved the cleaned tibble dataframe and called it mc3_edges_cleaned.\n\n```{r}\nmc3_edges_cleaned <- mc3_edges_raw %>%\n  rename(from_id = source,\n         to_id = target) %>%\n  mutate(across(c(from_id, to_id), as.character)) %>%\n  # Parse to_id to get supertype and sub_type for target nodes (e.g., Event_Communication)\n  separate(to_id, into = c(\"to_id_supertype\", \"to_id_sub_type\", \"to_id_num\"),\n           sep = \"_\", remove = FALSE, fill = \"right\", extra = \"merge\") %>%\n  # Filter to ensure from_id and to_id exist in mc3_nodes_cleaned (prevent orphaned edges)\n  filter(from_id %in% mc3_nodes_cleaned$id,\n         to_id %in% mc3_nodes_cleaned$id) %>%\n  filter(!is.na(from_id), !is.na(to_id))\n\nprint(\"Columns in mc3_edges_cleaned after initial cleaning:\")\nprint(colnames(mc3_edges_cleaned))\nprint(\"Head of mc3_edges_cleaned after initial cleaning:\")\nprint(head(mc3_edges_cleaned))\n\n```\n\n## Unique Edges Count\n\n```{r}\n# Find the number of unique types in each column\nunique_counts <- mc3_edges_cleaned %>%\n  summarise_all(n_distinct) %>%\n  pivot_longer(cols = everything(), names_to = \"column\", values_to = \"unique_count\")\n\n# Print the unique counts for each column\nprint(unique_counts)\n```\n\n## Other preparatory work\n\nNext, code chunk below will be used to create mapping of character id in mc3_nodes_cleaned to row index\n\n```{r}\nnode_index_lookup <- mc3_nodes_cleaned %>%\n  mutate(.row_id = row_number()) %>%\n  select(id, .row_id)\n```\n\nNext, the code chunk below was used to join and convert `from_id` and `to_id` to integer indices. At the same time we also dropped rows with unmatched nodes.\n\n```{r}\nmc3_edges_indexed <- mc3_edges_cleaned %>%\n  left_join(node_index_lookup, by = c(\"from_id\" = \"id\")) %>%\n  rename(from = .row_id) %>%\n  left_join(node_index_lookup, by = c(\"to_id\" = \"id\")) %>%\n  rename(to = .row_id) %>%\n  # Filter out edges where either source or target node was not found\n  filter(!is.na(from) & !is.na(to)) %>%\n  # Select all columns to carry forward to mc3_edges_final\n  select(from, to, id, is_inferred, type, # Original edge attributes\n         from_id, to_id, to_id_supertype, to_id_sub_type, to_id_num # Original IDs and parsed target type\n         )\n```\n\nNext the code chunk below was used to subset nodes to only those referenced by edges.\n\n```{r}\nused_node_indices <- sort(unique(c(mc3_edges_indexed$from, mc3_edges_indexed$to)))\nmc3_nodes_final <- mc3_nodes_cleaned %>%\n  slice(used_node_indices) %>%\n  mutate(new_index = row_number())\n```\n\nWe then used the code chunk below to rebuild lookup from old index to new index.\n\n```{r}\nold_to_new_index <- tibble(\n  old_index = used_node_indices,\n  new_index = seq_along(used_node_indices)\n)\n```\n\nLastly, the code chunk below was used to update edge indices to match new node table.\n\n```{r}\nmc3_edges_final <- mc3_edges_indexed %>%\n  left_join(old_to_new_index, by = c(\"from\" = \"old_index\")) %>%\n  rename(from_new = new_index) %>%\n  left_join(old_to_new_index, by = c(\"to\" = \"old_index\")) %>%\n  rename(to_new = new_index) %>%\n  # Explicitly select all columns that are needed downstream\n  select(from = from_new, to = to_new,\n         id, is_inferred, type,\n         from_id, to_id, to_id_supertype, to_id_sub_type, to_id_num)\n```\n:::\n\n## **3.2 Building the tidygraph object**\n\n::: panel-tabset\n## Build the object-tbl_graph\n\n```{r}\nmc3_graph <- tbl_graph(\n  nodes = mc3_nodes_final,\n  edges = mc3_edges_final,\n  directed = TRUE\n)\n```\n\n## Examining the object\n\n```{r}\nstr(mc3_graph)\n```\n:::\n\n# **4) Knowledge Graphs**\n\n## **VisNetwork**\n\nVisNetwork provides the user to understand relationships through interactivity. For instance:\n\n-   The individual nodes can be selected from the drop-down menu to view its connected nodes and edges.\n\n-   The hover tooltip provides additional details from fields such as content, coordination_type, findings, destination, operational_role, results, and jurisdiction_type based on the related id information from mc3_nodes_final.\n\n## The Graph- VisNetwork\n\n::: no-code-fold\n```{r, echo=FALSE}\n\n# ---- 1. Define styles and legends ----\n\nevent_subtypes <- c(\n  \"Communication\", \"Monitoring\", \"VesselMovement\", \"Assessment\",\n  \"Collaborate\", \"Endorsement\", \"TourActivity\", \"TransponderPing\",\n  \"Harbor Report\", \"Fishing\", \"Criticize\"\n)\n\nrelationship_subtypes <- c(\n  \"Coordinates\", \"AccessPermission\", \"Operates\", \"Colleagues\",\n  \"Suspicious\", \"Reports\", \"Jurisdiction\", \"Unfriendly\", \"Friends\"\n)\n\nnode_legend_colors_plot <- c(\n  \"Person\" = \"#88CCEE\",\n  \"Vessel\" = \"#D55E00\",\n  \"Organization\" = \"#117733\",\n  \"Location\" = \"#AA4499\",\n  \"Group\"= \"#CC79A7\",\n  \"Event\" = \"#DDCC77\",         # type level\n  \"Relationship\" = \"#AF8DC3\"   # type level\n)\n\nnode_legend_shapes_plot <- c(\n  \"Person\" = \"dot\",\n  \"Vessel\" = \"triangle\",\n  \"Organization\" = \"square\",\n  \"Location\" = \"diamond\",\n  \"Group\" = \"circle plus\",\n  \"Event\" = \"star\",              # type level\n  \"Relationship\" = \"square x\"    # type level\n)\n\nSTYLES <- list(\n  node_label_dark = \"black\",\n  font_family = \"Roboto Condensed\"\n)\n\n# ---- 2. Prepare nodes ----\nnodes <- mc3_nodes_final %>%\n  mutate(\n    label = ifelse(is.na(name), id, name),\n    \n    # These parts are for pulling the related data from other fields\n    tooltip_extra = case_when(\n      type == \"Event\" & sub_type == \"Communication\" ~ content,\n      type == \"Event\" & sub_type == \"Monitoring\" ~ findings,\n      type == \"Event\" & sub_type == \"VesselMovement\" ~ destination,\n      type == \"Event\" & sub_type == \"Assessment\" ~ results,\n      type == \"Relationship\" & sub_type == \"Coordinates\" ~ coordination_type,\n      type == \"Relationship\" & sub_type == \"Operates\" ~ operational_role,\n      type == \"Relationship\" & sub_type == \"Jurisdiction\" ~ jurisdiction_type,\n      TRUE ~ NA_character_\n    ),\n    \n    title = paste0(\n      \"<b>\", label, \"</b><br>\",\n      \"Type: \", type, \"<br>\",\n      \"Sub-type: \", sub_type, \"<br>\",\n      ifelse(!is.na(tooltip_extra), paste0(\"<br><b>Details:</b> \", tooltip_extra), \"\")\n    ),\n    \n    # Fallback logic: if sub_type is NA or not in styling list, use type instead\n    group = ifelse(sub_type %in% names(node_legend_colors_plot), sub_type, type)\n  ) %>%\n  select(id, label, group, title) %>%\n  distinct()\n\n# ---- 3. Prepare directed edges (type == \"sent\") ----\n\nedges <- mc3_edges_final %>%\n  filter(from_id %in% nodes$id & to_id %in% nodes$id) %>%\n  select(from = from_id, to = to_id)\n\n# ---- 4. Build visNetwork ----\n\nnet <- visNetwork(nodes, edges, width = \"100%\", height = \"600px\") %>%\n  visEdges(arrows = list(to = list(enabled = TRUE, scaleFactor = 1.5))) %>%\n  visOptions(highlightNearest = TRUE, nodesIdSelection = TRUE) %>%\n  visIgraphLayout(layout = \"layout_with_fr\") %>%\n  visNodes(font = list(\n    size = 14,\n    color = STYLES$node_label_dark,\n    face = STYLES$font_family,\n    vadjust = -15\n  ))\n\n# ---- 5. Apply shape and color per group ----\n\nfor (group_name in names(node_legend_colors_plot)) {\n  net <- net %>% visGroups(\n    groupname = group_name,\n    color = node_legend_colors_plot[[group_name]],\n    shape = node_legend_shapes_plot[[group_name]]\n  )\n}\n# ---- 6. Add legend ----\n\nused_groups <- unique(nodes$group)\n\nlegend_df <- tibble::tibble(\n  label = used_groups,\n  shape = node_legend_shapes_plot[used_groups],\n  color = node_legend_colors_plot[used_groups]\n) %>%\n  distinct(label, .keep_all = TRUE)  # remove duplicates just in case\n\nnet <- net %>% visLegend(\n  addNodes = legend_df,\n  ncol = 2,                         # number of columns\n  position = \"left\",              \n  main = \"Entity (Sub)Types\",      # title\n  useGroups = FALSE                # show custom legend entries\n)\n# ---- 7. Render ----\nnet\n\n```\n:::\n\n```{r, results=FALSE}\n#| code-fold: true\n#| code-summary: \"Show the code\"\n# ---- 1. Define styles and legends ----\n\nevent_subtypes <- c(\n  \"Communication\", \"Monitoring\", \"VesselMovement\", \"Assessment\",\n  \"Collaborate\", \"Endorsement\", \"TourActivity\", \"TransponderPing\",\n  \"Harbor Report\", \"Fishing\", \"Criticize\"\n)\n\nrelationship_subtypes <- c(\n  \"Coordinates\", \"AccessPermission\", \"Operates\", \"Colleagues\",\n  \"Suspicious\", \"Reports\", \"Jurisdiction\", \"Unfriendly\", \"Friends\"\n)\n\nnode_legend_colors_plot <- c(\n  \"Person\" = \"#88CCEE\",\n  \"Vessel\" = \"#D55E00\",\n  \"Organization\" = \"#117733\",\n  \"Location\" = \"#AA4499\",\n  \"Group\"= \"#CC79A7\",\n  \"Event\" = \"#DDCC77\",         # type level\n  \"Relationship\" = \"#AF8DC3\"   # type level\n)\n\nnode_legend_shapes_plot <- c(\n  \"Person\" = \"dot\",\n  \"Vessel\" = \"triangle\",\n  \"Organization\" = \"square\",\n  \"Location\" = \"diamond\",\n  \"Group\" = \"circle plus\",\n  \"Event\" = \"star\",              # type level\n  \"Relationship\" = \"square x\"    # type level\n)\n\nSTYLES <- list(\n  node_label_dark = \"black\",\n  font_family = \"Roboto Condensed\"\n)\n\n# ---- 2. Prepare nodes ----\nnodes <- mc3_nodes_final %>%\n  mutate(\n    label = ifelse(is.na(name), id, name),\n    \n    # These parts are for pulling the related data from other fields\n    tooltip_extra = case_when(\n      type == \"Event\" & sub_type == \"Communication\" ~ content,\n      type == \"Event\" & sub_type == \"Monitoring\" ~ findings,\n      type == \"Event\" & sub_type == \"VesselMovement\" ~ destination,\n      type == \"Event\" & sub_type == \"Assessment\" ~ results,\n      type == \"Relationship\" & sub_type == \"Coordinates\" ~ coordination_type,\n      type == \"Relationship\" & sub_type == \"Operates\" ~ operational_role,\n      type == \"Relationship\" & sub_type == \"Jurisdiction\" ~ jurisdiction_type,\n      TRUE ~ NA_character_\n    ),\n    \n    title = paste0(\n      \"<b>\", label, \"</b><br>\",\n      \"Type: \", type, \"<br>\",\n      \"Sub-type: \", sub_type, \"<br>\",\n      ifelse(!is.na(tooltip_extra), paste0(\"<br><b>Details:</b> \", tooltip_extra), \"\")\n    ),\n    \n    # Fallback logic: if sub_type is NA or not in styling list, use type instead\n    group = ifelse(sub_type %in% names(node_legend_colors_plot), sub_type, type)\n  ) %>%\n  select(id, label, group, title) %>%\n  distinct()\n\n# ---- 3. Prepare directed edges (type == \"sent\") ----\n\nedges <- mc3_edges_final %>%\n  filter(from_id %in% nodes$id & to_id %in% nodes$id) %>%\n  select(from = from_id, to = to_id)\n\n# ---- 4. Build visNetwork ----\n\nnet <- visNetwork(nodes, edges, width = \"100%\", height = \"600px\") %>%\n  visEdges(arrows = list(to = list(enabled = TRUE, scaleFactor = 1.5))) %>%\n  visOptions(highlightNearest = TRUE, nodesIdSelection = TRUE) %>%\n  visIgraphLayout(layout = \"layout_with_fr\") %>%\n  visNodes(font = list(\n    size = 14,\n    color = STYLES$node_label_dark,\n    face = STYLES$font_family,\n    vadjust = -15\n  ))\n\n# ---- 5. Apply shape and color per group ----\n\nfor (group_name in names(node_legend_colors_plot)) {\n  net <- net %>% visGroups(\n    groupname = group_name,\n    color = node_legend_colors_plot[[group_name]],\n    shape = node_legend_shapes_plot[[group_name]]\n  )\n}\n# ---- 6. Add legend ----\n\nused_groups <- unique(nodes$group)\n\nlegend_df <- tibble::tibble(\n  label = used_groups,\n  shape = node_legend_shapes_plot[used_groups],\n  color = node_legend_colors_plot[used_groups]\n) %>%\n  distinct(label, .keep_all = TRUE)  # remove duplicates just in case\n\nnet <- net %>% visLegend(\n  addNodes = legend_df,\n  ncol = 2,                         # number of columns\n  position = \"left\",              \n  main = \"Entity (Sub)Types\",      # title\n  useGroups = FALSE                # show custom legend entries\n)\n# ---- 7. Render ----\nnet\n\n```\n\n# **5) Further Checking and Cleaning Data**\n\n::: panel-tabset\n## 5.1 Checking Nodes\n\nCheck if mapping is correct for type and sub_type.\n\n```{r}\nmc3_nodes_cleaned %>%\n  group_by(type, sub_type) %>%\n  summarize(count = n()) %>%\n  arrange(-count) %>%\n  kable()\n```\n\n## 5.2.1 Cleaning Edges\n\n```{r}\n# Split the 'from_id' column\nmc3_edges_cleaned <- mc3_edges_cleaned %>%\n  separate(from_id, into = c(\"from_id_supertype\", \"from_id_sub_type\", \"from_id_id\"), sep = \"_\", remove = FALSE, extra = \"drop\")\n\n# Split the 'target' column into \nmc3_edges_cleaned <- mc3_edges_cleaned %>%\n  separate(to_id, into = c(\"to_id_supertype\", \"to_id_sub_type\",\"to_id_id\"), sep = \"_\", remove = FALSE, extra = \"drop\")\n\n# Find the number of unique types in each column\nunique_counts <- mc3_edges_cleaned %>%\n  summarise_all(n_distinct) %>%\n  pivot_longer(cols = everything(), names_to = \"column\", values_to = \"unique_count\")\n\n# Print the unique counts for each column\nprint(unique_counts)\n```\n\n## 5.2.2 Checking Edges\n\n```{r}\n# Check the mapping\nmc3_edges_cleaned %>%\n  group_by(from_id_supertype, from_id_sub_type) %>%\n  summarize(count = n()) %>%\n  arrange(-count) %>%\n  kable()\n\n# Check the mapping\nmc3_edges_cleaned %>%\n  group_by(to_id_supertype, to_id_sub_type) %>%\n  summarize(count = n()) %>%\n  arrange(-count) %>%\n  kable()\n```\n\n**Under Event-Communication types:** The edges target type and target subtypes matches the count of 584 for node to_id_supertype and node to_id_sub_type. However, there were only 581 count for content within the original node file. We then looked into duplicates.\n\n## 5.3 Checking for Duplicates\n\n```{r}\n# checking for duplicates\nduplicate_values1 <- mc3_nodes_cleaned %>%\n  count(content) %>%\n  filter(n > 1)\n\n# View duplicates\nprint(duplicate_values1)\n```\n\nThere were 4 duplicates within the content column. Upon checking the original data, one was the sender and the other was the receiver who received the same content. We left the data as it was.\n:::\n\n# **6) Tackling Question 1**\n\n## 6.1 All Communications\n\nSince the content column determines the important events and relationships, the communication sub_type in the original nodes file would be useful. Thus, the communication to_id_sub_type and from_id_sub_type from the original edges file will also be useful.\n\n### 6.1.1 Creation of a timeline of all radio communications in table format\n\n::: panel-tabset\n## The Table\n\n```{r, echo=FALSE}\n# --- 1. Extract All Communications ---\n# Logic: Sender (source) --sent--> Event_Communication (target) --received--> Recipient (target)\n# This extracts all communication events\n\n# --- 2. Clean and Prepare Nodes ---\nmc3_nodes_cleaned <- mc3_nodes_raw %>%\n  mutate(id = as.character(id)) %>%\n  filter(!is.na(id)) %>%\n  distinct(id, .keep_all = TRUE) %>%\n  # Rename 'type' to 'supertype' to reduce confusion with communication type\n  rename(supertype = type) %>%\n  # Select only columns that are needed and are consistently present\n  select(id, name, sub_type, content, timestamp) \n\n# --- 3. Clean and Prepare Edges ---\n# Rename 'type' in edges to 'edge_type' to avoid conflict with node 'supertype'\nmc3_edges_cleaned <- mc3_edges_raw %>%\n  rename(from_id = source,\n         to_id = target,\n         edge_type = type) %>% # Renamed 'type' to 'edge_type'\n  mutate(across(c(from_id, to_id), as.character)) %>%\n  # Filter out any edges where from_id or to_id are not in cleaned nodes\n  filter(from_id %in% mc3_nodes_cleaned$id,\n         to_id %in% mc3_nodes_cleaned$id)\n\nother_communications_df <- mc3_edges_cleaned %>%\n  filter(edge_type == \"sent\") %>% # Start with 'sent' edges\n  # Join with nodes to get content and timestamp of the Event_Communication node\n  left_join(mc3_nodes_cleaned %>% select(id, content, timestamp),\n            by = c(\"to_id\" = \"id\")) %>%\n  rename(event_id = to_id, event_content = content, event_timestamp = timestamp) %>%\n  # Now, find the recipient of this communication event\n  left_join(mc3_edges_cleaned %>%\n              filter(edge_type == \"received\") %>%\n              select(event_id_match = from_id, recipient_id = to_id),\n            by = c(\"event_id\" = \"event_id_match\")) %>%\n  # Join with nodes to get the sender's name and sub_type\n  left_join(mc3_nodes_cleaned %>% select(id, name, sub_type),\n            by = c(\"from_id\" = \"id\")) %>%\n  rename(sender_id_actual = from_id, sender_name = name, sender_sub_type = sub_type) %>%\n  # Join with nodes to get the recipient's name and sub_type\n  left_join(mc3_nodes_cleaned %>% select(id, name, sub_type),\n            by = c(\"recipient_id\" = \"id\")) %>%\n  rename(recipient_name = name, recipient_sub_type = sub_type) %>%\n  # Select and rename final columns for all communications\n  select(\n    communication_type = edge_type, # This will be \"sent\" from original filter\n    sender_id = sender_id_actual,\n    sender_name,\n    sender_sub_type,\n    recipient_id,\n    recipient_name,\n    recipient_sub_type,\n    event_id,\n    content = event_content,\n    timestamp = event_timestamp\n  ) \n\n# create a timeline visualization or inspect content.\nprint(knitr::kable(head(other_communications_df %>%\n                          select(timestamp, sender_name, \n                                 recipient_name, content), 10),\n                   format = \"markdown\", align = \"l\"))\n```\n\n## The Code\n\n``` r\n# --- 1. Extract All Communications ---\n# Logic: Sender (source) --sent--> Event_Communication (target) --received--> Recipient (target)\n# This extracts all communication events\n\n# --- 2. Clean and Prepare Nodes ---\nmc3_nodes_cleaned <- mc3_nodes_raw %>%\n  mutate(id = as.character(id)) %>%\n  filter(!is.na(id)) %>%\n  distinct(id, .keep_all = TRUE) %>%\n  # Rename 'type' to 'supertype' to reduce confusion with communication type\n  rename(supertype = type) %>%\n  # Select only columns that are needed and are consistently present\n  select(id, name, sub_type, content, timestamp) \n\n# --- 3. Clean and Prepare Edges ---\n# Rename 'type' in edges to 'edge_type' to avoid conflict with node 'supertype'\nmc3_edges_cleaned <- mc3_edges_raw %>%\n  rename(from_id = source,\n         to_id = target,\n         edge_type = type) %>% # Renamed 'type' to 'edge_type'\n  mutate(across(c(from_id, to_id), as.character)) %>%\n  # Filter out any edges where from_id or to_id are not in cleaned nodes\n  filter(from_id %in% mc3_nodes_cleaned$id,\n         to_id %in% mc3_nodes_cleaned$id)\n\nother_communications_df <- mc3_edges_cleaned %>%\n  filter(edge_type == \"sent\") %>% # Start with 'sent' edges\n  # Join with nodes to get content and timestamp of the Event_Communication node\n  left_join(mc3_nodes_cleaned %>% select(id, content, timestamp),\n            by = c(\"to_id\" = \"id\")) %>%\n  rename(event_id = to_id, event_content = content, event_timestamp = timestamp) %>%\n  # Now, find the recipient of this communication event\n  left_join(mc3_edges_cleaned %>%\n              filter(edge_type == \"received\") %>%\n              select(event_id_match = from_id, recipient_id = to_id),\n            by = c(\"event_id\" = \"event_id_match\")) %>%\n  # Join with nodes to get the sender's name and sub_type\n  left_join(mc3_nodes_cleaned %>% select(id, name, sub_type),\n            by = c(\"from_id\" = \"id\")) %>%\n  rename(sender_id_actual = from_id, sender_name = name, sender_sub_type = sub_type) %>%\n  # Join with nodes to get the recipient's name and sub_type\n  left_join(mc3_nodes_cleaned %>% select(id, name, sub_type),\n            by = c(\"recipient_id\" = \"id\")) %>%\n  rename(recipient_name = name, recipient_sub_type = sub_type) %>%\n  # Select and rename final columns for all communications\n  select(\n    communication_type = edge_type, # This will be \"sent\" from original filter\n    sender_id = sender_id_actual,\n    sender_name,\n    sender_sub_type,\n    recipient_id,\n    recipient_name,\n    recipient_sub_type,\n    event_id,\n    content = event_content,\n    timestamp = event_timestamp\n  ) \n\n# create a timeline visualization or inspect content.\nprint(knitr::kable(head(other_communications_df %>%\n                          select(timestamp, sender_name, \n                                 recipient_name, content), 10),\n                   format = \"markdown\", align = \"l\"))\n```\n:::\n\n### 6.1.2 Static Chord Diagram- All Communicators\n\n```{r, fig.width=10, fig.height=8, echo=FALSE, message=FALSE, warning=FALSE}\n\n# --- Step 1: Build communication matrix ---\nsent_df <- other_communications_df %>%\n  filter(communication_type == \"sent\") %>%\n  count(sender_name, recipient_name, name = \"sent\")\n\nreceived_df <- other_communications_df %>%\n  filter(communication_type == \"received\") %>%\n  count(sender_name = recipient_name, recipient_name = sender_name, name = \"received\")\n\ncombined_df <- full_join(sent_df, received_df, by = c(\"sender_name\", \"recipient_name\")) %>%\n  mutate(across(c(sent, received), ~replace_na(., 0)),\n         total = sent + received)\n\ncomm_matrix <- xtabs(total ~ sender_name + recipient_name, data = combined_df)\n\n# --- Step 2: Assign color per entity sub-type ---\ntype_lookup <- other_communications_df %>%\n  select(name = sender_name, type = sender_sub_type) %>%\n  bind_rows(other_communications_df %>% select(name = recipient_name, type = recipient_sub_type)) %>%\n  distinct(name, .keep_all = TRUE)\n\n# Define pastel Set2 colors for each type\ntype_colors_palette <- brewer.pal(n = 4, name = \"Set2\")\nnames(type_colors_palette) <- c(\"Person\", \"Organization\", \"Vessel\", \"Location\")\n\n# Map to nodes in the matrix\ngrid_colors <- type_colors_palette[type_lookup$type]\nnames(grid_colors) <- type_lookup$name\ngrid_colors <- grid_colors[rownames(comm_matrix)]\n\n# --- Step 3: Plot chord diagram ---\ncircos.clear()\npar(mar = c(4, 2, 8, 10))  # bottom, left, top, right\n\nchordDiagram(\n  comm_matrix,\n  grid.col = grid_colors,\n  transparency = 0.25,\n  annotationTrack = \"grid\",\n  preAllocateTracks = list(track.height = 0.1)\n)\n\n# Add readable sector names\ncircos.trackPlotRegion(\n  track.index = 1,\n  panel.fun = function(x, y) {\n    name <- get.cell.meta.data(\"sector.index\")\n    circos.text(\n      x = mean(get.cell.meta.data(\"xlim\")),\n      y = 0,\n      labels = str_wrap(name, 10),\n      facing = \"clockwise\",\n      niceFacing = TRUE,\n      adj = c(0, 0.5),\n      cex = 0.6\n    )\n  },\n  bg.border = NA\n)\n\n# --- Step 4: Title, subtitle ---\ntitle(\n  main = \"Chord Diagram of Communication Flows\",\n  cex.main = 1.6,\n  font.main = 2,\n  line = 5\n)\nmtext(\"Each ribbon shows volume of sent + received messages\", side = 3, line = 3, cex = 1, col = \"gray30\")\nmtext(\"Note. Group subtype is excluded from this diagram\", side = 1, line = 3, cex = 0.8, col = \"gray40\")\n\n# --- Step 5: Custom Legend ---\nlegend_items <- names(type_colors_palette)\nlegend(\n  x = 1.1, y = 0.85, legend = legend_items,\n  fill = type_colors_palette,\n  border = \"gray30\",\n  bty = \"n\",\n  cex = 0.7,\n  pt.cex = 0.7,\n  title = \"Entity Sub-Type\" \n\n)\n\n```\n\n**Findings:**\n\nThe thickness of each ribbon (chord) represents the magnitude of the relationship. A thicker ribbon represents more frequent communications (sent + received) between a sender and recipient.\n\nHere, we have an overview of paired communicators who have higher frequencies. We also can see the links between communicators. These are the entities who communicated frequently with others that we might want to focus on:\n\n-   Person: The Intern, The Lookout, Clepper Jensen, Davis, Miranda Jordan, Mrs. Money.\n\n-   Organization: Oceanus City Council, Green Guardian\n\n-   Vessel: Reef Guardian, Neptune, Mako, Remora\n\n-   Location: Himark Habor\n\n-   Group: N/A\n\n### 6.1.3 Heatmap of Correspondences\n\n::: panel-tabset\n## Heatmap\n\n```{r, echo=FALSE}\n# Step 1: Count interactions\nadj_df <- other_communications_df %>%\n  count(sender_name, recipient_name, name = \"count\")\n\n# Step 2: Compute total sent and received counts\nsender_order <- adj_df %>%\n  group_by(sender_name) %>%\n  summarise(total_sent = sum(count)) %>%\n  arrange(desc(total_sent)) %>%\n  pull(sender_name)\n\nrecipient_order <- adj_df %>%\n  group_by(recipient_name) %>%\n  summarise(total_received = sum(count)) %>%\n  arrange(desc(total_received)) %>%\n  pull(recipient_name)\n\n# Step 3: Reorder factor levels\nadj_df <- adj_df %>%\n  mutate(\n    sender_name = factor(sender_name, levels = sender_order),\n    recipient_name = factor(recipient_name, levels = recipient_order)\n  )\n\n# Step 4: Plot heatmap\nggplot(adj_df, aes(x = recipient_name, y = sender_name, fill = count)) +\n  geom_tile(color = \"white\") +\n  scale_fill_gradient(low = \"white\", high = \"navyblue\") +\n  labs(\n    title = \"Sender-Recipient Communication Heatmap\",\n    subtitle = \"Top communicators sorted to bottom-left\",\n    x = \"Recipient\",\n    y = \"Sender\",\n    fill = \"Messages\"\n  ) +\n  theme_minimal(base_size = 10) +\n  theme(\n    axis.text.x = element_text(angle = 45, hjust = 1),\n    plot.title = element_text(size = 12, face = \"bold\"),\n    plot.subtitle = element_text(size = 10),\n    panel.grid = element_blank()\n  )\n```\n\n## The Code\n\n``` r\n# Step 1: Count interactions\nadj_df <- other_communications_df %>%\n  count(sender_name, recipient_name, name = \"count\")\n\n# Step 2: Compute total sent and received counts\nsender_order <- adj_df %>%\n  group_by(sender_name) %>%\n  summarise(total_sent = sum(count)) %>%\n  arrange(desc(total_sent)) %>%\n  pull(sender_name)\n\nrecipient_order <- adj_df %>%\n  group_by(recipient_name) %>%\n  summarise(total_received = sum(count)) %>%\n  arrange(desc(total_received)) %>%\n  pull(recipient_name)\n\n# Step 3: Reorder factor levels\nadj_df <- adj_df %>%\n  mutate(\n    sender_name = factor(sender_name, levels = sender_order),\n    recipient_name = factor(recipient_name, levels = recipient_order)\n  )\n\n# Step 4: Plot heatmap\nggplot(adj_df, aes(x = recipient_name, y = sender_name, fill = count)) +\n  geom_tile(color = \"white\") +\n  scale_fill_gradient(low = \"white\", high = \"navyblue\") +\n  labs(\n    title = \"Sender-Recipient Communication Heatmap\",\n    subtitle = \"Top communicators sorted to bottom-left\",\n    x = \"Recipient\",\n    y = \"Sender\",\n    fill = \"Messages\"\n  ) +\n  theme_minimal(base_size = 10) +\n  theme(\n    axis.text.x = element_text(angle = 45, hjust = 1),\n    plot.title = element_text(size = 12, face = \"bold\"),\n    plot.subtitle = element_text(size = 10),\n    panel.grid = element_blank()\n  )\n```\n:::\n\n**Findings:**\n\nAfter extraction of the entities who communicated frequently (from the Static Chord Diagram), we tabled who they communicated with by using the heatmap. E.g. Name1 communicated with Name2.\n\n+----------------+----------------------+-----------------------------------------------------------------------------------------------------------------------------------------------------------+\n| Name 1 Subtype | Name1                | Name2                                                                                                                                                     |\n+================+======================+===========================================================================================================================================================+\n| Person         | The Intern           | The Lookout, Mrs. Money                                                                                                                                   |\n+----------------+----------------------+-----------------------------------------------------------------------------------------------------------------------------------------------------------+\n| Person         | Clepper Jensen       | Miranda Jordan                                                                                                                                            |\n+----------------+----------------------+-----------------------------------------------------------------------------------------------------------------------------------------------------------+\n| Person         | Davis                | Neptune                                                                                                                                                   |\n+----------------+----------------------+-----------------------------------------------------------------------------------------------------------------------------------------------------------+\n| Person         | Mrs. Money           | The Intern, The Middleman, Boss                                                                                                                           |\n+----------------+----------------------+-----------------------------------------------------------------------------------------------------------------------------------------------------------+\n| Vessel         | Mako                 | Remora, Green Guardians, Oceanus City Council, Neptune, Reef Guardians, Himark Harbor, Davis, Sentinel, Paackland Habor, Samantha Blake, Serenity, Osprey |\n+----------------+----------------------+-----------------------------------------------------------------------------------------------------------------------------------------------------------+\n| Vessel         | Remora               | Mako, Neptune, Himark Habor, Davis, Paackland Harbor, V. Miesel Shipping, Marlin, Small Fry                                                               |\n+----------------+----------------------+-----------------------------------------------------------------------------------------------------------------------------------------------------------+\n| Vessel         | Neptune              | Mako, Himark Habor, Remora, Mrs Money, V. Miesel Shipping, Nadia, Serenity                                                                                |\n+----------------+----------------------+-----------------------------------------------------------------------------------------------------------------------------------------------------------+\n| Vessel         | Reef Guardian        | Green Guardians, Oceanus City Council, Mako, Paackland Harbor, EcoVigil, Serenity, Defender                                                               |\n+----------------+----------------------+-----------------------------------------------------------------------------------------------------------------------------------------------------------+\n| Organization   | Green Guardian       | Green Guardians, Oceanus City Council, The Lookout, Sentinel, Horizon                                                                                     |\n+----------------+----------------------+-----------------------------------------------------------------------------------------------------------------------------------------------------------+\n| Organization   | Oceanus City Council | Green Guardians, Reef Guardians, Himark Harbor, Sentinel, Paackland Harbor, Liam Thorne, Samantha Blake, Haacklee Harbor                                  |\n+----------------+----------------------+-----------------------------------------------------------------------------------------------------------------------------------------------------------+\n| Location       | Himark Habor         | Oceanus City Council, Mako, Serenity, Marlin                                                                                                              |\n+----------------+----------------------+-----------------------------------------------------------------------------------------------------------------------------------------------------------+\n\n# **7) Tackling Question 2**\n\nIn section 7 and 8, we attempted to find answers to question 2 and 4, as we explored other interesting information.\n\n# Question 2a)\n\n### 7.1.2 Unique count from each sender subtype\n\n::: panel-tabset\n## Unique Count\n\n```{r, echo=FALSE}\nsender_names_by_type <- other_communications_df %>%\n  group_by(sender_sub_type) %>%\n  summarise(\n    unique_senders = n_distinct(sender_name),\n    sender_names = paste(sort(unique(sender_name)), collapse = \", \")\n  ) %>%\n  arrange(desc(unique_senders))  # sort from largest to smallest\n\n# View the table\nprint(sender_names_by_type)\n```\n\n## The Code\n\n``` r\nsender_names_by_type <- other_communications_df %>%\n  group_by(sender_sub_type) %>%\n  summarise(\n    unique_senders = n_distinct(sender_name),\n    sender_names = paste(sort(unique(sender_name)), collapse = \", \")\n  ) %>%\n  arrange(desc(unique_senders))  # sort from largest to smallest\n\n# View the table\nprint(sender_names_by_type)\n```\n\nThere were no Group sub-type as confirmed by this filtered table.\n:::\n\n## 7.2 People and Vessels\n\nDue to a large number of entity subtypes as people and vessels in 7.1.4, we then looked into the characters' and vessel's identity and their actual communication content.\n\n### 7.2.1 Filter by Vessel and Person only\n\n::: panel-tabset\n## The Code\n\n```{r}\nperson_vessel_df <- other_communications_df %>%\n  filter(\n    (sender_sub_type == \"Person\" & recipient_sub_type == \"Vessel\") |\n    (sender_sub_type == \"Vessel\" & recipient_sub_type == \"Person\") |\n    (sender_sub_type == \"Person\" & recipient_sub_type == \"Person\") |\n    (sender_sub_type == \"Vessel\" & recipient_sub_type == \"Vessel\")\n  )\n```\n:::\n\n### 7.2.2 Plotted Timeline- People & Vessels\n\n```{r}\n#| code-fold: true\n#| code-summary: \"Show the code\"\n# --- FACTORING and DATETIME CLEANING ---\nperson_vessel_df_for_plot <- person_vessel_df %>%\n  mutate(\n    timestamp = as.POSIXct(timestamp),\n    comm_date = as.Date(timestamp),\n    comm_time_of_day = hms::as_hms(format(timestamp, \"%H:%M:%S\")),\n    sender_sub_type = factor(sender_sub_type, levels = c(\"Person\", \"Vessel\")),\n    communicating_pair_sorted = paste(pmin(sender_name, recipient_name), pmax(sender_name, recipient_name), sep = \" & \")\n  )\n\n# --- WRAPPING CONTENT AND TOOLTIP ---\nplot_data1 <- person_vessel_df_for_plot %>%\n  mutate(\n    timestamp = as.POSIXct(timestamp),\n    date = as.Date(timestamp),\n    time = format(timestamp, \"%H:%M:%S\"),\n    wrapped_content = str_wrap(content, width = 50),\n    tooltip_text = paste0(\n      \"<b>Date:</b> \", date, \"<br>\",\n      \"<b>Time:</b> \", time, \"<br>\",\n      \"<b>From:</b> \", sender_name, \"<br>\",\n      \"<b>To:</b> \", recipient_name, \"<br>\",\n      \"<b>Event_id:</b> \", event_id, \"<br><br>\",\n      \"<b>Content:</b><br>\", wrapped_content\n    )\n  )\n\n# Plot\np <-ggplot(plot_data1, aes(x = comm_date, y = comm_time_of_day)) +\n  geom_point(aes(\n    color = sender_id,\n    shape = sender_sub_type,\n    text = tooltip_text\n  ),show.legend = c(color = TRUE, shape = FALSE), \n  size = 2, alpha = 0.7) +\n  scale_shape_manual(values = c(\"Person\" = 16, \"Vessel\" = 17)) +\n  facet_wrap(~ sender_sub_type, ncol = 1, scales = \"fixed\") +\n  scale_y_time(\n    limits = hms::as_hms(c(\"08:00:00\", \"14:00:00\")),  # reversed to show time top-to-bottom\n    breaks = hms::as_hms(c(\"08:00:00\", \"09:00:00\", \"10:00:00\", \"11:00:00\", \"12:00:00\", \"13:00:00\", \"14:00:00\")),\n    labels = c(\"08:00\", \"09:00\", \"10:00\", \"11:00\", \"12:00\", \"13:00\", \"14:00\")\n)+\n  scale_x_date(\n  date_breaks = \"1 day\",\n  date_labels = \"%d %b\"\n)+\n  labs(\n    title = \"Communication Events Over Time (Sender's Perspective)\",\n    x = \"Date\",\n    y = \"Time of Day\",\n    color = \"Sender (subtype, name)\"\n  ) +\n  theme_grey() +\n  theme(\n    axis.text.y = element_text(size = 6),\n    axis.title.y = element_text(size = 7),\n    axis.ticks.y = element_line(),\n    axis.text.x = element_text(size = 6, angle = 45, hjust = 1),\n    axis.title.x = element_text(margin = margin(t = 8), size = 7),\n    panel.spacing = unit(0.5, \"lines\"),  # Applies to both x and y spacing\n    strip.text = element_text(size = 8, face = \"bold\"),\n    legend.position = \"bottom\",\n    legend.text = element_text(size = 6),\n    legend.title = element_blank()\n  )\n\n# --- Convert to interactive plot ---\nggplotly(p, tooltip = \"tooltip_text\")\n```\n\n#### 7.2.2.1 Findings on People/ Vessels:\n\n-   Core logic:\n\n    -   If two names appear as sender and recipient in the same message, they cannot belong to the same person — i.e., they're not aliases of each other.\n\n    -   If two names sent a message at the exact time, they cannot belong to the same person.\n\n    -   For instance, if Nadia sent a message to The Accountant, they would not be the same individual. If Nadia sent a message at 10am to The Accountant and The Lookout also sent a message at 10am to The Intern, Nadia and The Lookout cannot be the same person.\n\n-   Select only The Accountant, Mrs. Money, Elise: We see close timings between Mrs. Money and Elise on 8 Oct, and 10 Oct. These were on the same topic. Elise then disappears from radar on 10 Oct. She reappears as The Accountant and Mrs. Money on 11 Oct on the same topic and remains only as The Accountant till 14 Oct.\n\n-   Select only Liam and The Middleman: The Middleman disappeared on 7 Oct and appeared as Liam on 8 Oct. On 11 Oct Mrs. Money asked The Middleman if anything was found by conservation vessels. On the same day, Liam reappeared and replied Elise that nothing was found by them.\n\n-   Select only The Boss and Nadia: The Boss disappeared on 5 Oct and reappeared as Nadia on 8 Oct. Likely the same person.\n\n-   Select only Small Fry and Rodriguez: on 2 Oct Rodriguez corresponded with Remora and Mako on meeting at the slip #14. It happened again on 14 Oct as he took on dual roles and responded to the same message with different names. Likely the same person.\n\n-   Select only The Lookout and Sam: on 7 Oct Sam asked Kelly to get information on who authorized the permit. 2 minutes later, The Lookout (Kelly) responded to The Intern (Sam), that it was signed by Jensen from City Council.\n\n-   Seawatch only appeared on 10 Oct but Horizon talked to Seawatch on 8 Oct. Therefore, some other entity is Seawatch before or during 8 Oct. Defender told Seawatch on 3 Oct at 8.39am that it increased its patrol and informed Seawatch to maintain vigilance. The Lookout (Seawatch) responded to Sentinel (Defender) at 8.41am that it acknowledged the need for vigilance.\n\n-   After getting a general idea of the characters' involvement, we looked at the interactions in 7.3.\n\n## 7.3 Discussion/ Interpretation on all communications:\n\nFrom the interactive plot, we were able to select certain names of individuals and/or vessels from the legend and read their conversations. We segmented entities based on our first cut of observations of the following people or vessels and rated them as suspicious or non-suspicious. We tabled out what we have learnt with variables: Sender, Recipient, Commonalities, Rationale, Suspicious?, Date, Event Id, in Section 7.3.1 and 7.3.2.\n\n### 7.3.1 Suspicious Conversations\n\n```{r}\n#| code-fold: true\n#| code-summary: \"Show the code\"\nlibrary(reactable)\nlibrary(dplyr)\nlibrary(stringr)\nlibrary(tidyr) # For separate_rows, if needed for 'Event Id' later\n\n# Create the data frame using tribble, consolidating multi-line entries\ndf_new_data <- tribble(\n  ~Sender, ~Recipient, ~Commonalities, ~Rationale, ~Suspicious_Status, ~Date, ~Event_Id,\n  \"The Lookout (Person)\", \"The Intern (Person)\", \"Mako\", \"Jensen from City Council signed a permit to set a corridor for Mako vessel.\", \"Jensen\", \"5/10\", \"371\",\n  \"Glitters Team aka. Sailor Shift Team\", \"Boss (Person)\", \"Permit, Commissioner Torres\", \"Glitters thanked their Boss who got Commissioner Torres to sign off the permit\", \"Nadia aka The Boss\", \"6/10\", \"389\",\n  \"Remora (Vessel)\", \"Sailor Shift Team aka. Glitters Team\", \"Permit, Commissioner Torres\", \"Davis thanked Nadia who got Commissioner Torres to sign off the permit\", \"Nadia aka The Boss\", \"6/10\", \"388\",\n  \"Mrs. Money (Person)\", \"Mako (Vessel); Neptune (Vessel)\", \"Mako, Remora, Neptune\", \"Mrs. Money is the Financial Controller who provides the payment protocols for Mako and Remora's captions. She also provides the encryption protocols and transfer devices. Mrs. Money coordinates payment protocols for Remora and Mako captains\", \"Elise aka. Mrs. Money\", \"7/10\", \"458 and 464\",\n  \"Neptune/ Neptune Captain\", \"Elise aka. Mrs. Money (Person)\", \"Remora, Mako\", \"Neptune told her to coordinate payment protocols for Remora and Mako captains\", \"Elise aka. Mrs. Money\", \"7/10\", \"456 and 518\",\n  \"Remona (Vessel)\", \"Rodriquez (Person)\", \"Sailor Shift\", \"Nemo Reef selected for Sailor Shift's music shoot.; Nadia personally handled permits for Nemo Reefs after meeting Davis.\", \"Both\", \"2/10\", \"153 and 328\",\n  \"Remona (Vessel)\", \"Nadia (Person)\", \"Delta 3, Sailor Shift\", \"Tourism facade created by Remona and awaiting installation of underwater lighting placements at Nemo Reef.\", \"Both\", \"14/10\", \"943\",\n  \"Davis (Person)\", \"Mako (Vessel)\", \"Rodriquez, Nadia, Neptune\", \"Rodriquez will help with logistics.\", \"Both\", \"2/10\", \"115\",\n  \"Davis (Person)\", \"Mako (Vessel)\", \"Rodriquez, Nadia, Neptune\", \"V. Miesel's Marine Research Permit is CR-7844. There is a 5 day deadline from 8 Oct.\", \"Both\", \"8/10\", \"548\",\n  \"Davis (Person)\", \"Mako (Vessel)\", \"Rodriquez, Nadia, Neptune\", \"V. Miesel approved their operational authority.\", \"Both\", \"12/10\", \"802\",\n  \"Davis (Person)\", \"Remona (Vessel)\", \"Client\", \"Davis wants to maintain client's privacy with Paackland Harbour.\", \"Both, and also Paackland Harbour\", \"4/10\", \"282\",\n  \"Mako (Vessel)\", \"Davis (Person)\", \"Permit CR-7844, Boss\", \"Davis is a captain.\", \"Both\", \"5/10\", \"349\",\n  \"Mako (Vessel)\", \"Boss (Person)\", \"Boss, Samantha\", \"Oceanus Council approved Mako's departure to Nemo Reef with minimal documentation.\", \"Oceanus Council\", \"5/10\", \"365\",\n  \"Boss (Person)\", \"Marko (Vessel)\", \"Mission, Boss\", \"Informed Marko to abort mission as conservation patrols are tracking it\", \"Both\", \"4/10\", \"316\",\n  \"Small Fry aka Rodriquez (Person)\", \"Remora (Vessel, Mako (Vessel)\", \"Slip #14, Glitters Team, Sailor Team\", \"Mako asked Rodriquez when he could come by slip #14.; Small Fry replied he would come by slip #14 in 30 minutes time.; Small Fry surprised that Glitters Team filing for paperwork downtown for protected area of Nemo Reef.\", \"Both\", \"2/10\", \"142, 143 and 156\",\n  \"Neptune\", \"Nadia (Person); Neptune (Vessel)\", \"Equipment specs\", \"Neptune asked to meet Nadia at 0600 and confirm the equipment specs approved by Elise.; Nadia confirmed the time with Neptune and agreed to show her reviewed equipment specs from The Accountant.\", \"Both; Elise aka The Accountant\", \"8/10\", \"537 and 738\",\n  \"Knowles (Vessel)\", \"Davis (Person)\", \"Boss\", \"Instructed by Mako to provide equipment transfer.\", \"Both\", \"14/10\", \"1001 and 1003\",\n  \"Sentinel(Vessel)\", \"Mako (Vessel)\", \"Permit\", \"Mako told Sentinel it was operating under NR-1045.\", \"Mako\", \"7/10\", \"467\",\n  \"Mako (Vessel)\", \"Sentinel (Vessel)\", \"Permit\", \"Sentinel asked the reasons for Mako operating under permit NR-1045\", \"Mako\", \"8/10\", \"574\",\n  \"Mako (Vessel)\", \"Sentinel (Vessel)\", \"Permit\", \"Mako told Sentinel it was operating under permit CR-7844 (marine equipment transport) not NR-1045\", \"Mako\", \"8/10\", \"575\",\n  \"Miranda (Person)\", \"Clepper Jesen (Person)\", \"Rodriquez\", \"Rodriquez filed for permits under Sailor Shifts Team for 2 commercial and 1 private yatch to perform environmental sampling.\", \"Rodriquez is suspicious. The communicators are not suspicious.\", \"2/10\", \"130\",\n  \"Miranda (Person)\", \"Clepper Jesen (Person)\", \"Rodriquez\", \"Rodriquez is connected to a mining consortium with previous violations in protected areas.\", \"Rodriquez is suspicious. The communicators are not suspicious\", \"2/10\", \"134\",\n  \"Miranda (Person)\", \"Clepper Jesen (Person)\", \"Rodriquez\", \"Rodriquez is connected to Council Knowles and they are related to V. Miesel Shipping which is possibly a shell company which has vessels.\", \"Rodriquez is suspicious. The communicators are not suspicious.\", \"3/10\", \"201\",\n  \"Miranda (Person)\", \"Clepper Jesen (Person)\", \"Rodriquez is suspicious\", \"Council Knowles' brother-in-law owns the offshore bank account to V. Miesel Shipping. The company is involved in rare earth extraction.\", \"Rodriquez is suspicious. The communicators are not suspicious.\", \"3/10\", \"204\",\n  \"Miranda (Person)\", \"Clepper Jesen (Person)\", \"Rodriquez is suspicious\", \"Knowles accepted cash from Rodriquez.\", \"Rodriquez is suspicious. The communicators are not suspicious.\", \"3/10\", \"206\"\n)\n\n# Process the data (primarily for consistent whitespace and Event_Id splitting if necessary)\ndf_processed <- df_new_data %>%\n  # Standardize delimiters and remove excess whitespace across all character columns.\n  mutate(\n    across(where(is.character), ~ str_replace_all(.x, \"[,\\n]+\", \", \") %>% str_trim())\n  ) %>%\n  # For Event_Id, replace \"and\" with comma and then separate rows if needed\n  mutate(Event_Id = str_replace_all(Event_Id, \" and \", \", \")) %>%\n  mutate(across(where(is.character), str_trim)) %>%\n  mutate(Event_Id = as.character(Event_Id)) # Ensure Event_Id is character\n\n# Create the reactable table\nreactable(\n  df_processed,\n  filterable = TRUE,\n  searchable = TRUE,\n  paginationType = \"numbers\",\n  defaultPageSize = 5,\n  showPageSizeOptions = TRUE,\n  pageSizeOptions = c(5, 10, 20, 50, 100),\n  striped = TRUE,\n  highlight = TRUE,\n  columns = list(\n    Sender = colDef(name = \"Sender\", minWidth = 120),\n    Recipient = colDef(name = \"Recipient\", minWidth = 120),\n    Commonalities = colDef(name = \"Commonalities\", minWidth = 150),\n    Rationale = colDef(name = \"Rationale\", minWidth = 300),\n    # Rename Suspicious_Status for display\n    Suspicious_Status = colDef(name = \"Suspicious?\", minWidth = 150),\n    # Date column as text, no special date sorting\n    Date = colDef(name = \"Date\", minWidth = 80, align = \"center\"),\n    Event_Id = colDef(name = \"Event Id\", minWidth = 80, align = \"center\")\n  ),\n  theme = reactableTheme(\n    borderColor = \"#dfe2e5\",\n    stripedColor = \"#f6f8fa\",\n    highlightColor = \"#f0f5f9\",\n    cellPadding = \"8px 12px\",\n    style = list(fontFamily = \"Verdana, Geneva, sans-serif\", fontSize = \"14px\"),\n    headerStyle = list(\n      \"&.rt-th:hover\" = list(backgroundColor = \"#e0e6eb\"),\n      fontSize = \"15px\",\n      fontWeight = 600,\n      color = \"#333\",\n      background = \"#f7f7f7\"\n    ),\n    rowSelectedStyle = list(backgroundColor = \"#e6f2ff\", \"&:hover\" = list(backgroundColor = \"#e6f2ff\")),\n    searchInputStyle = list(width = \"100%\", margin = \"5px 0\", padding = \"5px\"),\n    filterInputStyle = list(width = \"100%\", margin = \"2px 0\", padding = \"4px\")\n  )\n)\n```\n\n### 7.3.2 Non-suspicious conversations\n\n```{r}\n#| code-fold: true\n#| code-summary: \"Show the code\"\n# Load necessary packages\nlibrary(reactable)\nlibrary(dplyr)\nlibrary(stringr)\nlibrary(tidyr) # For separate_rows\nlibrary(lubridate) # For date parsing\n\n# 1. Manually parse the data into a tribble\n# Each row in the tribble corresponds to a logical entry from provided text.\n# Multi-line strings within a cell are captured using '\\n'.\n# The 'Suspicious?' column is named 'Suspicious_Status' in R to avoid special characters,\n# and will be renamed in the reactable column definition for display.\ndf_raw_input <- tribble(\n  ~Sender, ~Recipient, ~Commonalities, ~Rationale, ~Suspicious_Status, ~Date, ~Event_Id,\n  \"Samantha (Person)\", \"Sailor Shift Team aka Glitters Team (Organization)\", \"Permit, Nemo Reef, Music Video\", \"Samantha was assisting Sailor Shift Team to coordinate the permit and equipment rental for their music video and wanted confirmation on Nemo Reef as their intended location.\", \"Unsure\", \"1/10\", \"64\",\n  \"Sailor Shift Team aka Glitters Team (Organization)\", \"Samantha (Person)\", \"Permit, Nemo Reef,\", \"Glitters Team confirmed with Samantha that they would like to use Nemo Reef as their primary location\", \"Unsure\", \"1/10\", \"66\",\n  \"Mako (Vessel)\", \"Samantha (Person)\", \"Nemo Reef Permit\", \"Mako claims that Samantha has a coordination team. Preparing for an event in a week's time from 6 Oct.\", \"Samantha is not\", \"6/10\", \"380\",\n  \"Mako (Vessel)\", \"Samantha (Person)\", \"Nemo Reef Permit\", \"Samantha advised them to stop activities which might be illegal without permit\", \"Samantha is not\", \"10/10\", \"687\",\n  \"The Lookout (Person)\", \"Sentinel (Vessel)\", \"Marina's Dream, Music Video\", \"Spotted 3 suspicious vessels around Nemo Reef on 3/10.\", \"Both are not\", \"3/10\", \"171\",\n  \"The Lookout (Person)\", \"Sentinel (Vessel)\", \"Marina's Dream, Music Video\", \"Spotted music video production on 13/10\", \"Both are not\", \"13/10\", \"912\",\n  \"The Lookout (Person)\", \"Horizon (Vessel)\", \"Music Video\", \"Found it suspicious to spot lighting rigs and cameras at 12pm. Wanted Horizon to investigate\", \"Both are not\", \"13/10\", \"926\",\n  \"EcoVigil (Vessel)\", \"Liam (Person)\", \"ROVs\", \"Collection of water samples using ROVs\", \"EcoVigil is not\", \"11/10\", \"737 and 751\" # \"and\" will be handled by separate_rows\n)\n\n# 2. Process the data for display and sorting\ndf_processed <- df_raw_input %>%\n  # Standardize delimiters and remove excess whitespace across all character columns.\n  # This flattens multi-line strings within cells and makes 'separate_rows' more reliable.\n  mutate(\n    across(where(is.character), ~ str_replace_all(.x, \"[,\\n]+\", \", \") %>% str_trim())\n  ) %>%\n  # Handle the \"and\" in Event_Id, converting it to a comma for consistent splitting.\n  mutate(Event_Id = str_replace_all(Event_Id, \" and \", \", \")) %>%\n  # Now, use separate_rows for Event_Id if it contains multiple comma-separated values.\n  # 'Date' column appears to be single-valued in this dataset, so it's not included here.\n  # If Date could also have multiple values (e.g., \"1/10, 2/10\"), you would add it to separate_rows.\n  separate_rows(Event_Id, sep = \", \", convert = FALSE) %>%\n  # Trim whitespace again after separation in case of leading/trailing spaces\n  mutate(across(where(is.character), str_trim)) %>%\n  # Convert Date to actual date objects for proper sorting.\n  # Using `dmy` for day/month/year format and assuming the current year (2025).\n  mutate(\n    FullDate = paste0(Date, \"/2025\"), # Add the current year for correct parsing\n    ParsedDate = dmy(FullDate, quiet = TRUE) # Convert to Date object (Day Month Year)\n  ) %>%\n  # Order the data by parsed date and then event ID\n  arrange(ParsedDate, Event_Id) %>%\n  select(-FullDate) %>% # Remove the helper column\n  # Ensure Event_Id is character type for display purposes\n  mutate(Event_Id = as.character(Event_Id))\n\n# 3. Create the reactable table\nreactable(\n  df_processed,\n  filterable = TRUE, # Enable column filters at the top of each column\n  searchable = TRUE, # Add a global search box above the table\n  paginationType = \"numbers\", # Display page numbers (e.g., 1, 2, 3 instead of Prev/Next)\n  defaultPageSize = 5, # Show 5 rows per page by default\n  showPageSizeOptions = TRUE, # Allow users to select different page sizes\n  pageSizeOptions = c(5, 10, 20, 50, 100), # Available page size options\n  striped = TRUE, # Add alternating row colors for better readability\n  highlight = TRUE, # Highlight the row when the user hovers over it\n  # Define the default sorting for the table when it first loads\n  defaultSorted = list(ParsedDate = \"asc\"), # Sort by the hidden ParsedDate column in ascending order\n  columns = list(\n    # The 'ParsedDate' column is used internally for correct date sorting but is not displayed\n    ParsedDate = colDef(\n      show = FALSE\n    ),\n    # Define how each visible column should be displayed and behave\n    Date = colDef(\n      name = \"Date\", # Display name for the column header\n      defaultSortOrder = \"asc\", # Ensure initial sort is ascending for the displayed date\n      minWidth = 80, # Minimum width for the column to ensure content fits\n      align = \"center\" # Align text to the center for better presentation of dates\n    ),\n    Sender = colDef(name = \"Sender\", minWidth = 120),\n    Recipient = colDef(name = \"Recipient\", minWidth = 120),\n    Commonalities = colDef(name = \"Commonalities\", minWidth = 150),\n    Rationale = colDef(name = \"Rationale\", minWidth = 300),\n    # Custom definition for the 'Suspicious_Status' column to display its original name\n    Suspicious_Status = colDef(name = \"Suspicious?\", minWidth = 150),\n    Event_Id = colDef(\n      name = \"Event ID\", # Display name for the column header\n      minWidth = 80, # Minimum width\n      align = \"center\" # Align text to the center\n    )\n  ),\n  # Customize the visual theme of the reactable table for a consistent look and feel\n  theme = reactableTheme(\n    borderColor = \"#dfe2e5\", # Defines the color of table borders\n    stripedColor = \"#f6f8fa\", # Defines the background color of striped rows\n    highlightColor = \"#f0f5f9\", # Defines the background color when a row is hovered over\n    cellPadding = \"8px 12px\", # Sets the padding inside table cells\n    style = list(fontFamily = \"Verdana, Geneva, sans-serif\", fontSize = \"14px\"), # General font family and size for table content\n    headerStyle = list(\n      \"&.rt-th:hover\" = list(backgroundColor = \"#e0e6eb\"), # Hover effect for table headers\n      fontSize = \"15px\", # Font size for headers\n      fontWeight = 600, # Font weight for headers (bold)\n      color = \"#333\", # Text color for headers\n      background = \"#f7f7f7\" # Background color for headers\n    ),\n    rowSelectedStyle = list(backgroundColor = \"#e6f2ff\", \"&:hover\" = list(backgroundColor = \"#e6f2ff\")), # Style for selected rows\n    searchInputStyle = list(width = \"100%\", margin = \"5px 0\", padding = \"5px\"), # Style for the global search input box\n    filterInputStyle = list(width = \"100%\", margin = \"2px 0\", padding = \"4px\") # Style for individual column filter input boxes\n  )\n)\n```\n\n# Question 2b)\n\n## 7.5 Community Detection and Centrality Measure- ggraph\n\n### 7.5.1 Community Detection- All\n\nSince we had an idea of the identity of the characters involved and their sub types, we wanted to uncover the communities they belonged to. We used the Louvian method for community detection to find communities that were densely connected internally but sparse to others.\n\n::: panel-tabset\n## Community Detection\n\n```{r, echo=FALSE}\nset.seed(1234)  \n\n# --- STEP 1: Prepare the edge list ---\nedge_df <- other_communications_df %>%\n  select(sender_id, recipient_id) %>%\n  filter(!is.na(sender_id) & !is.na(recipient_id)) %>%\n  rename(from = sender_id, to = recipient_id) %>%\n  distinct()\n\n# Remove self-loops\nedge_df <- edge_df %>% filter(from != to)\n\n# --- STEP 2: Create the graph object (undirected) ---\ng <- tbl_graph(edges = edge_df, directed = FALSE)\n\n# --- STEP 3: Run Louvain community detection ---\ng <- g %>%\n  mutate(community = group_louvain())\n\n# --- STEP 4: Visualize the graph ---\nggraph(g, layout = \"fr\") +\n  geom_edge_link(alpha = 0.3) +\n  geom_node_point(aes(color = as.factor(community)), size = 5) +\n  geom_node_text(aes(label = name), repel = TRUE, size = 3) +\n  theme_void() +\n  labs(title = \"Community Detection in Communication Network\",\n       color = \"Community\")\n```\n\n## The Code\n\n``` r\nset.seed(1234)  \n\n# --- STEP 1: Prepare the edge list ---\nedge_df <- other_communications_df %>%\n  select(sender_id, recipient_id) %>%\n  filter(!is.na(sender_id) & !is.na(recipient_id)) %>%\n  rename(from = sender_id, to = recipient_id) %>%\n  distinct()\n\n# Remove self-loops\nedge_df <- edge_df %>% filter(from != to)\n\n# --- STEP 2: Create the graph object (undirected) ---\ng <- tbl_graph(edges = edge_df, directed = FALSE)\n\n# --- STEP 3: Run Louvain community detection ---\ng <- g %>%\n  mutate(community = group_louvain())\n\n# --- STEP 4: Visualize the graph ---\nggraph(g, layout = \"fr\") +\n  geom_edge_link(alpha = 0.3) +\n  geom_node_point(aes(color = as.factor(community)), size = 5) +\n  geom_node_text(aes(label = name), repel = TRUE, size = 3) +\n  theme_void() +\n  labs(title = \"Community Detection in Communication Network\",\n       color = \"Community\")\n```\n:::\n\n### 7.5.2 Centrality Measure- All\n\nWe then proceeded to use the PageRank centrality algorithm to assign a numerical weight to each node to reflect its importance. The community attribute we previously calculated was then assigned to this graph.\n\n::: panel-tabset\n## PageRank Centrality Algorithm\n\n```{r, echo=FALSE}\nset.seed(1234) \n\n# --- Compute Centrality Measures ---\ng <- g %>%\n  mutate(\n    pagerank = centrality_pagerank(),\n    degree = centrality_degree(),\n    betweenness = centrality_betweenness(),\n    closeness = centrality_closeness()\n  )\n\n# Show top 10 nodes by PageRank\ng %>%\n  as_tibble() %>%\n  select(name, pagerank, degree, betweenness, closeness) %>%\n  arrange(desc(pagerank)) %>%\n  head(10)\n```\n\n## The Network\n\n```{r, echo=FALSE}\nset.seed(1234) \n\n# Visualize by Centrality\nggraph(g, layout = \"fr\") +\n  geom_edge_link(alpha = 0.3) +\n  geom_node_point(aes(size = pagerank, color = as.factor(community)), alpha = 0.8) +\n  geom_node_text(aes(label = name),\n                 repel = TRUE,\n                 size = 3,\n                 max.iter = 5000) + # <--- Increased this value \n  theme_void() +\n  labs(title = \"Network with PageRank Centrality\",\n       size = \"PageRank\", color = \"Community\")\n```\n\n## The Code\n\n``` r\nset.seed(1234) \n\n# --- STEP: Compute Centrality Measures ---\ng <- g %>%\n  mutate(\n    pagerank = centrality_pagerank(),\n    degree = centrality_degree(),\n    betweenness = centrality_betweenness(),\n    closeness = centrality_closeness()\n  )\n\n# Show top 10 nodes by PageRank\ng %>%\n  as_tibble() %>%\n  select(name, pagerank, degree, betweenness, closeness) %>%\n  arrange(desc(pagerank)) %>%\n  head(10)\n\n# Visualize by Centrality\nggraph(g, layout = \"fr\") +\n  geom_edge_link(alpha = 0.3) +\n  geom_node_point(aes(size = pagerank, color = as.factor(community)), alpha = 0.8) +\n  geom_node_text(aes(label = name),\n                 repel = TRUE,\n                 size = 3,\n                 max.iter = 5000) + # <--- Increased this value \n  theme_void() +\n  labs(title = \"Network with PageRank Centrality\",\n       size = \"PageRank\", color = \"Community\")\n```\n:::\n\n#### **7.5.2.1 Findings**:\n\n-   There were around 6 closely associated groups. Community 5 (Clepper and Miranda) appeared to be segmented from the central group, due to the non-involvement from the nature of the investigative work.\n-   From the graph, we extracted the 11 influential nodes to focus on:\n    -   Community 1: Reef Guardian, EcoVigil\n    -   Community 2: Neptune, Remora, Nadia, V. Miesel Shipping, Davis\n    -   Community 3: Mako\n    -   Community 4: Mrs. Money, Boss, The Middleman\n    -   Community 5: N/A as they were not very influential at global level\n    -   Community 6: N/A as they were not very influential at global level\n\n### 7.5.3 Wordclouds- Bigram\n\n::: panel-tabset\n## The Wordclouds\n\n```{r, echo=FALSE}\n# 1. Extract node community assignments\ng_node_communities <- g %>%\n  as_tibble() %>%\n  select(sender_name = name, community)\n\n# 2. Join communication content with community assignments\ncontent_with_community <- other_communications_df %>%\n  left_join(g_node_communities, by = c(\"sender_name\")) %>%\n  filter(!is.na(community), !is.na(content))\n\n# 3. Unnest tokens for unigrams\nunigrams <- content_with_community %>%\n  unnest_tokens(word, content, token = \"words\") %>%\n  anti_join(stop_words, by = \"word\") %>%\n  count(community, word, sort = TRUE)\n\n# 4. Unnest tokens for bigrams\nbigrams <- content_with_community %>%\n  unnest_tokens(bigram, content, token = \"ngrams\", n = 2) %>%\n  separate(bigram, into = c(\"word1\", \"word2\"), sep = \" \") %>%\n  filter(!word1 %in% stop_words$word,\n         !word2 %in% stop_words$word) %>%\n  unite(bigram, word1, word2, sep = \" \") %>%\n  count(community, bigram, sort = TRUE)\n\n# 5a. Plot word clouds per community\npar(mfrow = c(2, 3))  # 2 rows, 3 columns layout for 6 communities\nfor (i in sort(unique(bigrams$community))) {\n  words <- bigrams %>% filter(community == i)\n  \n  if (nrow(words) < 1) next  # Skip if no words\n  \n  suppressWarnings({\n    set.seed(432)  # Set seed for reproducibility\n    wordcloud(words = words$bigram,  # <-- FIXED here\n              freq = words$n,\n              max.words = min(20, nrow(words)),\n              scale = c(3, 0.5),\n              colors = brewer.pal(8, \"Dark2\"),\n              random.order = FALSE)\n  })\n  mtext(paste(\"Community\", i), side = 3, line = 1, adj = 0.5, cex = 1.5, col = \"black\")\n}\n```\n\n## The Code\n\n``` r\n# 1. Extract node community assignments\ng_node_communities <- g %>%\n  as_tibble() %>%\n  select(sender_name = name, community)\n\n# 2. Join communication content with community assignments\ncontent_with_community <- other_communications_df %>%\n  left_join(g_node_communities, by = c(\"sender_name\")) %>%\n  filter(!is.na(community), !is.na(content))\n\n# 3. Unnest tokens for unigrams\nunigrams <- content_with_community %>%\n  unnest_tokens(word, content, token = \"words\") %>%\n  anti_join(stop_words, by = \"word\") %>%\n  count(community, word, sort = TRUE)\n\n# 4. Unnest tokens for bigrams\nbigrams <- content_with_community %>%\n  unnest_tokens(bigram, content, token = \"ngrams\", n = 2) %>%\n  separate(bigram, into = c(\"word1\", \"word2\"), sep = \" \") %>%\n  filter(!word1 %in% stop_words$word,\n         !word2 %in% stop_words$word) %>%\n  unite(bigram, word1, word2, sep = \" \") %>%\n  count(community, bigram, sort = TRUE)\n\n# 5a. Plot word clouds per community\npar(mfrow = c(2, 3))  # 2 rows, 3 columns layout for 6 communities\nfor (i in sort(unique(bigrams$community))) {\n  words <- bigrams %>% filter(community == i)\n  \n  if (nrow(words) < 1) next  # Skip if no words\n  \n  suppressWarnings({\n    set.seed(432)  # Set seed for reproducibility\n    wordcloud(words = words$bigram,  # <-- FIXED here\n              freq = words$n,\n              max.words = min(20, nrow(words)),\n              scale = c(3, 0.5),\n              colors = brewer.pal(8, \"Dark2\"),\n              random.order = FALSE)\n  })\n  mtext(paste(\"Community\", i), side = 3, line = 1, adj = 0.5, cex = 1.5, col = \"black\")\n}\n```\n:::\n\n-   Certain words stood out more by their size in the unigram and bigrams. To view clearer frequencies and patterns among the community, we furthered the visualisations into circular barcharts of bigrams.\n\n### 7.5.4 Circular barchart for Top Bigrams per Community\n\n::: panel-tabset\n## The Circular Barchart\n\n```{r, echo=FALSE, message=FALSE, warning=FALSE, `fig-width`=10, `fig-height`=10}\nset.seed(1234)\n# --- Configuration ---\nnum_top_bigrams_per_community <- 8\nempty_bar_count <- 2 # gaps btw comm.\n#excluded_community <- 5 # too little in community 5\n\n# --- 1. Prepare the Combined Dataset ---\nall_communities_data <- bigrams %>%\n#  filter(community != excluded_community) %>%\n  group_by(community) %>%\n  arrange(desc(n)) %>%\n  slice_head(n = num_top_bigrams_per_community) %>%\n  ungroup()\n\nall_communities_data$community <- as.factor(all_communities_data$community)\n\nto_add <- data.frame(\n  bigram = NA,\n  n = NA,\n  community = rep(levels(all_communities_data$community), each = empty_bar_count)\n)\n\nplot_data <- rbind(all_communities_data, to_add) %>%\n  arrange(community)\n\nplot_data$id <- seq_len(nrow(plot_data)) # Keep ID as numeric here\n\n# --- 2. Prepare Label Data ---\nlabel_data <- plot_data\nnumber_of_bar <- nrow(label_data)\nlabel_data$angle <- 90 - 360 * (label_data$id - 0.5) / number_of_bar\nlabel_data$hjust <- ifelse(label_data$angle < -90, 1, 0)\nlabel_data$angle <- ifelse(label_data$angle < -90, label_data$angle + 180, label_data$angle)\n\n# --- 3. Prepare Data for Baselines (Community Dividers) ---\nbase_data <- plot_data %>%\n  group_by(community) %>%\n  summarize(\n    start = min(id, na.rm = TRUE), # Keep as numeric\n    end = max(id, na.rm = TRUE) - empty_bar_count # Keep as numeric\n  ) %>%\n  rowwise() %>%\n  mutate(\n    title_position = mean(c(start, end))\n  ) %>%\n  ungroup()\n\n# --- 4. Prepare Data for Grid Lines (Optional: Value Scales) ---\nmax_n_value <- max(plot_data$n, na.rm = TRUE)\ngrid_lines_values <- c(20, 40, 60, 80, 100)\ngrid_lines_values <- grid_lines_values[grid_lines_values <= max_n_value]\n\ngrid_segments_data <- plot_data %>%\n  group_by(community) %>%\n  summarize(\n    start_id = min(id, na.rm = TRUE), # Keep as numeric\n    end_id = max(id, na.rm = TRUE) - empty_bar_count # Keep as numeric\n  )\n\ngrid_data_final <- tibble()\nfor(val in grid_lines_values) {\n  temp_data <- grid_segments_data %>%\n    mutate(y_value = val)\n  grid_data_final <- bind_rows(grid_data_final, temp_data)\n}\n\n# --- Data for grid line LABELS ---\ngrid_label_data <- data.frame(\n  x_pos = max(plot_data$id, na.rm = TRUE) + 2, # Fixed x position outside the plot\n  y_pos = grid_lines_values,\n  label_text = as.character(grid_lines_values)\n)\n\n# --- 5. Make the Unified Plot ---\np <- ggplot(plot_data, aes(x = id, y = n, fill = community)) + # <--- x = id (numeric)\n  # Add background grid lines for value (e.g., 20, 40, 60, 80)\n  geom_segment(data = grid_data_final,\n               aes(x = start_id - 0.5, y = y_value, xend = end_id + 0.5, yend = y_value),\n               inherit.aes = FALSE,\n               color = \"grey\", alpha = 0.8, linewidth = 0.3) +\n\n  # Add text showing the value of each grid line at a fixed position\n  geom_text(data = grid_label_data,\n            aes(x = x_pos, y = y_pos, label = label_text),\n            inherit.aes = FALSE,\n            color = \"grey\", size = 3, angle = 0, fontface = \"bold\", hjust = 0) +\n\n  # Bars for the bigrams (main plot elements)\n  geom_bar(stat = \"identity\", alpha = 0.8, color = \"white\", linewidth = 0.1,\n           width = 1.4) + # <--- Add width=1 to remove space between bars if id is numeric\n\n  # Set limits for the y-axis, providing space for labels\n  ylim(-max_n_value * 0.7, max_n_value * 1.2) +\n\n  theme_minimal() +\n  theme(\n    legend.position = \"none\",\n    axis.text = element_blank(),\n    axis.title = element_blank(),\n    panel.grid = element_blank(),\n    plot.margin = unit(c(1.5, 1.5, 1.5, 1.5), \"cm\") # Top, Right, Bottom, Left margins\n  ) +\n  coord_polar(start = 0) +\n\n  # Add bigram labels\n  geom_text(\n    data = label_data,\n    aes(x = id, y = n + 10, label = bigram, hjust = hjust), # <--- x = id (numeric)\n    color = \"black\", fontface = \"bold\", alpha = 0.8, size = 2.8,\n    angle = label_data$angle, inherit.aes = FALSE\n  ) +\n\n  # Add base lines for each community segment\n  geom_segment(\n    data = base_data,\n    aes(x = start - 0.5, y = -10, xend = end + 0.5, yend = -10),\n    colour = \"black\", alpha = 0.8, linewidth = 0.6, inherit.aes = FALSE\n  ) +\n\n  # Add community group labels\n  geom_text(\n    data = base_data,\n    aes(x = title_position, y = -40, label = paste(\"Comm.\", community)),\n    colour = \"black\", alpha = 0.9, size = 2, fontface = \"bold\", inherit.aes = FALSE\n  )+\n  # --- Add the Title ---\n  labs(\n    title = \"Circular Bar Chart by Community\",\n    subtitle = \"Frequencies of key bigrams within each community\", # Updated subtitle\n    caption = paste0(\"AT | Generated: \", Sys.Date())\n  ) +\n  # Apply the Set2 Brewer palette\n  scale_fill_brewer(palette = \"Set2\") +\n  # --- Customize title appearance ---\n  theme(\n    plot.title = element_text(hjust = 0.5, size = 16, face = \"bold\", margin = margin(b = 10)),\n    plot.subtitle = element_text(hjust = 0.5, size = 12, margin = margin(b = 10)),\n    plot.caption = element_text(hjust = 1, size = 7, color = \"grey50\")\n  )\n\nprint(p)\n```\n\n## allThe Code\n\n``` r\n# --- Configuration ---\nnum_top_bigrams_per_community <- 8\nempty_bar_count <- 2 # gaps btw comm.\n#excluded_community <- 5 # too little in community 5\n\n# --- 1. Prepare the Combined Dataset ---\nall_communities_data <- bigrams %>%\n#  filter(community != excluded_community) %>%\n  group_by(community) %>%\n  arrange(desc(n)) %>%\n  slice_head(n = num_top_bigrams_per_community) %>%\n  ungroup()\n\nall_communities_data$community <- as.factor(all_communities_data$community)\n\nto_add <- data.frame(\n  bigram = NA,\n  n = NA,\n  community = rep(levels(all_communities_data$community), each = empty_bar_count)\n)\n\nplot_data <- rbind(all_communities_data, to_add) %>%\n  arrange(community)\n\nplot_data$id <- seq_len(nrow(plot_data)) # Keep ID as numeric here\n\n# --- 2. Prepare Label Data ---\nlabel_data <- plot_data\nnumber_of_bar <- nrow(label_data)\nlabel_data$angle <- 90 - 360 * (label_data$id - 0.5) / number_of_bar\nlabel_data$hjust <- ifelse(label_data$angle < -90, 1, 0)\nlabel_data$angle <- ifelse(label_data$angle < -90, label_data$angle + 180, label_data$angle)\n\n# --- 3. Prepare Data for Baselines (Community Dividers) ---\nbase_data <- plot_data %>%\n  group_by(community) %>%\n  summarize(\n    start = min(id, na.rm = TRUE), # Keep as numeric\n    end = max(id, na.rm = TRUE) - empty_bar_count # Keep as numeric\n  ) %>%\n  rowwise() %>%\n  mutate(\n    title_position = mean(c(start, end))\n  ) %>%\n  ungroup()\n\n# --- 4. Prepare Data for Grid Lines (Optional: Value Scales) ---\nmax_n_value <- max(plot_data$n, na.rm = TRUE)\ngrid_lines_values <- c(20, 40, 60, 80, 100)\ngrid_lines_values <- grid_lines_values[grid_lines_values <= max_n_value]\n\ngrid_segments_data <- plot_data %>%\n  group_by(community) %>%\n  summarize(\n    start_id = min(id, na.rm = TRUE), # Keep as numeric\n    end_id = max(id, na.rm = TRUE) - empty_bar_count # Keep as numeric\n  )\n\ngrid_data_final <- tibble()\nfor(val in grid_lines_values) {\n  temp_data <- grid_segments_data %>%\n    mutate(y_value = val)\n  grid_data_final <- bind_rows(grid_data_final, temp_data)\n}\n\n# --- Data for grid line LABELS ---\ngrid_label_data <- data.frame(\n  x_pos = max(plot_data$id, na.rm = TRUE) + 2, # Fixed x position outside the plot\n  y_pos = grid_lines_values,\n  label_text = as.character(grid_lines_values)\n)\n\n# --- 5. Make the Unified Plot ---\np <- ggplot(plot_data, aes(x = id, y = n, fill = community)) + # <--- x = id (numeric)\n  # Add background grid lines for value (e.g., 20, 40, 60, 80)\n  geom_segment(data = grid_data_final,\n               aes(x = start_id - 0.5, y = y_value, xend = end_id + 0.5, yend = y_value),\n               inherit.aes = FALSE,\n               color = \"grey\", alpha = 0.8, linewidth = 0.3) +\n\n  # Add text showing the value of each grid line at a fixed position\n  geom_text(data = grid_label_data,\n            aes(x = x_pos, y = y_pos, label = label_text),\n            inherit.aes = FALSE,\n            color = \"grey\", size = 3, angle = 0, fontface = \"bold\", hjust = 0) +\n\n  # Bars for the bigrams (main plot elements)\n  geom_bar(stat = \"identity\", alpha = 0.8, color = \"white\", linewidth = 0.1,\n           width = 1.4) + # <--- Add width=1 to remove space between bars if id is numeric\n\n  # Set limits for the y-axis, providing space for labels\n  ylim(-max_n_value * 0.7, max_n_value * 1.2) +\n\n  theme_minimal() +\n  theme(\n    legend.position = \"none\",\n    axis.text = element_blank(),\n    axis.title = element_blank(),\n    panel.grid = element_blank(),\n    plot.margin = unit(c(1.5, 1.5, 1.5, 1.5), \"cm\") # Top, Right, Bottom, Left margins\n  ) +\n  coord_polar(start = 0) +\n\n  # Add bigram labels\n  geom_text(\n    data = label_data,\n    aes(x = id, y = n + 10, label = bigram, hjust = hjust), # <--- x = id (numeric)\n    color = \"black\", fontface = \"bold\", alpha = 0.8, size = 2.8,\n    angle = label_data$angle, inherit.aes = FALSE\n  ) +\n\n  # Add base lines for each community segment\n  geom_segment(\n    data = base_data,\n    aes(x = start - 0.5, y = -10, xend = end + 0.5, yend = -10),\n    colour = \"black\", alpha = 0.8, linewidth = 0.6, inherit.aes = FALSE\n  ) +\n\n  # Add community group labels\n  geom_text(\n    data = base_data,\n    aes(x = title_position, y = -40, label = paste(\"Comm.\", community)),\n    colour = \"black\", alpha = 0.9, size = 2, fontface = \"bold\", inherit.aes = FALSE\n  )+\n  # --- Add the Title ---\n  labs(\n    title = \"Circular Bar Chart by Community\",\n    subtitle = \"Frequencies of key bigrams within each community\", # Updated subtitle\n    caption = paste0(\"AT | Generated: \", Sys.Date())\n  ) +\n  # Apply the Set2 Brewer palette\n  scale_fill_brewer(palette = \"Set2\") +\n  # --- Customize title appearance ---\n  theme(\n    plot.title = element_text(hjust = 0.5, size = 16, face = \"bold\", margin = margin(b = 10)),\n    plot.subtitle = element_text(hjust = 0.5, size = 12, margin = margin(b = 10)),\n    plot.caption = element_text(hjust = 1, size = 7, color = \"grey50\")\n  )\n\nprint(p)\n```\n:::\n\n### 7.5.5 Community Group Membership- All\n\nThe topic area was gathered from the bigram wordclouds and circular bar chart. The Group Name was created based on knowledge from the Members in the group and the topic area. These were the information from the 6 segmented groups:\n\n::: panel-tabset\n## The Table\n\n```{r, echo=FALSE}\nset.seed(1234)\n\n# 6. Create a tidy summary table of members per community\ngrouped_members <- g %>%\n  as_tibble() %>%\n  select(name, community) %>%\n  group_by(community) %>%\n  summarise(\n    Members = paste(sort(name), collapse = \", \"),\n    .groups = \"drop\"\n  ) %>%\n  mutate(\n    `Group Number` = community,\n    `Topic Area` = case_when(\n      community == 1 ~ \"green guardians, city council, paackland harbor, green guardians, nemo reef, water quality\",\n      community == 2 ~ \"nemo reef, miesel shipping, permit, cr 7844, delta 3\",\n      community == 3 ~ \"nemo reef, himark harbor, samantha blake, radio silence\",\n      community == 4 ~ \"money, 0500 meeting, nemo reef, intern reporting, conservation activity, financial projections\",\n      community == 5 ~ \"sam, kelly, loading equipment\",\n      community == 6 ~ \"miranda reporting, jensen, project poseidon, conservation vessels, nemo reef\",\n      TRUE ~ \"Other\"\n    ),\n    `Group Name` = case_when(\n      community == 1 ~ \"Conservationist Group\",\n      community == 2 ~ \"Sailor Shift\",\n      community == 3 ~ \"Maritime\",\n      community == 4 ~ \"Suspicious Characters\",\n      community == 5 ~ \"Sam & Kelly\",\n      community == 6 ~ \"Hacklee Herald\",\n      TRUE ~ \"Miscellaneous\"\n    )\n  ) %>%\n  select(`Group Number`, `Topic Area`, `Members`, `Group Name`)\n\n# Show the summary table in a clean format\nkable(grouped_members, caption = \"Community Group Membership Summary\", align = \"l\")\n```\n\n## The Code\n\n``` r\nset.seed(1234)\n\n# 6. Create a tidy summary table of members per community\ngrouped_members <- g %>%\n  as_tibble() %>%\n  select(name, community) %>%\n  group_by(community) %>%\n  summarise(\n    Members = paste(sort(name), collapse = \", \"),\n    .groups = \"drop\"\n  ) %>%\n  mutate(\n    `Group Number` = community,\n    `Topic Area` = case_when(\n      community == 1 ~ \"green guardians, city council, paackland harbor, green guardians, nemo reef, water quality\",\n      community == 2 ~ \"nemo reef, miesel shipping, permit, cr 7844, delta 3\",\n      community == 3 ~ \"nemo reef, himark harbor, samantha blake, radio silence\",\n      community == 4 ~ \"money, 0500 meeting, nemo reef, intern reporting, conservation activity, financial projections\",\n      community == 5 ~ \"sam, kelly, loading equipment\",\n      community == 6 ~ \"miranda reporting, jensen, project poseidon, conservation vessels, nemo reef\",\n      TRUE ~ \"Other\"\n    ),\n    `Group Name` = case_when(\n      community == 1 ~ \"Conservationist Group\",\n      community == 2 ~ \"Sailor Shift\",\n      community == 3 ~ \"Maritime\",\n      community == 4 ~ \"Suspicious Characters\",\n      community == 5 ~ \"Sam & Kelly\",\n      community == 6 ~ \"Hacklee Herald\",\n      TRUE ~ \"Miscellaneous\"\n    )\n  ) %>%\n  select(`Group Number`, `Topic Area`, `Members`, `Group Name`)\n\n# Show the summary table in a clean format\nkable(grouped_members, caption = \"Community Group Membership Summary\", align = \"l\")\n```\n:::\n\n#### **7.5.5.1 Findings:**\n\n-   We focused on the 11 nodes in the suspicious groups named:\n    -   Sailor Shift (Influential Nodes: Neptune, Remora, Nadia, V. Miesel Shipping, Davis);\n    -   Maritime (Influential Node: Mako);\n    -   Conservationist Group: (Influential Nodes: Reef Guardian, EcoVigil); and\n    -   Suspicious Characters (Influential Nodes: Mrs. Money, Boss, The Middleman).\n-   We held back on the slightly less influential nodes such as: Sam & Kelly, and Hacklee Herald which was where Clepper Jensen worked as a journalist.\n\n### 7.5.6 Interactive Chord Diagram by Community\n\nIn 7.1, we previously created a static chord diagram and heatmap to identify node pairs with higher interactions, and the interactions across entity subtypes.\n\nHere, the interactive chord diagram showed the correspondences among communities at every two hour intervals.\n\n```{r}\n#| code-fold: true\n#| code-summary: \"Show the code\"\n# Get community membership from graph object\ncommunity_df <- g %>%\n  as_tibble() %>%\n  select(name, community)\n```\n\n::: no-code-fold\n```{r, echo=FALSE, message=FALSE, warning=FALSE}\nlibrary(circlize)\nlibrary(dplyr)\nlibrary(tidyr)\nlibrary(RColorBrewer)\nlibrary(stringr)\nlibrary(lubridate)\nlibrary(htmltools) # Essential for building the HTML structure\nlibrary(jsonlite) # For passing R data to JavaScript safely\n\n# --- 1. Data Preprocessing and Setup ---\n\n# Bin by 2-hour interval\nother_communications_df <- other_communications_df %>%\n  mutate(timestamp = as.POSIXct(timestamp)) %>% # Ensure timestamp is POSIXct\n  mutate(timestamp_2hr = floor_date(timestamp, unit = \"2 hours\"))\n\n# Get all unique 2-hour time bins for the slider\nall_times <- sort(unique(other_communications_df$timestamp_2hr))\n\n# Define output directory for image frames\noutput_dir <- \"chord_frames\"\ndir.create(output_dir, showWarnings = FALSE) # Create the directory if it doesn't exist\n\n# Community name mapping (ensure this matches  'community_df' structure)\ncommunity_name_map <- c(\n  \"1\" = \"Conservationist Group\",\n  \"2\" = \"Sailor Shift\",\n  \"3\" = \"Maritime\",\n  \"4\" = \"Suspicious Characters\",\n  \"5\" = \"Sam & Kelly\",\n  \"6\" = \"Hacklee Herald\"\n)\n\n\n# Assuming community_df has a 'community' column that's numeric/factor\nif (exists(\"community_df\") && \"community\" %in% names(community_df)) {\n  num_unique_communities <- length(unique(community_df$community))\n  base_colors <- brewer.pal(max(3, num_unique_communities), \"Set2\") # Use Set2 for pastel\n  community_colors <- setNames(\n    base_colors[1:num_unique_communities], # Slice to exactly the number needed\n    as.character(sort(unique(community_df$community)))\n  )\n} else {\n  # Fallback if community_df is not defined or missing 'community' column\n  message(\"Warning: 'community_df' or 'community' column not found. Using default colors.\")\n  community_colors <- c(\n    \"1\" = \"#66C2A5\", \"2\" = \"#FC8D62\", \"3\" = \"#8DA0CB\", \"4\" = \"#E78AC3\",\n    \"5\" = \"#A6D854\", \"6\" = \"#FFD92F\", \"7\" = \"#E5C494\", \"8\" = \"#B3B3B3\"\n  )\n}\n\n\n# --- 2. Generate and Save Chord Diagrams as PNGs ---\n\n# Loop through each time bin, create a plot, and save it\nfor (i in seq_along(all_times)) {\n  selected_time <- all_times[i]\n  end_time <- selected_time + hours(2)\n\n  filtered_df <- other_communications_df %>%\n    filter(timestamp_2hr == selected_time)\n\n  # Prepare data for the chord diagram matrix\n  sent_df <- filtered_df %>%\n    filter(communication_type == \"sent\") %>%\n    count(sender_name, recipient_name, name = \"sent\")\n\n  received_df <- filtered_df %>%\n    filter(communication_type == \"received\") %>%\n    count(sender_name = recipient_name, recipient_name = sender_name, name = \"received\")\n\n  combined_df <- full_join(sent_df, received_df, by = c(\"sender_name\", \"recipient_name\")) %>%\n    mutate(across(c(sent, received), ~replace_na(., 0)),\n           total = sent + received)\n\n  # Skip this iteration if no data for the current time slice\n  if (nrow(combined_df) == 0 || sum(combined_df$total) == 0) {\n    message(paste(\"No communications for time:\", selected_time, \". Skipping frame.\"))\n\n    next\n  }\n\n  comm_matrix <- xtabs(total ~ sender_name + recipient_name, data = combined_df)\n\n  # Ensure sector_names from comm_matrix exist in community_df for color mapping\n  sector_names <- union(rownames(comm_matrix), colnames(comm_matrix))\n  \n  # Filter community_df to only relevant sectors and ensure distinct entries\n  sector_community_df <- community_df %>%\n    filter(name %in% sector_names) %>%\n    distinct(name, .keep_all = TRUE) %>%\n    arrange(match(name, sector_names))\n\n  # Map community colors to sector names based on 'community' column\n  grid_colors_current_frame <- setNames(\n    community_colors[as.character(sector_community_df$community)],\n    sector_community_df$name\n  )\n  # Ensure only colors for actual sectors in the matrix are used\n  grid_colors_current_frame <- grid_colors_current_frame[names(grid_colors_current_frame) %in% sector_names]\n\n\n  # Open PNG device for saving the plot\n  png(sprintf(\"%s/frame_%03d.png\", output_dir, i), width = 800, height = 800)\n  \n  # Clear existing circlize plot before drawing new one\n  circos.clear()\n  par(mar = c(6, 2, 10, 6)) # Adjust margins as needed for title and labels\n\n  # Draw the chord diagram\n  chordDiagram(\n    comm_matrix,\n    grid.col = grid_colors_current_frame,\n    transparency = 0.25,\n    annotationTrack = \"grid\",\n    preAllocateTracks = list(track.height = 0.1)\n  )\n\n  # Add labels to the sectors\n  circos.trackPlotRegion(\n    track.index = 1,\n    panel.fun = function(x, y) {\n      name <- get.cell.meta.data(\"sector.index\")\n      wrapped_name <- str_wrap(name, width = 12)\n      circos.text(\n        x = mean(get.cell.meta.data(\"xlim\")),\n        y = 0,\n        labels = wrapped_name,\n        facing = \"clockwise\",\n        niceFacing = TRUE,\n        adj = c(0, 0.5),\n        cex = 0.8\n      )\n    },\n    bg.border = NA\n  )\n\n  # Add a main title to the plot\n  title(\n    main = paste(\"Communication Flows\\n\", format(selected_time, \"%d %b %Y (%H:%M\"), \"to\", format(end_time, \"%H:%M)\")),\n    cex.main = 1.2,\n    font.main = 1,\n    line = 6\n  )\n  dev.off() # CRITICAL: Close the PNG device to save the file\n}\n\n# --- 3. Build the HTML Viewer with Embedded Images and JavaScript ---\n\n# Generate HTML <img> tags for each saved frame\n# Filter out any frames that might have been skipped if 'next' was used\n# Check which frame files actually exist\nexisting_frames <- list.files(output_dir, pattern = \"^frame_\\\\d{3}\\\\.png$\", full.names = TRUE)\n# Extract the numeric index from the filename to match with all_times\nframe_indices <- as.numeric(gsub(\"frame_(\\\\d{3})\\\\.png\", \"\\\\1\", basename(existing_frames)))\n\n# Only create image tags for the frames that were successfully generated\nimage_tags <- lapply(seq_along(existing_frames), function(idx) {\n  # The original 'i' (loop index) corresponds to the 'frame_indices'\n  original_time_idx <- frame_indices[idx]\n  tags$img(src = existing_frames[idx], # Use the full path here\n           style = if (idx == 1) \"display:block;\" else \"display:none;\", # Show first frame by default\n           class = \"chord-frame\",\n           alt = paste(\"Chord diagram for time slice\", format(all_times[original_time_idx], \"%d %b %Y %H:%M\")))\n})\n\n\n# JavaScript function to update which image frame is visible\n# We need to map the slider value (0 to num_frames-1) to the correct time index\n# because some frames might be skipped, causing gaps in numerical sequence.\njs_script <- HTML(sprintf(\"\n<script>\n  // Ensure the allTimes array correctly maps to the generated frames\n  const originalAllTimes = %s; // This is the full list of all_times\n  const generatedFrameIndices = %s; // This indicates which original_time_idx corresponds to a generated frame\n\n  function updateFrame(sliderIndex) {\n    const frames = document.querySelectorAll('.chord-frame');\n    frames.forEach((el, i) => {\n      // frames[i] corresponds to existing_frames[i] from R\n      // sliderIndex is 0-based for the slider\n      el.style.display = (i === sliderIndex) ? 'block' : 'none';\n    });\n\n    // Update the time display text based on the current frame's original time\n    const timeDisplay = document.getElementById('current-time-display');\n    if (timeDisplay && sliderIndex < generatedFrameIndices.length) {\n        // Get the original time index for the currently displayed frame\n        const actualTimeIndex = generatedFrameIndices[sliderIndex] - 1; // Convert 1-based to 0-based for originalAllTimes\n        \n        if (actualTimeIndex >= 0 && actualTimeIndex < originalAllTimes.length) {\n            const selectedTime = new Date(originalAllTimes[actualTimeIndex]);\n            const endTime = new Date(selectedTime.getTime() + 2 * 60 * 60 * 1000); // Add 2 hours in milliseconds\n\n            // Format dates and times for display\n            const formatDate = (date) => date.toLocaleDateString('en-US', { day: '2-digit', month: 'short', year: 'numeric' });\n            const formatTime = (date) => date.toLocaleTimeString('en-US', { hour: '2-digit', minute: '2-digit', hour12: false });\n            \n            timeDisplay.innerHTML = `Day: ${formatDate(selectedTime)} | Time: ${formatTime(selectedTime)} to ${formatTime(endTime)}`;\n        } else {\n            timeDisplay.innerHTML = 'No data for this time slice.';\n        }\n    }\n  }\n\n  // Initialize the display on page load\n  document.addEventListener('DOMContentLoaded', () => {\n    const slider = document.getElementById('frameSlider');\n    if (slider) {\n        updateFrame(parseInt(slider.value)); // Set initial frame based on slider's default value\n    }\n  });\n</script>\n\", jsonlite::toJSON(as.character(all_times)), jsonlite::toJSON(frame_indices))) # Pass all_times and frame_indices to JS\n\n\n# --- 4. Display the HTML content directly in the Quarto document ---\n# This is the key line to make Quarto embed the interactive viewer.\nbrowsable(\n  tagList(\n    js_script, # The JavaScript for interactivity\n    tags$head(\n      tags$style(HTML(\"\n        /* Basic styling for the image frames and slider container */\n        .chord-frame { width: 100%; max-width: 800px; height: auto; margin: auto; display: block; }\n        #slider-container { text-align: center; margin: 20px auto; max-width: 800px; }\n        .chord-title { text-align: center; font-size: 1.5em; margin-bottom: 15px; font-weight: bold; }\n        #frameSlider { width: 80%; max-width: 700px; margin: 10px auto; display: block; }\n        #current-time-display { font-weight: bold; margin-top: 10px; }\n      \"))\n    ), # Close tags$head\n\n    tags$body( \n      tags$div(class = \"chord-title\", \"Interactive Communication Flows Over Time\"),\n      tags$div(id = \"slider-container\",\n          tags$input(type = \"range\", min = \"0\", max = length(existing_frames) - 1, value = 0,\n                     id = \"frameSlider\", oninput = \"updateFrame(parseInt(this.value))\"),\n          tags$p(id = \"current-time-display\", style = \"font-weight:bold; margin-top: 10px;\"),\n          tags$p(\"Use the slider to view communication over time\")\n      ),\n      tags$div(id = \"chord-images-container\", image_tags) # Container for all image frames\n    )\n  )\n)\n```\n:::\n\n#### 7.5.6.1 Findings:\n\nWe noticed some cross community direct and indirect communication occured mainly among influential nodes, suggesting collaboration. These are **some** sample linkages with arrows regardless of sent or received:\n\n+-----------------------+-------------------------------------------------------------+\n| Community X           | Node Linkages (Community X -\\> Community X -\\> Community Y) |\n+=======================+=============================================================+\n| Suspicious Characters | Mrs. Money -\\> Intern -\\> The Lookout                       |\n|                       |                                                             |\n|                       | Liam -\\> Paackland Harbor -\\> The Middleman                 |\n|                       |                                                             |\n|                       | Glitters Team -\\> Boss -\\> Mako                             |\n|                       |                                                             |\n|                       | Glitters Team -\\> Samantha Blake -\\> Sailor Shifts Team     |\n+-----------------------+-------------------------------------------------------------+\n| Sailor Shift          | Neptune -\\> Elise -\\> Mako                                  |\n|                       |                                                             |\n|                       | Neptune -\\> Davis -\\> Mako                                  |\n|                       |                                                             |\n|                       | Remora -\\> Neptune -\\> Boss                                 |\n|                       |                                                             |\n|                       | Rodriguez -\\> Remora -\\> Mako                               |\n|                       |                                                             |\n|                       | Remora -\\> Small Fry -\\> Mako                               |\n|                       |                                                             |\n|                       | Davis -\\> Remora -\\> Paackland Harbor                       |\n|                       |                                                             |\n|                       | V. Miesel Shipping -\\> Neptune -\\> Mako                     |\n+-----------------------+-------------------------------------------------------------+\n| Sam & Kelly           | Kelly -\\> Sam - \\> The Lookout                              |\n+-----------------------+-------------------------------------------------------------+\n| Maritime              | Mako -\\> Himark Harbor -\\> Oceanus City Council             |\n+-----------------------+-------------------------------------------------------------+\n| Hacklee Herald        | N/A (Only Direct Community X to X communications)           |\n+-----------------------+-------------------------------------------------------------+\n| Conservationist Group | Reef Guardian -\\> Oceanus City Council -\\> Nadia            |\n|                       |                                                             |\n|                       | Reef Guardian -\\> Paackland Harbor -\\> Mako                 |\n|                       |                                                             |\n|                       | Oceanus City Council -\\> Liam -\\> Nadia                     |\n+-----------------------+-------------------------------------------------------------+\n\nWe also noticed that at times, certain individuals sent messages but there were no response back. This could possibly be due to the pseudonyms being used to send or reply to the same content. For instance, there was a message from Davis to Rodriguez on 14 Oct around 1200-1400 but there was no response by Rodriguez. By looking at the content field, we then found out that he was Small Fry due to the responses he provided to Davis which was originally addressed to Rodriguez.\n\n### 7.5.7 Community Detection- People & Vessels\n\nSince our nodes (apart from V. Miesel Shipping) were mostly of people and vessels, in order for us to drill even deeper into people and vessels, we recreated the process for only people and vessels.\n\n::: panel-tabset\n## Community Detection\n\n```{r,echo=FALSE}\nset.seed(1234)\n\n# --- STEP 1: Prepare the edge list ---\nedge_df_pv <- person_vessel_df %>%\n  select(sender_id, recipient_id) %>%\n  filter(!is.na(sender_id) & !is.na(recipient_id)) %>%\n  rename(from = sender_id, to = recipient_id) %>%\n  distinct()\n\n# Optional: remove self-loops\nedge_df_pv <- edge_df_pv %>% filter(from != to)\n\n# --- STEP 2: Create the graph object (undirected) ---\ng_pv <- tbl_graph(edges = edge_df_pv, directed = FALSE)\n\n# --- STEP 3: Run Louvain community detection ---\ng_pv <- g_pv %>%\n  mutate(community = group_louvain())\n\n# --- STEP 4: Visualize the graph ---\nggraph(g_pv, layout = \"fr\") +\n  geom_edge_link(alpha = 0.3) +\n  geom_node_point(aes(color = as.factor(community)), size = 5) +\n  geom_node_text(aes(label = name), repel = TRUE, size = 3) +\n  theme_void() +\n  labs(title = \"Community Detection in Communication Network\",\n       color = \"Community\")\n```\n\n## The Code\n\n``` r\nset.seed(1234)\n\n# --- STEP 1: Prepare the edge list ---\nedge_df_pv <- person_vessel_df %>%\n  select(sender_id, recipient_id) %>%\n  filter(!is.na(sender_id) & !is.na(recipient_id)) %>%\n  rename(from = sender_id, to = recipient_id) %>%\n  distinct()\n\n# Optional: remove self-loops\nedge_df_pv <- edge_df_pv %>% filter(from != to)\n\n# --- STEP 2: Create the graph object (undirected) ---\ng_pv <- tbl_graph(edges = edge_df_pv, directed = FALSE)\n\n# --- STEP 3: Run Louvain community detection ---\ng_pv <- g_pv %>%\n  mutate(community = group_louvain())\n\n# --- STEP 4: Visualize the graph ---\nggraph(g_pv, layout = \"fr\") +\n  geom_edge_link(alpha = 0.3) +\n  geom_node_point(aes(color = as.factor(community)), size = 5) +\n  geom_node_text(aes(label = name), repel = TRUE, size = 3) +\n  theme_void() +\n  labs(title = \"Community Detection in Communication Network\",\n       color = \"Community\")\n```\n:::\n\n### 7.5.8 Centrality Measure- People & Vessels\n\n::: panel-tabset\n## PageRank Centrality Algorithm\n\n```{r, echo=FALSE}\n# --- Compute Centrality Measures ---\nset.seed(1234)\ng_pv <- g_pv %>%\n  mutate(\n    pagerank = centrality_pagerank(),\n    degree = centrality_degree(),\n    betweenness = centrality_betweenness(),\n    closeness = centrality_closeness()\n  )\n\n# Show top 10 nodes by PageRank\ng_pv %>%\n  as_tibble() %>%\n  select(name, pagerank, degree, betweenness, closeness) %>%\n  arrange(desc(pagerank)) %>%\n  head(10)\n```\n\n## The Network\n\n```{r, echo=FALSE}\nset.seed(1234)\n\n# Visualize by Centrality\nggraph(g_pv, layout = \"fr\") +\n  geom_edge_link(alpha = 0.3) +\n  geom_node_point(aes(size = pagerank, color = as.factor(community)), alpha = 0.8) +\n  geom_node_text(aes(label = name), repel = TRUE, size = 3) +\n  theme_void() +\n  labs(title = \"Network with PageRank Centrality\",\n       size = \"PageRank\", color = \"Community\")\n```\n\n## The Code\n\n``` r\nset.seed(1234)\n\n# --- STEP: Compute Centrality Measures ---\ng_pv <- g_pv %>%\n  mutate(\n    pagerank = centrality_pagerank(),\n    degree = centrality_degree(),\n    betweenness = centrality_betweenness(),\n    closeness = centrality_closeness()\n  )\n\n# Show top 10 nodes by PageRank\ng_pv %>%\n  as_tibble() %>%\n  select(name, pagerank, degree, betweenness, closeness) %>%\n  arrange(desc(pagerank)) %>%\n  head(10)\n\n# Visualize by Centrality\nggraph(g_pv, layout = \"fr\") +\n  geom_edge_link(alpha = 0.3) +\n  geom_node_point(aes(size = pagerank, color = as.factor(community)), alpha = 0.8) +\n  geom_node_text(aes(label = name), repel = TRUE, size = 3) +\n  theme_void() +\n  labs(title = \"Network with PageRank Centrality\",\n       size = \"PageRank\", color = \"Community\")\n```\n:::\n\n#### **7.5.8.1 Findings:**\n\n-   There were 5 closely associated groups. Community 5 (Clepper and Miranda) appeared to be segmented from the central group, due to the non-involvement from the nature of their investigative work.\n-   From the graph, we extracted the 8 influential nodes to focus on:\n    -   Community 1: Mako\n    -   Community 2: Neptune, Remora, Nadia, Davis\n    -   Community 3: N/A as they were not very influential at global level\n    -   Community 4: Mrs. Money, Boss, The Middleman\n    -   Community 5: N/A as they were not very influential at global level\n\n### 7.5.9 Wordclouds- Bigrams\n\nWe focused on bigrams here to get more contextual data from two instead of one word.\n\n::: panel-tabset\n## The Wordclouds\n\n```{r, echo=FALSE}\n# 5b. Plot word clouds per community\nvalid_communities <- unique(g_pv %>% as_tibble() %>% pull(community))\n\npar(mfrow = c(2, 3))  # Still allocate 6 slots, but you can adjust this\nfor (i in sort(valid_communities)) {\n  words <- bigrams %>% filter(community == i)\n  \n  if (nrow(words) < 1) next\n  \n  suppressWarnings({\n    set.seed(432)  # Set seed for reproducibility\n    wordcloud(words = words$bigram,  # <-- FIXED here\n              freq = words$n,\n              max.words = min(30, nrow(words)),\n              scale = c(3, 0.5),\n              colors = brewer.pal(8, \"Dark2\"),\n              random.order = FALSE)\n  })\n  mtext(paste(\"Community\", i), side = 3, line = 1, adj = 0.5, cex = 1.5, col = \"black\")\n}\n```\n\n## The Code\n\n``` r\n# 5b. Plot word clouds per community\nvalid_communities <- unique(g_pv %>% as_tibble() %>% pull(community))\n\npar(mfrow = c(2, 3))  # Still allocate 6 slots, but you can adjust this\nfor (i in sort(valid_communities)) {\n  words <- bigrams %>% filter(community == i)\n  \n  if (nrow(words) < 1) next\n  \n  suppressWarnings({\n    set.seed(432)  # Set seed for reproducibility\n    wordcloud(words = words$bigram,  # <-- FIXED here\n              freq = words$n,\n              max.words = min(30, nrow(words)),\n              scale = c(3, 0.5),\n              colors = brewer.pal(8, \"Dark2\"),\n              random.order = FALSE)\n  })\n  mtext(paste(\"Community\", i), side = 3, line = 1, adj = 0.5, cex = 1.5, col = \"black\")\n}\n```\n:::\n\n### 7.5.10 Circular barchart for Top Bigrams per Community\n\n::: panel-tabset\n## The Circular Barchart\n\n```{r, echo=FALSE, message=FALSE, warning=FALSE, `fig-width`=8, `fig-height`=8}\nset.seed(1234)\n\nvalid_communities <- g_pv %>%\n  as_tibble() %>%\n  distinct(community) %>%\n  pull(community)\n\nbigrams <- bigrams %>% filter(community %in% valid_communities)\n\n# --- Configuration ---\nnum_top_bigrams_per_community <- 8\nempty_bar_count <- 2 # gaps btw comm.\n#excluded_community <- 5 # too little in community 5\n\n# --- 1. Prepare the Combined Dataset ---\nall_communities_data <- bigrams %>%\n#  filter(community != excluded_community) %>%\n  group_by(community) %>%\n  arrange(desc(n)) %>%\n  slice_head(n = num_top_bigrams_per_community) %>%\n  ungroup()\n\nall_communities_data$community <- as.factor(all_communities_data$community)\n\nto_add <- data.frame(\n  bigram = NA,\n  n = NA,\n  community = rep(levels(all_communities_data$community), each = empty_bar_count)\n)\n\nplot_data <- rbind(all_communities_data, to_add) %>%\n  arrange(community)\n\nplot_data$id <- seq_len(nrow(plot_data)) # Keep ID as numeric here\n\n# --- 2. Prepare Label Data ---\nlabel_data <- plot_data\nnumber_of_bar <- nrow(label_data)\nlabel_data$angle <- 90 - 360 * (label_data$id - 0.5) / number_of_bar\nlabel_data$hjust <- ifelse(label_data$angle < -90, 1, 0)\nlabel_data$angle <- ifelse(label_data$angle < -90, label_data$angle + 180, label_data$angle)\n\n# --- 3. Prepare Data for Baselines (Community Dividers) ---\nbase_data <- plot_data %>%\n  group_by(community) %>%\n  summarize(\n    start = min(id, na.rm = TRUE), # Keep as numeric\n    end = max(id, na.rm = TRUE) - empty_bar_count # Keep as numeric\n  ) %>%\n  rowwise() %>%\n  mutate(\n    title_position = mean(c(start, end))\n  ) %>%\n  ungroup()\n\n# --- 4. Prepare Data for Grid Lines (Optional: Value Scales) ---\nmax_n_value <- max(plot_data$n, na.rm = TRUE)\ngrid_lines_values <- c(20, 40, 60, 80, 100)\ngrid_lines_values <- grid_lines_values[grid_lines_values <= max_n_value]\n\ngrid_segments_data <- plot_data %>%\n  group_by(community) %>%\n  summarize(\n    start_id = min(id, na.rm = TRUE), # Keep as numeric\n    end_id = max(id, na.rm = TRUE) - empty_bar_count # Keep as numeric\n  )\n\ngrid_data_final <- tibble()\nfor(val in grid_lines_values) {\n  temp_data <- grid_segments_data %>%\n    mutate(y_value = val)\n  grid_data_final <- bind_rows(grid_data_final, temp_data)\n}\n\n# --- Data for grid line LABELS ---\ngrid_label_data <- data.frame(\n  x_pos = max(plot_data$id, na.rm = TRUE) + 2, # Fixed x position outside the plot\n  y_pos = grid_lines_values,\n  label_text = as.character(grid_lines_values)\n)\n\n# --- 5. Make the Unified Plot ---\np <- ggplot(plot_data, aes(x = id, y = n, fill = community)) + # <--- x = id (numeric)\n  # Add background grid lines for value (e.g., 20, 40, 60, 80)\n  geom_segment(data = grid_data_final,\n               aes(x = start_id - 0.5, y = y_value, xend = end_id + 0.5, yend = y_value),\n               inherit.aes = FALSE,\n               color = \"grey\", alpha = 0.8, linewidth = 0.3) +\n\n  # Add text showing the value of each grid line at a fixed position\n  geom_text(data = grid_label_data,\n            aes(x = x_pos, y = y_pos, label = label_text),\n            inherit.aes = FALSE,\n            color = \"grey\", size = 3, angle = 0, fontface = \"bold\", hjust = 0) +\n\n  # Bars for the bigrams (main plot elements)\n  geom_bar(stat = \"identity\", alpha = 0.8, color = \"white\", linewidth = 0.1,\n           width = 1) + # <--- Add width=1 to remove space between bars if id is numeric\n\n  # Set limits for the y-axis, providing space for labels\n  ylim(-max_n_value * 0.7, max_n_value * 1.2) +\n\n  theme_minimal() +\n  theme(\n    legend.position = \"none\",\n    axis.text = element_blank(),\n    axis.title = element_blank(),\n    panel.grid = element_blank(),\n    plot.margin = unit(c(1.5, 1.5, 1.5, 1.5), \"cm\") # Top, Right, Bottom, Left margins\n  ) +\n  coord_polar(start = 0) +\n\n  # Add bigram labels\n  geom_text(\n    data = label_data,\n    aes(x = id, y = n + 10, label = bigram, hjust = hjust), # <--- x = id (numeric)\n    color = \"black\", fontface = \"bold\", alpha = 0.8, size = 2.8,\n    angle = label_data$angle, inherit.aes = FALSE\n  ) +\n\n  # Add base lines for each community segment\n  geom_segment(\n    data = base_data,\n    aes(x = start - 0.5, y = -10, xend = end + 0.5, yend = -10),\n    colour = \"black\", alpha = 0.8, linewidth = 0.6, inherit.aes = FALSE\n  ) +\n\n  # Add community group labels\n  geom_text(\n    data = base_data,\n    aes(x = title_position, y = -40, label = paste(\"Comm.\", community)),\n    colour = \"black\", alpha = 0.9, size = 2, fontface = \"bold\", inherit.aes = FALSE\n  )+\n  # --- Add the Title ---\n  labs(\n    title = \"Circular Bar Chart by Community\",\n    subtitle = \"Frequencies of key bigrams within each community\", # Updated subtitle\n    caption = paste0(\"AT | Generated: \", Sys.Date())\n  ) +\n  # Apply the Set2 Brewer palette\n  scale_fill_brewer(palette = \"Set2\") +\n  # --- Customize title appearance ---\n  theme(\n    plot.title = element_text(hjust = 0.5, size = 16, face = \"bold\", margin = margin(b = 10)),\n    plot.subtitle = element_text(hjust = 0.5, size = 12, margin = margin(b = 10)),\n    plot.caption = element_text(hjust = 1, size = 7, color = \"grey50\")\n  )\n\nprint(p)\n```\n\n## The Code\n\n``` r\nset.seed(1234)\n\nset.seed(1234)\n\nvalid_communities <- g_pv %>%\n  as_tibble() %>%\n  distinct(community) %>%\n  pull(community)\n\nbigrams <- bigrams %>% filter(community %in% valid_communities)\n\n# --- Configuration ---\nnum_top_bigrams_per_community <- 8\nempty_bar_count <- 2 # gaps btw comm.\n#excluded_community <- 5 # too little in community 5\n\n# --- 1. Prepare the Combined Dataset ---\nall_communities_data <- bigrams %>%\n#  filter(community != excluded_community) %>%\n  group_by(community) %>%\n  arrange(desc(n)) %>%\n  slice_head(n = num_top_bigrams_per_community) %>%\n  ungroup()\n\nall_communities_data$community <- as.factor(all_communities_data$community)\n\nto_add <- data.frame(\n  bigram = NA,\n  n = NA,\n  community = rep(levels(all_communities_data$community), each = empty_bar_count)\n)\n\nplot_data <- rbind(all_communities_data, to_add) %>%\n  arrange(community)\n\nplot_data$id <- seq_len(nrow(plot_data)) # Keep ID as numeric here\n\n# --- 2. Prepare Label Data ---\nlabel_data <- plot_data\nnumber_of_bar <- nrow(label_data)\nlabel_data$angle <- 90 - 360 * (label_data$id - 0.5) / number_of_bar\nlabel_data$hjust <- ifelse(label_data$angle < -90, 1, 0)\nlabel_data$angle <- ifelse(label_data$angle < -90, label_data$angle + 180, label_data$angle)\n\n# --- 3. Prepare Data for Baselines (Community Dividers) ---\nbase_data <- plot_data %>%\n  group_by(community) %>%\n  summarize(\n    start = min(id, na.rm = TRUE), # Keep as numeric\n    end = max(id, na.rm = TRUE) - empty_bar_count # Keep as numeric\n  ) %>%\n  rowwise() %>%\n  mutate(\n    title_position = mean(c(start, end))\n  ) %>%\n  ungroup()\n\n# --- 4. Prepare Data for Grid Lines (Optional: Value Scales) ---\nmax_n_value <- max(plot_data$n, na.rm = TRUE)\ngrid_lines_values <- c(20, 40, 60, 80, 100)\ngrid_lines_values <- grid_lines_values[grid_lines_values <= max_n_value]\n\ngrid_segments_data <- plot_data %>%\n  group_by(community) %>%\n  summarize(\n    start_id = min(id, na.rm = TRUE), # Keep as numeric\n    end_id = max(id, na.rm = TRUE) - empty_bar_count # Keep as numeric\n  )\n\ngrid_data_final <- tibble()\nfor(val in grid_lines_values) {\n  temp_data <- grid_segments_data %>%\n    mutate(y_value = val)\n  grid_data_final <- bind_rows(grid_data_final, temp_data)\n}\n\n# --- Data for grid line LABELS ---\ngrid_label_data <- data.frame(\n  x_pos = max(plot_data$id, na.rm = TRUE) + 2, # Fixed x position outside the plot\n  y_pos = grid_lines_values,\n  label_text = as.character(grid_lines_values)\n)\n\n# --- 5. Make the Unified Plot ---\np <- ggplot(plot_data, aes(x = id, y = n, fill = community)) + # <--- x = id (numeric)\n  # Add background grid lines for value (e.g., 20, 40, 60, 80)\n  geom_segment(data = grid_data_final,\n               aes(x = start_id - 0.5, y = y_value, xend = end_id + 0.5, yend = y_value),\n               inherit.aes = FALSE,\n               color = \"grey\", alpha = 0.8, linewidth = 0.3) +\n\n  # Add text showing the value of each grid line at a fixed position\n  geom_text(data = grid_label_data,\n            aes(x = x_pos, y = y_pos, label = label_text),\n            inherit.aes = FALSE,\n            color = \"grey\", size = 3, angle = 0, fontface = \"bold\", hjust = 0) +\n\n  # Bars for the bigrams (main plot elements)\n  geom_bar(stat = \"identity\", alpha = 0.8, color = \"white\", linewidth = 0.1,\n           width = 1) + # <--- Add width=1 to remove space between bars if id is numeric\n\n  # Set limits for the y-axis, providing space for labels\n  ylim(-max_n_value * 0.7, max_n_value * 1.2) +\n\n  theme_minimal() +\n  theme(\n    legend.position = \"none\",\n    axis.text = element_blank(),\n    axis.title = element_blank(),\n    panel.grid = element_blank(),\n    plot.margin = unit(c(1.5, 1.5, 1.5, 1.5), \"cm\") # Top, Right, Bottom, Left margins\n  ) +\n  coord_polar(start = 0) +\n\n  # Add bigram labels\n  geom_text(\n    data = label_data,\n    aes(x = id, y = n + 10, label = bigram, hjust = hjust), # <--- x = id (numeric)\n    color = \"black\", fontface = \"bold\", alpha = 0.8, size = 2.8,\n    angle = label_data$angle, inherit.aes = FALSE\n  ) +\n\n  # Add base lines for each community segment\n  geom_segment(\n    data = base_data,\n    aes(x = start - 0.5, y = -10, xend = end + 0.5, yend = -10),\n    colour = \"black\", alpha = 0.8, linewidth = 0.6, inherit.aes = FALSE\n  ) +\n\n  # Add community group labels\n  geom_text(\n    data = base_data,\n    aes(x = title_position, y = -40, label = paste(\"Comm.\", community)),\n    colour = \"black\", alpha = 0.9, size = 2, fontface = \"bold\", inherit.aes = FALSE\n  )+\n  # --- Add the Title ---\n  labs(\n    title = \"Circular Bar Chart by Community\",\n    subtitle = \"Frequencies of key bigrams within each community\", # Updated subtitle\n    caption = paste0(\"AT | Generated: \", Sys.Date())\n  ) +\n  # Apply the Set2 Brewer palette\n  scale_fill_brewer(palette = \"Set2\") +\n  # --- Customize title appearance ---\n  theme(\n    plot.title = element_text(hjust = 0.5, size = 16, face = \"bold\", margin = margin(b = 10)),\n    plot.subtitle = element_text(hjust = 0.5, size = 12, margin = margin(b = 10)),\n    plot.caption = element_text(hjust = 1, size = 7, color = \"grey50\")\n  )\n\nprint(p)\n```\n:::\n\n### 7.5.11 Community Group Membership- People & Vessels\n\nThe topic area was gathered from the bigram wordclouds and circular bar chart. The Group Name was created based on knowledge from the Members in the group and the topic area. These are the information for the 5 segmented groups:\n\n::: panel-tabset\n## The Table\n\n```{r, echo=FALSE}\nset.seed(1234)\n# 6. Create a tidy summary table of members per community\ngrouped_members <- g_pv %>%\n  as_tibble() %>%\n  select(name, community) %>%\n  group_by(community) %>%\n  summarise(\n    Members = paste(sort(name), collapse = \", \"),\n    .groups = \"drop\"\n  ) %>%\n  mutate(\n    `Group Number` = community,\n    `Topic Area` = case_when(\n      community == 1 ~ \"nemo reef, himark harbor, samantha blake, city council\",\n      community == 2 ~ \"south dock, equipment transfer, security team, nemo reef, delta3, cr 7844\",\n      community == 3 ~ \"intern reporting, conservation vessels, nemo reef\",\n      community == 4 ~ \"10am tomorrow, 0500 tomorrow, funding channels, alternative funding\",\n      community == 5 ~ \"classification markings, project poseidon, clearance documents, harbor security\",\n      TRUE ~ \"Other\"\n    ),\n    `Group Name` = case_when(\n      community == 1 ~ \"Conservationist Group\",\n      community == 2 ~ \"Permit\",\n      community == 3 ~ \"Pseudonym\",\n      community == 4 ~ \"Suspicious\",\n      community == 5 ~ \"Hacklee Herald\",\n      TRUE ~ \"Miscellaneous\"\n    )\n  ) %>%\n  select(`Group Number`, `Topic Area`, `Members`, `Group Name`)\n\n# Show the summary table in a clean format\nkable(grouped_members, caption = \"Community Group Membership Summary\", align = \"l\")\n```\n\n## The Code\n\n``` r\nset.seed(1234)\n# 6. Create a tidy summary table of members per community\ngrouped_members <- g_pv %>%\n  as_tibble() %>%\n  select(name, community) %>%\n  group_by(community) %>%\n  summarise(\n    Members = paste(sort(name), collapse = \", \"),\n    .groups = \"drop\"\n  ) %>%\n  mutate(\n    `Group Number` = community,\n    `Topic Area` = case_when(\n      community == 1 ~ \"nemo reef, himark harbor, samantha blake, city council\",\n      community == 2 ~ \"south dock, equipment transfer, security team, nemo reef, delta3, cr 7844\",\n      community == 3 ~ \"intern reporting, conservation vessels, nemo reef\",\n      community == 4 ~ \"10am tomorrow, 0500 tomorrow, funding channels, alternative funding\",\n      community == 5 ~ \"classification markings, project poseidon, clearance documents, harbor security\",\n      TRUE ~ \"Other\"\n    ),\n    `Group Name` = case_when(\n      community == 1 ~ \"Conservationist Group\",\n      community == 2 ~ \"Permit\",\n      community == 3 ~ \"Pseudonym\",\n      community == 4 ~ \"Suspicious\",\n      community == 5 ~ \"Hacklee Herald\",\n      TRUE ~ \"Miscellaneous\"\n    )\n  ) %>%\n  select(`Group Number`, `Topic Area`, `Members`, `Group Name`)\n\n# Show the summary table in a clean format\nkable(grouped_members, caption = \"Community Group Membership Summary\", align = \"l\")\n```\n:::\n\n#### **7.5.11.1 Findings:**\n\n-   Movements and changes in membership since section 7.5.6:\n    -   Mako moved from Maritime to Conservationist.\n    -   Samantha Blake moved from the Suspicious Characters to Conservationist.\n    -   Sam and Kelly moved from their own Community to Pseudonym.\n    -   The Lookout moved from Conservationist Group to Pseudonym.\n    -   The Intern moved from Suspicious Characters to Pseudonym.\n    -   Sailor Shift community renamed to Permit\n-   From 11 nodes in section 7.5.6.1, we further narrowed down on the 8 nodes in the suspicious groups named:\n    -   Permit (Influential Nodes: Neptune, Remora, Nadia, Davis);\n    -   Conservationist Group (Influential Node: Mako);\n    -   Suspicious (Influential Nodes: Mrs. Money, Boss, The Middleman).\n-   We held back on the slightly less influential nodes such as: Hacklee Herald which was where Clepper Jensen worked as a journalist.\n\n### 7.5.12 Plotted Community Timeline- People & Vessels\n\nWe then decided to plot the timeline based on community colours to uncover patterns.\n\n```{r}\n#| code-fold: true\n#| code-summary: \"Show the code\"\n# --- FACTORING and DATETIME CLEANING ---\nperson_vessel_df_for_plot <- person_vessel_df %>%\n  mutate(\n    timestamp = as.POSIXct(timestamp),\n    comm_date = as.Date(timestamp),\n    comm_time_of_day = hms::as_hms(format(timestamp, \"%H:%M:%S\")),\n    sender_sub_type = factor(sender_sub_type, levels = c(\"Person\", \"Vessel\")),\n    communicating_pair_sorted = paste(pmin(sender_name, recipient_name), pmax(sender_name, recipient_name), sep = \" & \")\n  )\n\n# Get community membership from graph object\ncommunity_df <- g_pv %>%\n  as_tibble() %>%\n  select(name, community)\n\n# --- WRAPPING CONTENT AND TOOLTIP ---\nplot_data1 <- person_vessel_df_for_plot %>%\n  mutate(\n    timestamp = as.POSIXct(timestamp),\n    date = as.Date(timestamp),\n    time = format(timestamp, \"%H:%M:%S\"),\n    wrapped_content = str_wrap(content, width = 50),\n    tooltip_text = paste0(\n      \"<b>Date:</b> \", date, \"<br>\",\n      \"<b>Time:</b> \", time, \"<br>\",\n      \"<b>From:</b> \", sender_name, \"<br>\",\n      \"<b>To:</b> \", recipient_name, \"<br>\",\n      \"<b>Event_id:</b> \", event_id, \"<br><br>\",\n      \"<b>Content:</b><br>\", wrapped_content\n    )\n  )\n\n# Merge with plot_data1 using sender_id == name\nplot_data1 <- plot_data1 %>%\n  left_join(community_df, by = c(\"sender_id\" = \"name\"))\n\n# Plot\np <- ggplot(plot_data1, aes(x = comm_date, y = comm_time_of_day)) +\n  geom_point(aes(\n    color = as.factor(community),\n    shape = sender_sub_type,\n    text = tooltip_text\n  ), show.legend = c(color = TRUE, shape = FALSE),\n  size = 2, alpha = 0.7) +\n  scale_shape_manual(values = c(\"Person\" = 16, \"Vessel\" = 17)) +\n  facet_wrap(~ sender_sub_type, ncol = 1, scales = \"fixed\") +\n    scale_y_time(\n    limits = hms::as_hms(c(\"08:00:00\", \"14:00:00\")),  # reversed to show time top-to-bottom\n    breaks = hms::as_hms(c(\"08:00:00\", \"09:00:00\", \"10:00:00\", \"11:00:00\", \"12:00:00\", \"13:00:00\", \"14:00:00\")),\n    labels = c(\"08:00\", \"09:00\", \"10:00\", \"11:00\", \"12:00\", \"13:00\", \"14:00\")\n)+\n  scale_x_date(\n  date_breaks = \"1 day\",\n  date_labels = \"%d %b\"\n)+\n  labs(\n    title = \"Communication Events Over Time (Sender's Perspective)\",\n    x = \"Date\",\n    y = \"Time of Day\",\n    color = \"Community\"\n  ) +\n  theme_grey() +\n  theme(\n    axis.text.y = element_text(size = 6),\n    axis.title.y = element_text(size = 7),\n    axis.ticks.y = element_line(),\n    axis.text.x = element_text(size = 6, angle = 45, hjust = 1),\n    axis.title.x = element_text(margin = margin(t = 10), size = 7),\n    panel.spacing = unit(0.5, \"lines\"),  # Applies to both x and y spacing\n    strip.text = element_text(size = 8, face = \"bold\"),\n    legend.position = \"bottom\",\n    legend.text = element_text(size = 6),\n    legend.title = element_blank()\n  )\n\n# --- Convert to interactive plot ---\nggplotly(p, tooltip = \"tooltip_text\")\n```\n\n### 7.5.13 Discussion/ Interpretation:\n\nWe mainly focused on the conversations by 8 influential nodes and some related nodes:\n\n-   **Conservation Group** (Comm.1): Samantha Blake informed Mako to stop operations on 8 and 10th Oct. Serenity is a private luxury yacht. Osprey was likely a tourism vessel looking for charter from Mako for their tourists.\n\n-   **Permit** (Comm. 2): Neptune, Remora, Nadia, and Davis were working on Nemo Reef operation. This referred to the Music Video Production for Sailor Shift on 14 Oct.\n\n-   **Pseudonym** (Comm. 3): Other than communicating among themselves, The Lookout appeared to have also externally corresponded with Sentinel, Reef Guardian and Horizon (conservation based topics), while The Intern also externally corresponded with Mrs. Money.\n\n-   **Suspicious** (Comm. 4): The Middleman had access to Council documents. Mrs. Money had funding from sources that would not flag out to regulators for her operations. Mrs. Money was investigating V. Miesel's structures. On 5 Oct, Boss told Mrs. Money to disguise financial trails through tourism ventures and destroy evidence of Nemo Reef operations.\n\n-   **Hacklee Herald** (Comm. 5): Conversations between Clepper and his intern Miranda which ended on 11 Oct. Miranda mentioned an Oceanus City Council Member meeting with unmarked vessels at night.\n\n# **8) Tackling Question 3**\n\n# Question 3a)\n\n## 8.1 Entities Breakdown\n\n**Core Logic:**\n\n-   If two names appear as sender and recipient in the same message, they cannot belong to the same person — i.e., they're not aliases of each other.\n\n-   If two names sent a message at the exact time, they cannot belong to the same person.\n\nWe created Alluvial Diagrams to chart: real_identity → observed_name → community\n\n::: panel-tabset\n## Extraction of the list of Entity names\n\n```{r}\nunique_names <- sort(unique(c(other_communications_df$sender_name, \n                              other_communications_df$recipient_name)))\nunique_names\n\n```\n\n## Manual Mapping\n\n```{r}\nname_mapping <- tibble::tibble(\n  observed_name = c(\n    \"Boss\", \"City Officials\", \"Clepper Jensen\", \"Davis\", \"Defender\", \"EcoVigil\",\n    \"Elise\", \"Glitters Team\", \"Green Guardians\", \"Haacklee Harbor\", \"Himark Harbor\", \"Horizon\",\n    \"Kelly\", \"Knowles\", \"Liam Thorne\", \"Mako\", \"Marlin\", \"Miranda Jordan\",\n    \"Mrs. Money\", \"Nadia Conti\", \"Neptune\", \"Northern Light\", \"Oceanus City Council\", \"Osprey\",\n    \"Paackland Harbor\", \"Port Security\", \"Reef Guardian\", \"Remora\", \"Rodriguez\", \"Sailor Shift Team\",\n    \"Sam\", \"Samantha Blake\", \"Seawatch\", \"Sentinel\", \"Serenity\", \"Small Fry\",\n    \"The Accountant\", \"The Intern\", \"The Lookout\", \"The Middleman\", \"V. Miesel Shipping\"\n  ),\n  real_identity = c(\n    \"Nadia Conti\", \"Oceanus City Council\", \"Clepper Jensen\", \"Captain Davis\", \"Sentinel\", \"EcoVigil\",\n    \"Elise\", \"Sailor Shift Team\", \"Green Guardians\", \"Harbor Authority\",\"Harbor Authority\", \"Horizon\",\n    \"Kelly\", \"Knowles\", \"Liam Thorne\", \"Mako\", \"Small Fishing Vessel\", \"Miranda Jordan\",\n    \"Elise\", \"Nadia Conti\", \"Neptune\", \"Commercial Vessel\", \"Oceanus City Council\", \"Tourism Vessel\",\n    \"Harbor Authority\", \"Oceanus City Council\", \"Reef Guardian\", \"Remora\", \"Rodriguez\", \"Sailor Shift Team\",\n    \"Sam\", \"Samantha Blake\", \"Kelly\", \"Sentinel\", \"Private Luxury Yacht\", \"Rodriguez\",\n    \"Elise\", \"Sam\", \"Kelly\", \"Liam Thorne\", \"V. Miesel Shipping\"\n  ),\n  community = c(\n    \"V. Miesel Shipping\", \"City Council\", \"Haacklee Herald\", \"V. Miesel Shipping\", \"Local Conservationist Group\", \"Local Conservationist Group\",\n    \"V. Miesel Shipping\", \"Sailor Shift Team\", \"Local Conservationist Group\", \"Harbor Authority\", \"Harbor Authority\", \"Local Conservationist Group\",\n    \"Local Conservationist Group\", \"V. Miesel Shipping\", \"City Council\", \"V. Miesel Shipping\", \"Maritime\", \"Haacklee Herald\",\n    \"V. Miesel Shipping\", \"V. Miesel Shipping\", \"V. Miesel Shipping\", \"Maritime\", \"City Council\", \"Maritime\",\n    \"Harbor Authority\", \"City Council\", \"Local Conservationist Group\", \"V. Miesel Shipping\", \"V. Miesel Shipping\", \"Sailor Shift Team\",\n    \"V. Miesel Shipping\", \"Sailor Shift Team\", \"Local Conservationist Group\", \"Local Conservationist Group\", \"Maritime\", \"V. Miesel Shipping\",\n    \"V. Miesel Shipping\", \"V. Miesel Shipping\", \"Local Conservationist Group\", \"City Council\", \"V. Miesel Shipping\"\n  )\n)\n\nmulti_members <- tibble::tibble(\n  observed_name = c(\n    #  City Council members (additional to existing)\n    \"Commissioner Blake\", \"Commissioner Torres\", \"Council Knowles\", \"The Middleman\", \"Jensen from City Council\", \"Liam Thorne\",\n\n    # Sailor Shift Team (may already exist, but we ensure all)\n    \"Boss\", \"Council Knowles\", \"Davis\", \"Glitters Team\", \"Liam Thorne\", \"Mako\", \"Mrs. Money\", \"Nadia Conti\", \"Neptune\",\n    \"Remora\", \"Rodriguez\", \"Sam\", \"Samantha Blake\", \"Small Fry\", \"The Accountant\", \"The Intern\", \"The Middleman\", \"Elise\",\n\n    #  Influential Families\n    \"Council Knowles\", \"V. Miesel Shipping\",\n\n    #  Conservationist Group\n    \"Defender\", \"EcoVigil\", \"Green Guardians\", \"Horizon\", \"Kelly\", \"Reef Guardian\", \"Seawatch\", \"Sentinel\", \"The Lookout\"\n  ),\n  real_identity = c(\n    \"Commissioner Blake\", \"Commissioner Torres\", \"Council Knowles\", \"Liam Thorne\", \"Clepper Jensen\", \"Liam Thorne\",\n\n    \"Nadia Conti\", \"Council Knowles\", \"Captain Davis\", \"Sailor Shift Team\", \"Liam Thorne\", \"Mako\", \"Elise\", \"Nadia Conti\", \"Neptune\",\n    \"Remora\", \"Rodriguez\", \"Sam\", \"Samantha Blake\", \"Rodriguez\", \"Elise\", \"Sam\", \"Liam Thorne\", \"Elise\",\n\n    \"Council Knowles\", \"V. Miesel Shipping\",\n\n    \"Sentinel\", \"EcoVigil\", \"Green Guardians\", \"Horizon\", \"Kelly\", \"Reef Guardian\", \"The Lookout\", \"Sentinel\", \"Kelly\"\n  ),\n  community = c(\n    rep(\"City Council\", 6),\n    rep(\"Sailor Shift Team\", 18),\n    rep(\"Influential Families\", 2),\n    rep(\"Local Conservationist Group\", 9)\n  )\n)\n\n```\n:::\n\n## Entities- Interactive Alluvial Diagrams\n\nHover to see details for individual identities.\n\nReal Identity from analysis -\\> Observed Name from data -\\> Community\n\nThis will probably be a drop down for each name in Shiny.\n\n```{r}\n# --- Libraries ---\nlibrary(dplyr)\nlibrary(ggplot2)\nlibrary(ggalluvial)\nlibrary(stringr)\nlibrary(plotly)\n\n# --- 1. Build Alluvial Dataset ---\nalluvial_data <- name_mapping %>%\n  bind_rows(multi_members) %>% # Combine the two data sources\n  distinct() %>% # Remove any duplicate rows after combining\n  filter(!is.na(real_identity) & !is.na(community)) %>%\n  count(real_identity, observed_name, community, name = \"value\") %>%\n  mutate(tooltip = paste0( # Create the tooltip string\n    \"Real Identity: \", real_identity, \"<br>\",\n    \"Observed Name: \", observed_name, \"<br>\",\n    \"Community: \", community, \"<br>\",\n    \"Count: \", value\n  ))\n\n# --- 3. Create static ggplot object (original version) ---\np <- ggplot(alluvial_data,\n            aes(axis1 = real_identity, axis2 = observed_name, axis3 = community,\n                y = value,\n                text = tooltip # Map the custom tooltip string to the 'text' aesthetic\n            )) +\n  geom_alluvium(aes(fill = real_identity), width = 1/12, alpha = 0.8) +\n  geom_stratum(width = 1/12, fill = \"grey90\", color = \"black\", aes(text = NULL)) + # No dual-role fill here\n  geom_text(stat = \"stratum\", aes(label = after_stat(stratum)), size = 3.5, hjust = 0) +\n  scale_x_discrete(\n    limits = c(\"Real Identity\", \"Observed Name\", \"Community\"),\n    expand = c(.05, .25)\n  ) +\n  labs(\n    title = \"All Identity Flows\",\n    x = NULL, y = \"Link Count\"\n  ) +\n  theme_minimal() +\n  theme(\n    legend.position = \"none\", # No legend for fill here\n    panel.grid = element_blank(),\n    axis.text.y = element_blank(),\n    axis.ticks = element_blank(),\n    plot.margin = margin(10, 80, 10, 10),\n    axis.text.x = element_text(face = \"bold\")\n  )\n\n# --- 4. Convert to interactive Plotly object ---\n# 'tooltip = \"text\"' tells Plotly to use the content of the 'text' aesthetic\ninteractive_plot <- ggplotly(p, tooltip = \"text\", height = 800, width = 1000)\ninteractive_plot # This line will print the Plotly object in  Quarto output\n\n```\n\n# Question 3b)\n\nWe created a graph with the character's original name, pseudonyms, and supplemented with any background information we learnt of. For instance, we learnt that Davis was a captain, or that Serenity was a private luxury yacht.Here, it is easier to determine who is using which pseudonyms by clicking on the real identity drop down panel which will then only segregate to the individual's Real Identity, Observed Name, and Community.\n\n# Question 3c)\n\nUnderstanding pseudonyms significantly reshapes our interpretation of the events in Oceanus. Without resolving aliases, the communication network appears fragmented — it may seem like dozens of separate individuals are involved. However, by mapping pseudonyms to real identities, we discover that a small number of actors are coordinating more activity than initially apparent. For example, a person using multiple pseudonyms may appear in many places at once — suggesting high influence or deception. This reveals orchestrated behavior, such as coordinated logistics, manipulation of event timelines, or masking involvement in controversial operations.\n\n# **9) Tackling Question 4**\n\n# Question 4a)\n\n## 9.1 Nadia's Ego Network- Louvain community\n\n::: panel-tabset\n## Ego Network\n\n```{r, echo=FALSE}\nset.seed(1234)\n\n# Assume g_full includes Nadia — not g from other_communications_df\ng_igraph <- as.igraph(g)\n\n# Confirm Nadia exists\nif (!\"Nadia Conti\" %in% V(g_igraph)$name) stop(\"Nadia Conti not found in the graph.\")\n\n# Get ego subgraph\nnadia_ego_igraph <- make_ego_graph(g_igraph, order = 1, nodes = which(V(g_igraph)$name == \"Nadia Conti\"), mode = \"all\")[[1]]\n\n# Convert to tidygraph\nnadia_ego_graph <- as_tbl_graph(nadia_ego_igraph)\n\n# Convert to undirected for Louvain\nnadia_ego_graph <- nadia_ego_graph %>% \n  to_undirected() %>% \n  activate(nodes) %>%\n  mutate(\n    community = group_louvain(),\n    pagerank = centrality_pagerank()\n  )\n\n# Plot Nadia's ego network\nggraph(nadia_ego_graph, layout = \"fr\") +\n  geom_edge_link(alpha = 0.4) +\n  geom_node_point(aes(size = pagerank, color = as.factor(community)), alpha = 0.9) +\n  geom_node_text(aes(label = name), repel = TRUE, size = 3) +\n  scale_color_brewer(palette = \"Set2\") +\n  theme_void() +\n  labs(\n    title = \"Nadia Conti’s Ego Network\",\n    subtitle = \"Nodes sized by PageRank, colored by Louvain community\",\n    color = \"Community\",\n    size = \"PageRank\"\n  )\n```\n\n## The Code\n\n``` r\nset.seed(1234)\n\n# Assume g_full includes Nadia — not g from other_communications_df\ng_igraph <- as.igraph(g)\n\n# Confirm Nadia exists\nif (!\"Nadia Conti\" %in% V(g_igraph)$name) stop(\"Nadia Conti not found in the graph.\")\n\n# Get ego subgraph\nnadia_ego_igraph <- make_ego_graph(g_igraph, order = 1, nodes = which(V(g_igraph)$name == \"Nadia Conti\"), mode = \"all\")[[1]]\n\n# Convert to tidygraph\nnadia_ego_graph <- as_tbl_graph(nadia_ego_igraph)\n\n# Convert to undirected for Louvain\nnadia_ego_graph <- nadia_ego_graph %>% \n  to_undirected() %>% \n  activate(nodes) %>%\n  mutate(\n    community = group_louvain(),\n    pagerank = centrality_pagerank()\n  )\n\n# Plot Nadia's ego network\nggraph(nadia_ego_graph, layout = \"fr\") +\n  geom_edge_link(alpha = 0.4) +\n  geom_node_point(aes(size = pagerank, color = as.factor(community)), alpha = 0.9) +\n  geom_node_text(aes(label = name), repel = TRUE, size = 3) +\n  scale_color_brewer(palette = \"Set2\") +\n  theme_void() +\n  labs(\n    title = \"Nadia Conti’s Ego Network\",\n    subtitle = \"Nodes sized by PageRank, colored by Louvain community\",\n    color = \"Community\",\n    size = \"PageRank\"\n  )\n```\n:::\n\n-   We wanted to find out if there were sub communities within Nadia's direct network that worked closely together.\n-   The orange community were possibly involved in Sailor Shifts's music video, while the green community were likely regarding ensuring compliance to authorities such as officials, the harbour and conservation team.\n-   Nadia, Elise, and Marlin were the orange nodes that directly linked to the green nodes.\n\n## 9.2 Nadia's Sent and Received Ego Networks- VizNetwork\n\n### 9.2.1 Data Preparation\n\n::: panel-tabset\n## Preparation- Nodes & Edges\n\n```{r, echo=FALSE}\n# --- 2. Clean and Prepare Nodes ---\nmc3_nodes_cleaned <- mc3_nodes_raw %>%\n  mutate(id = as.character(id)) %>%\n  filter(!is.na(id)) %>%\n  distinct(id, .keep_all = TRUE) %>%\n  # Rename 'type' to 'supertype' to reduce confusion with communication type\n  rename(supertype = type) %>%\n  # Select only columns that are needed and are consistently present\n  select(id, name, sub_type, content, timestamp) # Keep timestamp as character for now\n\n# --- 3. Clean and Prepare Edges ---\n# Rename 'type' in edges to 'edge_type' to avoid conflict with node 'supertype'\nmc3_edges_cleaned <- mc3_edges_raw %>%\n  rename(from_id = source,\n         to_id = target,\n         edge_type = type) %>% # Renamed 'type' to 'edge_type'\n  mutate(across(c(from_id, to_id), as.character)) %>%\n  # Filter out any edges where from_id or to_id are not in cleaned nodes\n  filter(from_id %in% mc3_nodes_cleaned$id,\n         to_id %in% mc3_nodes_cleaned$id)\n\n# --- 4. Identify Nadia Conti's ID and Sub_type ---\nnadia_info <- mc3_nodes_cleaned %>%\n  filter(name == \"Nadia Conti\") %>%\n  select(id, sub_type) # Corrected: Select sub_type here, not supertype\n\nnadia_id <- nadia_info %>% pull(id)\nnadia_sub_type <- nadia_info %>% pull(sub_type) # New variable for Nadia's sub_type\n\n\nif (length(nadia_id) == 0) {\n  stop(\"Nadia Conti not found in the nodes data. Please check the 'name' column or the ID.\")\n} else if (length(nadia_id) > 1) {\n  warning(\"Multiple entries found for Nadia Conti. Using the first one.\")\n  nadia_id <- nadia_id[1]\n  nadia_sub_type <- nadia_sub_type[1] # Ensure sub_type is also taken for the first one\n}\n\nprint(paste(\"Nadia Conti's ID:\", nadia_id))\nprint(paste(\"Nadia Conti's Sub_type:\", nadia_sub_type))\n\n# --- 5. Extract Nadia's Sent Communications ---\n# Logic: Nadia (source) --sent--> Event_Communication (target) --received--> Recipient (target)\nnadia_sent_communications <- mc3_edges_cleaned %>%\n  filter(from_id == nadia_id, edge_type == \"sent\") %>%\n  # Join with nodes to get content and timestamp of the Event_Communication node\n  left_join(mc3_nodes_cleaned %>% select(id, content, timestamp),\n            by = c(\"to_id\" = \"id\")) %>%\n  rename(event_id = to_id, event_content = content, event_timestamp = timestamp) %>%\n  # Now, find the recipient of this communication event\n  left_join(mc3_edges_cleaned %>%\n              filter(edge_type == \"received\") %>%\n              select(event_id_match = from_id, recipient_id = to_id),\n            by = c(\"event_id\" = \"event_id_match\")) %>%\n  # Join with nodes to get the recipient's name AND sub_type\n  left_join(mc3_nodes_cleaned %>% select(id, name, sub_type), # Select sub_type here\n            by = c(\"recipient_id\" = \"id\")) %>%\n  rename(recipient_name = name, recipient_sub_type = sub_type) %>% # Rename sub_type\n  # Select and rename final columns for sent communications\n  select(\n    communication_type = edge_type, # This will be \"sent\"\n    sender_id = from_id,\n    recipient_id,\n    recipient_name,\n    recipient_sub_type, # Include in final select\n    event_id,\n    content = event_content,\n    timestamp = event_timestamp # Timestamp is still character here\n  ) %>%\n  mutate(\n    sender_name = !!nadia_id, # Explicitly set sender_name to Nadia's ID/name using !!\n    sender_sub_type = !!nadia_sub_type # Assign Nadia's sub_type as a constant value using !!\n  )\n\nprint(\"--- Nadia's Sent Communications ---\")\nprint(kable(head(nadia_sent_communications, 10), format = \"markdown\", align = \"l\"))\n\n\n# --- 6. Extract Nadia's Received Communications ---\n# Logic: Sender (source) --sent--> Event_Communication (target) --received--> Nadia (target)\nnadia_received_communications <- mc3_edges_cleaned %>%\n  filter(to_id == nadia_id, edge_type == \"received\") %>%\n  # The source of this edge is the Event_Communication node\n  rename(event_id = from_id) %>%\n  # Join with nodes to get content and timestamp of the Event_Communication node\n  left_join(mc3_nodes_cleaned %>% select(id, content, timestamp),\n            by = c(\"event_id\" = \"id\")) %>%\n  rename(event_content = content, event_timestamp = timestamp) %>%\n  # Now, find the original sender of this communication event\n  left_join(mc3_edges_cleaned %>%\n              filter(edge_type == \"sent\") %>%\n              select(event_id_match = to_id, sender_id = from_id),\n            by = c(\"event_id\" = \"event_id_match\")) %>%\n  # Join with nodes to get the sender's name AND sub_type\n  left_join(mc3_nodes_cleaned %>% select(id, name, sub_type), # Select sub_type here\n            by = c(\"sender_id\" = \"id\")) %>%\n  rename(sender_name = name, sender_sub_type = sub_type) %>% # Rename sub_type\n  # Select and rename final columns for received communications\n  select(\n    communication_type = edge_type, # This will be \"received\"\n    sender_id,\n    sender_name,\n    sender_sub_type, # Include in final select\n    recipient_id = to_id,\n    event_id,\n    content = event_content,\n    timestamp = event_timestamp\n  ) %>%\n  mutate(\n    recipient_name = !!nadia_id, # Explicitly set recipient_name to Nadia's ID/name using !!\n    recipient_sub_type = !!nadia_sub_type # Assign Nadia's sub_type as a constant value using !!\n  )\n\nprint(\"--- Nadia's Received Communications ---\")\nprint(kable(head(nadia_received_communications, 10), format = \"markdown\", align = \"l\"))\n\n# --- 7. Combine Sent and Received Communications for Full Timeline ---\nnadia_full_communications_timeline <- bind_rows(\n  nadia_sent_communications,\n  nadia_received_communications\n) %>%\n  arrange(timestamp) %>%\n  # CRITICAL FIX: Explicitly convert timestamp to POSIXct after bind_rows\n  # Use as.POSIXct with the observed format string\n  mutate(timestamp = as.POSIXct(timestamp, format = \"%Y-%m-%d %H:%M:%S\")) %>%\n  # NEW: Create a sorted communicating pair for consistent coloring\n  rowwise() %>% # Process row by row\n  mutate(communicating_pair_sorted = paste(sort(c(sender_name, recipient_name)), collapse = \"_\")) %>%\n  ungroup() # Return to normal data frame operations\n\nprint(\"--- Nadia's Full Communication Timeline (Combined) ---\")\nprint(kable(head(nadia_full_communications_timeline, 10), format = \"markdown\", align = \"l\"))\n\n# --- 8. Prepare Data for Ego Network Visualization (Direct Person-to-Person/Entity) ---\n# Build nodes and edges directly from nadia_full_communications_timeline,\n# focusing on direct sender-recipient connections.\n# Nodes for the ego network graph: Collect all unique sender and recipient IDs\nall_ego_person_entity_ids <- nadia_full_communications_timeline %>%\n  select(id = sender_id) %>%\n  bind_rows(nadia_full_communications_timeline %>% select(id = recipient_id)) %>%\n  distinct(id) %>%\n  filter(!is.na(id)) # Ensure no NA IDs\n\n# Filter mc3_nodes_cleaned to get attributes for these person/entity nodes\nego_nodes_for_graph <- mc3_nodes_cleaned %>%\n  filter(id %in% all_ego_person_entity_ids$id) %>%\n  filter(!is.na(id)) %>% # Ensure no NA IDs in nodes for graph\n  # Add attributes for visualization\n  mutate(\n    is_nadia = ifelse(id == nadia_id, TRUE, FALSE),\n    # Create a new column for legend grouping that includes Nadia as a distinct category\n    node_legend_group = ifelse(is_nadia, \"Nadia Conti\", sub_type),\n    node_size = ifelse(is_nadia, 20, 18), # Further increased node sizes: Nadia 20, others 10\n    display_name = ifelse(is_nadia, \"Nadia Conti\", name) # Use actual name for others\n  ) %>%\n  filter(!is.na(sub_type)) # Ensure nodes have a sub_type for consistent plotting\n\n# Calculate communication counts for each node for hover text\nnode_comm_summary <- nadia_full_communications_timeline %>%\n  group_by(id = sender_id) %>%\n  summarise(sent_count = n(), .groups = 'drop') %>%\n  full_join(nadia_full_communications_timeline %>%\n              group_by(id = recipient_id) %>%\n              summarise(received_count = n(), .groups = 'drop'),\n            by = \"id\") %>%\n  mutate(\n    sent_count = replace_na(sent_count, 0),\n    received_count = replace_na(received_count, 0)\n  )\n\n# Join communication summary and create hover text for nodes\nego_nodes_for_graph <- ego_nodes_for_graph %>%\n  left_join(node_comm_summary, by = \"id\") %>%\n  mutate(\n    hover_text = paste(\n      \"Name:\", display_name, \"<br>\",\n      \"Type:\", node_legend_group, \"<br>\",\n      \"Sent Communications:\", sent_count, \"<br>\",\n      \"Received Communications:\", received_count\n    )\n  )\n\n# Edges for the ego network graph: Direct Sender -> Recipient edges\n# Aggregate to count occurrences for edge thickness\nego_edges_for_graph <- nadia_full_communications_timeline %>%\n  # Group by sender, recipient, their names, and communication type to count interactions\n  group_by(from = sender_id, to = recipient_id, sender_name, recipient_name, communication_type) %>%\n  summarise(\n    count_of_comm = n(), # Number of times this specific communication happened\n    content_sample = paste(head(content, 1), collapse = \"; \"), # Sample content\n    timestamp_min = min(timestamp, na.rm = TRUE),\n    timestamp_max = max(timestamp, na.rm = TRUE),\n    .groups = 'drop'\n  ) %>%\n  # Add the 'nadia_role_in_comm' column for coloring based on Nadia's perspective\n  mutate(\n    nadia_role_in_comm = case_when(\n      from == nadia_id & communication_type == \"sent\" ~ \"Nadia Sent\",\n      to == nadia_id & communication_type == \"received\" ~ \"Nadia Received\",\n      TRUE ~ \"Other Communication\" # For communications not directly involving Nadia as sender/recipient\n    )\n  ) %>%\n  # Ensure 'from' and 'to' are character and non-NA\n  mutate(\n    from = as.character(from),\n    to = as.character(to)\n  ) %>%\n  filter(!is.na(from) & !is.na(to)) %>%\n  # Filter out edges where 'from' or 'to' IDs are NOT in the final ego_nodes_for_graph\n  filter(from %in% ego_nodes_for_graph$id, to %in% ego_nodes_for_graph$id) %>%\n  # Create hover text for edges\n  mutate(\n    hover_text = paste(\n      \"From:\", sender_name, \"<br>\",\n      \"To:\", recipient_name, \"<br>\",\n      \"Type:\", communication_type, \"<br>\",\n      \"Count:\", count_of_comm, \"<br>\",\n      \"First:\", format(timestamp_min, \"%Y-%m-%d %H:%M:%S\"), \"<br>\",\n      \"Last:\", format(timestamp_max, \"%Y-%m-%d %H:%M:%S\"), \"<br>\",\n      \"Content Sample:\", content_sample\n    )\n  )\n\n# Create the tbl_graph object for the ego network\nnadia_ego_network_graph <- tbl_graph(nodes = ego_nodes_for_graph, edges = ego_edges_for_graph, directed = TRUE)\n\nprint(\"--- Checking: Number of nodes and edges in Nadia's Ego Network Graph ---\")\nprint(paste(\"Nodes:\", gorder(nadia_ego_network_graph), \"Edges:\", gsize(nadia_ego_network_graph)))\nprint(\"---------------------------------------------------------------------\")\n```\n\n## The Code\n\n``` r\n# --- 2. Clean and Prepare Nodes ---\nmc3_nodes_cleaned <- mc3_nodes_raw %>%\n  mutate(id = as.character(id)) %>%\n  filter(!is.na(id)) %>%\n  distinct(id, .keep_all = TRUE) %>%\n  # Rename 'type' to 'supertype' to reduce confusion with communication type\n  rename(supertype = type) %>%\n  # Select only columns that are needed and are consistently present\n  select(id, name, sub_type, content, timestamp) # Keep timestamp as character for now\n\n# --- 3. Clean and Prepare Edges ---\n# Rename 'type' in edges to 'edge_type' to avoid conflict with node 'supertype'\nmc3_edges_cleaned <- mc3_edges_raw %>%\n  rename(from_id = source,\n         to_id = target,\n         edge_type = type) %>% # Renamed 'type' to 'edge_type'\n  mutate(across(c(from_id, to_id), as.character)) %>%\n  # Filter out any edges where from_id or to_id are not in cleaned nodes\n  filter(from_id %in% mc3_nodes_cleaned$id,\n         to_id %in% mc3_nodes_cleaned$id)\n\n# --- 4. Identify Nadia Conti's ID and Sub_type ---\nnadia_info <- mc3_nodes_cleaned %>%\n  filter(name == \"Nadia Conti\") %>%\n  select(id, sub_type) # Corrected: Select sub_type here, not supertype\n\nnadia_id <- nadia_info %>% pull(id)\nnadia_sub_type <- nadia_info %>% pull(sub_type) # New variable for Nadia's sub_type\n\n\nif (length(nadia_id) == 0) {\n  stop(\"Nadia Conti not found in the nodes data. Please check the 'name' column or the ID.\")\n} else if (length(nadia_id) > 1) {\n  warning(\"Multiple entries found for Nadia Conti. Using the first one.\")\n  nadia_id <- nadia_id[1]\n  nadia_sub_type <- nadia_sub_type[1] # Ensure sub_type is also taken for the first one\n}\n\nprint(paste(\"Nadia Conti's ID:\", nadia_id))\nprint(paste(\"Nadia Conti's Sub_type:\", nadia_sub_type))\n\n# --- 5. Extract Nadia's Sent Communications ---\n# Logic: Nadia (source) --sent--> Event_Communication (target) --received--> Recipient (target)\nnadia_sent_communications <- mc3_edges_cleaned %>%\n  filter(from_id == nadia_id, edge_type == \"sent\") %>%\n  # Join with nodes to get content and timestamp of the Event_Communication node\n  left_join(mc3_nodes_cleaned %>% select(id, content, timestamp),\n            by = c(\"to_id\" = \"id\")) %>%\n  rename(event_id = to_id, event_content = content, event_timestamp = timestamp) %>%\n  # Now, find the recipient of this communication event\n  left_join(mc3_edges_cleaned %>%\n              filter(edge_type == \"received\") %>%\n              select(event_id_match = from_id, recipient_id = to_id),\n            by = c(\"event_id\" = \"event_id_match\")) %>%\n  # Join with nodes to get the recipient's name AND sub_type\n  left_join(mc3_nodes_cleaned %>% select(id, name, sub_type), # Select sub_type here\n            by = c(\"recipient_id\" = \"id\")) %>%\n  rename(recipient_name = name, recipient_sub_type = sub_type) %>% # Rename sub_type\n  # Select and rename final columns for sent communications\n  select(\n    communication_type = edge_type, # This will be \"sent\"\n    sender_id = from_id,\n    recipient_id,\n    recipient_name,\n    recipient_sub_type, # Include in final select\n    event_id,\n    content = event_content,\n    timestamp = event_timestamp # Timestamp is still character here\n  ) %>%\n  mutate(\n    sender_name = !!nadia_id, # Explicitly set sender_name to Nadia's ID/name using !!\n    sender_sub_type = !!nadia_sub_type # Assign Nadia's sub_type as a constant value using !!\n  )\n\nprint(\"--- Nadia's Sent Communications ---\")\nprint(kable(head(nadia_sent_communications, 10), format = \"markdown\", align = \"l\"))\n\n\n# --- 6. Extract Nadia's Received Communications ---\n# Logic: Sender (source) --sent--> Event_Communication (target) --received--> Nadia (target)\nnadia_received_communications <- mc3_edges_cleaned %>%\n  filter(to_id == nadia_id, edge_type == \"received\") %>%\n  # The source of this edge is the Event_Communication node\n  rename(event_id = from_id) %>%\n  # Join with nodes to get content and timestamp of the Event_Communication node\n  left_join(mc3_nodes_cleaned %>% select(id, content, timestamp),\n            by = c(\"event_id\" = \"id\")) %>%\n  rename(event_content = content, event_timestamp = timestamp) %>%\n  # Now, find the original sender of this communication event\n  left_join(mc3_edges_cleaned %>%\n              filter(edge_type == \"sent\") %>%\n              select(event_id_match = to_id, sender_id = from_id),\n            by = c(\"event_id\" = \"event_id_match\")) %>%\n  # Join with nodes to get the sender's name AND sub_type\n  left_join(mc3_nodes_cleaned %>% select(id, name, sub_type), # Select sub_type here\n            by = c(\"sender_id\" = \"id\")) %>%\n  rename(sender_name = name, sender_sub_type = sub_type) %>% # Rename sub_type\n  # Select and rename final columns for received communications\n  select(\n    communication_type = edge_type, # This will be \"received\"\n    sender_id,\n    sender_name,\n    sender_sub_type, # Include in final select\n    recipient_id = to_id,\n    event_id,\n    content = event_content,\n    timestamp = event_timestamp\n  ) %>%\n  mutate(\n    recipient_name = !!nadia_id, # Explicitly set recipient_name to Nadia's ID/name using !!\n    recipient_sub_type = !!nadia_sub_type # Assign Nadia's sub_type as a constant value using !!\n  )\n\nprint(\"--- Nadia's Received Communications ---\")\nprint(kable(head(nadia_received_communications, 10), format = \"markdown\", align = \"l\"))\n\n# --- 7. Combine Sent and Received Communications for Full Timeline ---\nnadia_full_communications_timeline <- bind_rows(\n  nadia_sent_communications,\n  nadia_received_communications\n) %>%\n  arrange(timestamp) %>%\n  # CRITICAL FIX: Explicitly convert timestamp to POSIXct after bind_rows\n  # Use as.POSIXct with the observed format string\n  mutate(timestamp = as.POSIXct(timestamp, format = \"%Y-%m-%d %H:%M:%S\")) %>%\n  # NEW: Create a sorted communicating pair for consistent coloring\n  rowwise() %>% # Process row by row\n  mutate(communicating_pair_sorted = paste(sort(c(sender_name, recipient_name)), collapse = \"_\")) %>%\n  ungroup() # Return to normal data frame operations\n\nprint(\"--- Nadia's Full Communication Timeline (Combined) ---\")\nprint(kable(head(nadia_full_communications_timeline, 10), format = \"markdown\", align = \"l\"))\n\n# --- 8. Prepare Data for Ego Network Visualization (Direct Person-to-Person/Entity) ---\n# Build nodes and edges directly from nadia_full_communications_timeline,\n# focusing on direct sender-recipient connections.\n# Nodes for the ego network graph: Collect all unique sender and recipient IDs\nall_ego_person_entity_ids <- nadia_full_communications_timeline %>%\n  select(id = sender_id) %>%\n  bind_rows(nadia_full_communications_timeline %>% select(id = recipient_id)) %>%\n  distinct(id) %>%\n  filter(!is.na(id)) # Ensure no NA IDs\n\n# Filter mc3_nodes_cleaned to get attributes for these person/entity nodes\nego_nodes_for_graph <- mc3_nodes_cleaned %>%\n  filter(id %in% all_ego_person_entity_ids$id) %>%\n  filter(!is.na(id)) %>% # Ensure no NA IDs in nodes for graph\n  # Add attributes for visualization\n  mutate(\n    is_nadia = ifelse(id == nadia_id, TRUE, FALSE),\n    # Create a new column for legend grouping that includes Nadia as a distinct category\n    node_legend_group = ifelse(is_nadia, \"Nadia Conti\", sub_type),\n    node_size = ifelse(is_nadia, 20, 18), # Further increased node sizes: Nadia 20, others 10\n    display_name = ifelse(is_nadia, \"Nadia Conti\", name) # Use actual name for others\n  ) %>%\n  filter(!is.na(sub_type)) # Ensure nodes have a sub_type for consistent plotting\n\n# Calculate communication counts for each node for hover text\nnode_comm_summary <- nadia_full_communications_timeline %>%\n  group_by(id = sender_id) %>%\n  summarise(sent_count = n(), .groups = 'drop') %>%\n  full_join(nadia_full_communications_timeline %>%\n              group_by(id = recipient_id) %>%\n              summarise(received_count = n(), .groups = 'drop'),\n            by = \"id\") %>%\n  mutate(\n    sent_count = replace_na(sent_count, 0),\n    received_count = replace_na(received_count, 0)\n  )\n\n# Join communication summary and create hover text for nodes\nego_nodes_for_graph <- ego_nodes_for_graph %>%\n  left_join(node_comm_summary, by = \"id\") %>%\n  mutate(\n    hover_text = paste(\n      \"Name:\", display_name, \"<br>\",\n      \"Type:\", node_legend_group, \"<br>\",\n      \"Sent Communications:\", sent_count, \"<br>\",\n      \"Received Communications:\", received_count\n    )\n  )\n\n# Edges for the ego network graph: Direct Sender -> Recipient edges\n# Aggregate to count occurrences for edge thickness\nego_edges_for_graph <- nadia_full_communications_timeline %>%\n  # Group by sender, recipient, their names, and communication type to count interactions\n  group_by(from = sender_id, to = recipient_id, sender_name, recipient_name, communication_type) %>%\n  summarise(\n    count_of_comm = n(), # Number of times this specific communication happened\n    content_sample = paste(head(content, 1), collapse = \"; \"), # Sample content\n    timestamp_min = min(timestamp, na.rm = TRUE),\n    timestamp_max = max(timestamp, na.rm = TRUE),\n    .groups = 'drop'\n  ) %>%\n  # Add the 'nadia_role_in_comm' column for coloring based on Nadia's perspective\n  mutate(\n    nadia_role_in_comm = case_when(\n      from == nadia_id & communication_type == \"sent\" ~ \"Nadia Sent\",\n      to == nadia_id & communication_type == \"received\" ~ \"Nadia Received\",\n      TRUE ~ \"Other Communication\" # For communications not directly involving Nadia as sender/recipient\n    )\n  ) %>%\n  # Ensure 'from' and 'to' are character and non-NA\n  mutate(\n    from = as.character(from),\n    to = as.character(to)\n  ) %>%\n  filter(!is.na(from) & !is.na(to)) %>%\n  # Filter out edges where 'from' or 'to' IDs are NOT in the final ego_nodes_for_graph\n  filter(from %in% ego_nodes_for_graph$id, to %in% ego_nodes_for_graph$id) %>%\n  # Create hover text for edges\n  mutate(\n    hover_text = paste(\n      \"From:\", sender_name, \"<br>\",\n      \"To:\", recipient_name, \"<br>\",\n      \"Type:\", communication_type, \"<br>\",\n      \"Count:\", count_of_comm, \"<br>\",\n      \"First:\", format(timestamp_min, \"%Y-%m-%d %H:%M:%S\"), \"<br>\",\n      \"Last:\", format(timestamp_max, \"%Y-%m-%d %H:%M:%S\"), \"<br>\",\n      \"Content Sample:\", content_sample\n    )\n  )\n\n# Create the tbl_graph object for the ego network\nnadia_ego_network_graph <- tbl_graph(nodes = ego_nodes_for_graph, edges = ego_edges_for_graph, directed = TRUE)\n\nprint(\"--- Checking: Number of nodes and edges in Nadia's Ego Network Graph ---\")\nprint(paste(\"Nodes:\", gorder(nadia_ego_network_graph), \"Edges:\", gsize(nadia_ego_network_graph)))\nprint(\"---------------------------------------------------------------------\")\n```\n:::\n\n### 9.2.2 Nadia's Sent and Received Ego Networks\n\n### 9.2.2.1 Sent Communications Network\n\n::: no-code-fold\n```{r, echo=FALSE}\n\n# Define custom colors for node types (reusing from previous code)\nnode_legend_colors_plot <- c(\n  \"Person\" = \"#88CCEE\",      # Blue\n  \"Vessel\" = \"#D55E00\",      # Orange\n  \"Organization\" = \"#117733\", # Green\n  \"Location\" = \"#AA4499\",   # Purple\n  \"Nadia Conti\" = \"red\"      # Special color for Nadia\n)\n\n# Define custom shapes for node subtypes\nnode_legend_shapes_plot <- c(\n  \"Person\" = \"dot\",        # Circle for visNetwork\n  \"Vessel\" = \"triangle\",\n  \"Organization\" = \"square\",\n  \"Location\" = \"diamond\",\n  \"Nadia Conti\" = \"star\"   # Star shape for Nadia in visNetwork\n)\n\n# Separate the edges into two sets: Nadia Sent and Nadia Received\nedges_sent <- ego_edges_for_graph %>%\n  filter(nadia_role_in_comm == \"Nadia Sent\")\n\nedges_received <- ego_edges_for_graph %>%\n  filter(nadia_role_in_comm == \"Nadia Received\")\n\n# Function to build visNetwork plot for a given edge set\nbuild_visnetwork_plot <- function(edge_df, title_label) {\n  # Prepare nodes from edge list\n  node_ids <- unique(c(edge_df$from, edge_df$to))\n\n  nodes <- ego_nodes_for_graph %>%\n    filter(id %in% node_ids) %>%\n    mutate(\n      label = ifelse(display_name == \"Nadia Conti\", \"\", display_name),\n      title = paste0(\n        \"<b>\", display_name, \"</b><br>\",\n        \"Type: \", node_legend_group, \"<br>\",\n        \"Sent: \", sent_count, \"<br>\",\n        \"Received: \", received_count\n      ),\n      group = ifelse(display_name == \"Nadia Conti\", \"Nadia Conti\", node_legend_group)\n    ) %>%\n    select(id, label, title, group, value = node_size)\n\n  # Prepare edges with arrow and tooltip\n  edges <- edge_df %>%\n    filter(!is.na(from) & !is.na(to)) %>%\n    mutate(\n      arrows = \"to\",\n      title = paste0(\n        \"<b>From:</b> \", sender_name, \"<br>\",\n        \"<b>To:</b> \", recipient_name, \"<br>\",\n        \"<b>Type:</b> \", communication_type, \"<br>\",\n        \"<b>Count:</b> \", count_of_comm, \"<br>\",\n        \"<b>First:</b> \", format(timestamp_min, \"%Y-%m-%d %H:%M:%S\"), \"<br>\",\n        \"<b>Last:</b> \", format(timestamp_max, \"%Y-%m-%d %H:%M:%S\"), \"<br>\",\n      \"<b>Content Sample:</b><br><div style='max-width:300px;white-space:normal;'>\", content_sample, \"</div>\"\n      )\n    ) %>%\n    select(from, to, arrows, title, width = count_of_comm)\n\n  # Create visNetwork\n  visNetwork(nodes, edges, width = \"100%\", height = \"600px\") %>%\n    visEdges(smooth = FALSE, arrows = list(to = list(enabled = TRUE, scaleFactor = 1.5))) %>%\n    visOptions(highlightNearest = TRUE, nodesIdSelection = TRUE) %>%\n    visIgraphLayout(layout = \"layout_with_fr\") %>%\n    visNodes(font = list(size = 14)) %>%\n    visGroups(groupname = \"Person\", color = node_legend_colors_plot[[\"Person\"]], shape = node_legend_shapes_plot[[\"Person\"]]) %>%\n    visGroups(groupname = \"Vessel\", color = node_legend_colors_plot[[\"Vessel\"]], shape = node_legend_shapes_plot[[\"Vessel\"]]) %>%\n    visGroups(groupname = \"Organization\", color = node_legend_colors_plot[[\"Organization\"]], shape = node_legend_shapes_plot[[\"Organization\"]]) %>%\n    visGroups(groupname = \"Location\", color = node_legend_colors_plot[[\"Location\"]], shape = node_legend_shapes_plot[[\"Location\"]]) %>%\n    visGroups(groupname = \"Nadia Conti\", color = node_legend_colors_plot[[\"Nadia Conti\"]], shape = node_legend_shapes_plot[[\"Nadia Conti\"]]) %>%\n      visLegend(\n    addNodes = legend_df,\n    ncol = 2,\n    position = \"left\",\n    main = \"Entity (Sub)Types\",\n    useGroups = FALSE) %>%\n    visLayout(randomSeed = 123) %>%\n    visNetwork::visExport() %>%\n    visNetwork::visPhysics(enabled = TRUE) %>%\n    visNetwork::visInteraction(navigationButtons = TRUE) %>%\n    visNetwork::visEvents(stabilizationIterationsDone = \"function () {this.setOptions({physics:false});}\")\n}\n\n# Build and show visNetwork plots\nbuild_visnetwork_plot(edges_sent, \"Nadia Sent Ego Network\")\n```\n:::\n\n```{r, results=FALSE}\n#| code-fold: true\n#| code-summary: \"Show the code\"\n# Define custom colors for node types (reusing from previous code)\nnode_legend_colors_plot <- c(\n  \"Person\" = \"#88CCEE\",      # Blue\n  \"Vessel\" = \"#D55E00\",      # Orange\n  \"Organization\" = \"#117733\", # Green\n  \"Location\" = \"#AA4499\",   # Purple\n  \"Nadia Conti\" = \"red\"      # Special color for Nadia\n)\n\n# Define custom shapes for node subtypes\nnode_legend_shapes_plot <- c(\n  \"Person\" = \"dot\",        # Circle for visNetwork\n  \"Vessel\" = \"triangle\",\n  \"Organization\" = \"square\",\n  \"Location\" = \"diamond\",\n  \"Nadia Conti\" = \"star\"   # Star shape for Nadia in visNetwork\n)\n\n# Separate the edges into two sets: Nadia Sent and Nadia Received\nedges_sent <- ego_edges_for_graph %>%\n  filter(nadia_role_in_comm == \"Nadia Sent\")\n\nedges_received <- ego_edges_for_graph %>%\n  filter(nadia_role_in_comm == \"Nadia Received\")\n\n# Function to build visNetwork plot for a given edge set\nbuild_visnetwork_plot <- function(edge_df, title_label) {\n  # Prepare nodes from edge list\n  node_ids <- unique(c(edge_df$from, edge_df$to))\n\n  nodes <- ego_nodes_for_graph %>%\n    filter(id %in% node_ids) %>%\n    mutate(\n      label = ifelse(display_name == \"Nadia Conti\", \"\", display_name),\n      title = paste0(\n        \"<b>\", display_name, \"</b><br>\",\n        \"Type: \", node_legend_group, \"<br>\",\n        \"Sent: \", sent_count, \"<br>\",\n        \"Received: \", received_count\n      ),\n      group = ifelse(display_name == \"Nadia Conti\", \"Nadia Conti\", node_legend_group)\n    ) %>%\n    select(id, label, title, group, value = node_size)\n\n  # Prepare edges with arrow and tooltip\n  edges <- edge_df %>%\n    filter(!is.na(from) & !is.na(to)) %>%\n    mutate(\n      arrows = \"to\",\n      title = paste0(\n        \"<b>From:</b> \", sender_name, \"<br>\",\n        \"<b>To:</b> \", recipient_name, \"<br>\",\n        \"<b>Type:</b> \", communication_type, \"<br>\",\n        \"<b>Count:</b> \", count_of_comm, \"<br>\",\n        \"<b>First:</b> \", format(timestamp_min, \"%Y-%m-%d %H:%M:%S\"), \"<br>\",\n        \"<b>Last:</b> \", format(timestamp_max, \"%Y-%m-%d %H:%M:%S\"), \"<br>\",\n      \"<b>Content Sample:</b><br><div style='max-width:300px;white-space:normal;'>\", content_sample, \"</div>\"\n      )\n    ) %>%\n    select(from, to, arrows, title, width = count_of_comm)\n\n  # Create visNetwork\n  visNetwork(nodes, edges, width = \"100%\", height = \"600px\") %>%\n    visEdges(smooth = FALSE, arrows = list(to = list(enabled = TRUE, scaleFactor = 1.5))) %>%\n    visOptions(highlightNearest = TRUE, nodesIdSelection = TRUE) %>%\n    visIgraphLayout(layout = \"layout_with_fr\") %>%\n    visNodes(font = list(size = 14)) %>%\n    visGroups(groupname = \"Person\", color = node_legend_colors_plot[[\"Person\"]], shape = node_legend_shapes_plot[[\"Person\"]]) %>%\n    visGroups(groupname = \"Vessel\", color = node_legend_colors_plot[[\"Vessel\"]], shape = node_legend_shapes_plot[[\"Vessel\"]]) %>%\n    visGroups(groupname = \"Organization\", color = node_legend_colors_plot[[\"Organization\"]], shape = node_legend_shapes_plot[[\"Organization\"]]) %>%\n    visGroups(groupname = \"Location\", color = node_legend_colors_plot[[\"Location\"]], shape = node_legend_shapes_plot[[\"Location\"]]) %>%\n    visGroups(groupname = \"Nadia Conti\", color = node_legend_colors_plot[[\"Nadia Conti\"]], shape = node_legend_shapes_plot[[\"Nadia Conti\"]]) %>%\n      visLegend(\n    addNodes = legend_df,\n    ncol = 2,\n    position = \"left\",\n    main = \"Entity (Sub)Types\",\n    useGroups = FALSE) %>%\n    visLayout(randomSeed = 123) %>%\n    visNetwork::visExport() %>%\n    visNetwork::visPhysics(enabled = TRUE) %>%\n    visNetwork::visInteraction(navigationButtons = TRUE) %>%\n    visNetwork::visEvents(stabilizationIterationsDone = \"function () {this.setOptions({physics:false});}\")\n}\n\n# Build and show visNetwork plots\nbuild_visnetwork_plot(edges_sent, \"Nadia Sent Ego Network\")\n```\n\n### 9.2.2.2 Received Communications Network\n\n::: no-code-fold\n```{r, echo=FALSE}\n\nbuild_visnetwork_plot(edges_received, \"Nadia Received Ego Network\")\n```\n:::\n\n```{r, results=FALSE}\n#| code-fold: true\n#| code-summary: \"Show the code\"\nbuild_visnetwork_plot(edges_received, \"Nadia Received Ego Network\")\n```\n\n### **9.2.3 Findings**:\n\nWe then wanted to find more about the correspondences. The first graph illustrated Nadia's sent communications and the second graph were her received communications. Hover over nodes to see the sent or received count from the perspective of the entity. Hover over arrowheads to see the number, direction, count, first and last correspondence time, type of sent or received, and content of one communication. Nadia sent only 8 but received 18 communications (possibly indicative of using a pseudonym):\n\n-   Nodes involved: Nadia, Davis, Elise, Haacklee Habor, Liam, Marlin, Neptune, Oceanus City Council, Remora, Rodriguez, Sailor Shifts Team, Sentinel, V. Miesel Shipping.\n\n-   Sent more direct communications to Liam (2) and Neptune (2), relative to others.\n\n-   Received more from Davis (5), Elise (3), and Liam (2), relative to others.\n\n-   The next step would be to find out the suspicious characters/ activities.\n\n## 9.3 Nadia's Ego Network: 3-hops degree centrality\n\nTo uncover more details, we designed n-hops degree centrality here. We input 3 hops to hover over the nodes and look into the communications in a wider network. 3-hop exposes overlapping communites (Nadia communicating with someone who coordinates between groups). The \"bridges\" may show their value in 3-hops. It also increases the change of detecting complete or near complete cliques. We understand that should there be requirements for details, we could look into n-hops and more.\n\n::: no-code-fold\n```{r, echo=FALSE}\n#| code-fold: true\n#| code-summary: \"Show the code\"\n\n\n# --- Define event and relationship subtypes (optional, for filtering or labeling) ---\nevent_subtypes <- c(\n  \"Communication\", \"Monitoring\", \"VesselMovement\", \"Assessment\",\n  \"Collaborate\", \"Endorsement\", \"TourActivity\", \"TransponderPing\",\n  \"Harbor Report\", \"Fishing\", \"Criticize\"\n)\n\nrelationship_subtypes <- c(\n  \"Coordinates\", \"AccessPermission\", \"Operates\", \"Colleagues\",\n  \"Suspicious\", \"Reports\", \"Jurisdiction\", \"Unfriendly\", \"Friends\"\n)\n\n# --- Define node colors and shapes by type or key sub-type ---\nnode_legend_colors_plot <- c(\n  \"Person\" = \"#88CCEE\",\n  \"Vessel\" = \"#D55E00\",\n  \"Organization\" = \"#117733\",\n  \"Location\" = \"#AA4499\",\n  \"Group\" = \"#CC79A7\",\n  \"Event\" = \"#DDCC77\",\n  \"Relationship\" = \"#AF8DC3\"\n)\n\nnode_legend_shapes_plot <- c(\n  \"Person\" = \"dot\",\n  \"Vessel\" = \"triangle\",\n  \"Organization\" = \"square\",\n  \"Location\" = \"diamond\",\n  \"Group\" = \"circle\",\n  \"Event\" = \"star\",\n  \"Relationship\" = \"square\"\n)\n\nSTYLES <- list(\n  node_label_dark = \"black\",\n  font_family = \"Roboto Condensed\"\n)\n\n# ---- 2. Define function to extract ego subgraph ----\nextract_ego_subgraph <- function(center_node = \"Nadia Conti\", hops = 3) {\n  # Construct igraph object\n  g <- graph_from_data_frame(\n    d = mc3_edges_final %>% select(from = from_id, to = to_id),\n    vertices = mc3_nodes_final %>% select(id) %>% distinct() %>% rename(name = id),\n    directed = TRUE\n  )\n\n  # Extract ego network\n  ego_graph <- make_ego_graph(g, order = hops, nodes = center_node, mode = \"all\")[[1]]\n  node_ids <- V(ego_graph)$name\n  edge_df <- as_data_frame(ego_graph, what = \"edges\")\n\n  # Prepare node metadata for visNetwork\n  ego_nodes <- mc3_nodes_final %>%\n    filter(id %in% node_ids) %>%\n    mutate(\n      label = ifelse(is.na(name), id, name),\n      tooltip_extra = case_when(\n        type == \"Event\" & sub_type == \"Communication\" ~ content,\n        type == \"Event\" & sub_type == \"Monitoring\" ~ findings,\n        type == \"Event\" & sub_type == \"VesselMovement\" ~ destination,\n        type == \"Event\" & sub_type == \"Assessment\" ~ results,\n        type == \"Relationship\" & sub_type == \"Coordinates\" ~ coordination_type,\n        type == \"Relationship\" & sub_type == \"Operates\" ~ operational_role,\n        type == \"Relationship\" & sub_type == \"Jurisdiction\" ~ jurisdiction_type,\n        TRUE ~ NA_character_\n      ),\n      title = paste0(\n        \"<b>\", label, \"</b><br>\",\n        \"Type: \", type, \"<br>\",\n        \"Sub-type: \", sub_type, \"<br>\",\n        ifelse(!is.na(tooltip_extra), paste0(\"<br><b>Details:</b> \", tooltip_extra), \"\")\n      ),\n      group = case_when(\n        sub_type %in% names(node_legend_colors_plot) ~ sub_type,\n        type %in% names(node_legend_colors_plot) ~ type,\n        TRUE ~ \"Other\"\n      )\n    ) %>%\n    select(id, label, group, title) %>%\n    distinct(id, .keep_all = TRUE)\n\n  list(nodes = ego_nodes, edges = edge_df)\n}\n\n# ---- 3. Extract Nadia Conti's 3-hop ego network ----\nego_data <- extract_ego_subgraph(\"Nadia Conti\", hops = 3)\nnodes <- ego_data$nodes\nedges <- ego_data$edges\n\n# (Optional) Save output\nnadia_ego_nodes_2hop <- nodes\nnadia_ego_edges_2hop <- edges\n\n# ---- 4. Build visNetwork plot ----\nnet <- visNetwork(nodes, edges, width = \"100%\", height = \"600px\") %>%\n  visEdges(arrows = list(to = list(enabled = TRUE, scaleFactor = 1.5))) %>%\n  visOptions(highlightNearest = TRUE, nodesIdSelection = TRUE) %>%\n  visIgraphLayout(layout = \"layout_with_fr\") %>%\n  visNodes(font = list(\n    size = 14,\n    color = STYLES$node_label_dark,\n    face = STYLES$font_family,\n    vadjust = -15\n  ))\n\n# ---- 5. Apply color/shape for known groups ----\nused_groups <- intersect(unique(nodes$group), names(node_legend_colors_plot))\n\nfor (group_name in used_groups) {\n  net <- net %>% visGroups(\n    groupname = group_name,\n    color = node_legend_colors_plot[[group_name]],\n    shape = node_legend_shapes_plot[[group_name]]\n  )\n}\n\n# ---- 6. Add legend dynamically ----\nlegend_df <- tibble::tibble(\n  label = used_groups,\n  shape = node_legend_shapes_plot[used_groups],\n  color = node_legend_colors_plot[used_groups]\n) %>%\n  distinct(label, .keep_all = TRUE)\n\nnet <- net %>% visLegend(\n  addNodes = legend_df,\n  ncol = 2,\n  position = \"left\",\n  main = \"Entity (Sub)Types\",\n  useGroups = FALSE\n)\n\n# ---- 7. Render the network ----\nnet\n\n\n\n```\n:::\n\n```{r, results=FALSE}\n#| code-fold: true\n#| code-summary: \"Show the code\"\n\n# --- Define event and relationship subtypes (optional, for filtering or labeling) ---\nevent_subtypes <- c(\n  \"Communication\", \"Monitoring\", \"VesselMovement\", \"Assessment\",\n  \"Collaborate\", \"Endorsement\", \"TourActivity\", \"TransponderPing\",\n  \"Harbor Report\", \"Fishing\", \"Criticize\"\n)\n\nrelationship_subtypes <- c(\n  \"Coordinates\", \"AccessPermission\", \"Operates\", \"Colleagues\",\n  \"Suspicious\", \"Reports\", \"Jurisdiction\", \"Unfriendly\", \"Friends\"\n)\n\n# --- Define node colors and shapes by type or key sub-type ---\nnode_legend_colors_plot <- c(\n  \"Person\" = \"#88CCEE\",\n  \"Vessel\" = \"#D55E00\",\n  \"Organization\" = \"#117733\",\n  \"Location\" = \"#AA4499\",\n  \"Group\" = \"#CC79A7\",\n  \"Event\" = \"#DDCC77\",\n  \"Relationship\" = \"#AF8DC3\"\n)\n\nnode_legend_shapes_plot <- c(\n  \"Person\" = \"dot\",\n  \"Vessel\" = \"triangle\",\n  \"Organization\" = \"square\",\n  \"Location\" = \"diamond\",\n  \"Group\" = \"circle\",\n  \"Event\" = \"star\",\n  \"Relationship\" = \"square\"\n)\n\nSTYLES <- list(\n  node_label_dark = \"black\",\n  font_family = \"Roboto Condensed\"\n)\n\n# ---- 2. Define function to extract ego subgraph ----\nextract_ego_subgraph <- function(center_node = \"Nadia Conti\", hops = 3) {\n  # Construct igraph object\n  g <- graph_from_data_frame(\n    d = mc3_edges_final %>% select(from = from_id, to = to_id),\n    vertices = mc3_nodes_final %>% select(id) %>% distinct() %>% rename(name = id),\n    directed = TRUE\n  )\n\n  # Extract ego network\n  ego_graph <- make_ego_graph(g, order = hops, nodes = center_node, mode = \"all\")[[1]]\n  node_ids <- V(ego_graph)$name\n  edge_df <- as_data_frame(ego_graph, what = \"edges\")\n\n  # Prepare node metadata for visNetwork\n  ego_nodes <- mc3_nodes_final %>%\n    filter(id %in% node_ids) %>%\n    mutate(\n      label = ifelse(is.na(name), id, name),\n      tooltip_extra = case_when(\n        type == \"Event\" & sub_type == \"Communication\" ~ content,\n        type == \"Event\" & sub_type == \"Monitoring\" ~ findings,\n        type == \"Event\" & sub_type == \"VesselMovement\" ~ destination,\n        type == \"Event\" & sub_type == \"Assessment\" ~ results,\n        type == \"Relationship\" & sub_type == \"Coordinates\" ~ coordination_type,\n        type == \"Relationship\" & sub_type == \"Operates\" ~ operational_role,\n        type == \"Relationship\" & sub_type == \"Jurisdiction\" ~ jurisdiction_type,\n        TRUE ~ NA_character_\n      ),\n      title = paste0(\n        \"<b>\", label, \"</b><br>\",\n        \"Type: \", type, \"<br>\",\n        \"Sub-type: \", sub_type, \"<br>\",\n        ifelse(!is.na(tooltip_extra), paste0(\"<br><b>Details:</b> \", tooltip_extra), \"\")\n      ),\n      group = case_when(\n        sub_type %in% names(node_legend_colors_plot) ~ sub_type,\n        type %in% names(node_legend_colors_plot) ~ type,\n        TRUE ~ \"Other\"\n      )\n    ) %>%\n    select(id, label, group, title) %>%\n    distinct(id, .keep_all = TRUE)\n\n  list(nodes = ego_nodes, edges = edge_df)\n}\n\n# ---- 3. Extract Nadia Conti's 3-hop ego network ----\nego_data <- extract_ego_subgraph(\"Nadia Conti\", hops = 3)\nnodes <- ego_data$nodes\nedges <- ego_data$edges\n\n# (Optional) Save output\nnadia_ego_nodes_2hop <- nodes\nnadia_ego_edges_2hop <- edges\n\n# ---- 4. Build visNetwork plot ----\nnet <- visNetwork(nodes, edges, width = \"100%\", height = \"600px\") %>%\n  visEdges(arrows = list(to = list(enabled = TRUE, scaleFactor = 1.5))) %>%\n  visOptions(highlightNearest = TRUE, nodesIdSelection = TRUE) %>%\n  visIgraphLayout(layout = \"layout_with_fr\") %>%\n  visNodes(font = list(\n    size = 14,\n    color = STYLES$node_label_dark,\n    face = STYLES$font_family,\n    vadjust = -15\n  ))\n\n# ---- 5. Apply color/shape for known groups ----\nused_groups <- intersect(unique(nodes$group), names(node_legend_colors_plot))\n\nfor (group_name in used_groups) {\n  net <- net %>% visGroups(\n    groupname = group_name,\n    color = node_legend_colors_plot[[group_name]],\n    shape = node_legend_shapes_plot[[group_name]]\n  )\n}\n\n# ---- 6. Add legend dynamically ----\nlegend_df <- tibble::tibble(\n  label = used_groups,\n  shape = node_legend_shapes_plot[used_groups],\n  color = node_legend_colors_plot[used_groups]\n) %>%\n  distinct(label, .keep_all = TRUE)\n\nnet <- net %>% visLegend(\n  addNodes = legend_df,\n  ncol = 2,\n  position = \"left\",\n  main = \"Entity (Sub)Types\",\n  useGroups = FALSE\n)\n\n# ---- 7. Render the network ----\nnet\n\n\n```\n\n#### **9.3.1 Findings**:\n\n-   Nodes from 1-hop: Nadia, Davis, Elise, Haacklee Habor, Liam, Marlin, Neptune, Oceanus City Council, Remora, Rodriguez, Sailor Shifts Team, Sentinel, V. Miesel Shipping.\n\n-   Additional nodes from 3-hop: Conservation vessels, EcoVigil, Sam, The Accountant, Mako, Nemo Reef.\n\n-   We would then use these 3-hop nodes to drill in deeper to find suspicious relationships between nodes.\n\n# Question 4b)\n\n## **9.4 Summary of Nadia's Actions**\n\n### 9.4.1 Sequential Timeline in Table (3-hop)\n\n::: panel-tabset\n## The Suspicious Entities\n\n```{r, echo=FALSE}\n# Extract Nadia Conti's 3-hop ego network\n\n# ---- Step 1: Create igraph from edge list ----\ng <- graph_from_data_frame(\n  d = mc3_edges_final %>% select(from = from_id, to = to_id),\n  vertices = mc3_nodes_final %>% select(id) %>% distinct() %>% rename(name = id),\n  directed = TRUE\n)\n\n# ---- Step 2: Extract 3-hop ego network for Nadia Conti ----\nego_graph <- make_ego_graph(g, order = 3, nodes = \"Nadia Conti\", mode = \"all\")[[1]]\nnode_ids <- V(ego_graph)$name\nedge_df <- as_data_frame(ego_graph, what = \"edges\")\n\n# ---- Step 3: Enrich ego nodes with labels and metadata ----\nnadia_ego_nodes_3hop <- mc3_nodes_final %>%\n  filter(id %in% node_ids) %>%\n  mutate(\n    label = ifelse(is.na(name), id, name),\n    tooltip_extra = case_when(\n      type == \"Event\" & sub_type == \"Communication\" ~ content,\n      type == \"Event\" & sub_type == \"Monitoring\" ~ findings,\n      type == \"Event\" & sub_type == \"VesselMovement\" ~ destination,\n      type == \"Event\" & sub_type == \"Assessment\" ~ results,\n      type == \"Relationship\" & sub_type == \"Coordinates\" ~ coordination_type,\n      type == \"Relationship\" & sub_type == \"Operates\" ~ operational_role,\n      type == \"Relationship\" & sub_type == \"Jurisdiction\" ~ jurisdiction_type,\n      TRUE ~ NA_character_\n    )\n  )\n\n# ---- Step 4: Enrich edges with sender/recipient names and types ----\nnadia_ego_edges_3hop <- edge_df %>%\n  left_join(nadia_ego_nodes_3hop %>% select(id, sender_name = label, sender_sub_type = sub_type), by = c(\"from\" = \"id\")) %>%\n  left_join(nadia_ego_nodes_3hop %>% select(id, recipient_name = label, recipient_sub_type = sub_type), by = c(\"to\" = \"id\"))\n\n# ---- Step 5: Create detailed communication dataframe ----\nnadia_ego_comm_df_3hop <- edge_df %>%\n  left_join(\n    nadia_ego_nodes_3hop %>%\n      select(id, name, sub_type),\n    by = c(\"from\" = \"id\")\n  ) %>%\n  rename(\n    sender_id = from,\n    sender_name = name,\n    sender_type = sub_type\n  ) %>%\n  left_join(\n    nadia_ego_nodes_3hop %>%\n      select(id, name, sub_type, content, findings, destination, results,\n             coordination_type, operational_role, jurisdiction_type, timestamp),\n    by = c(\"to\" = \"id\")\n  ) %>%\n  rename(\n    recipient_id = to,\n    recipient_name = name,\n    recipient_type = sub_type\n  ) %>%\n  mutate(\n    details = coalesce(content, findings, destination, results,\n                       coordination_type, operational_role, jurisdiction_type),\n    timestamp = suppressWarnings(ymd_hms(timestamp))\n  ) %>%\n  select(\n    sender_id, sender_name, sender_type,\n    recipient_id, recipient_name, recipient_type,\n    timestamp, details\n  )\n\n# ---- Step 6: Filter for 'suspicious' in any relevant field ----\nsuspicious_links <- nadia_ego_comm_df_3hop %>%\n  filter(\n    grepl(\"suspicious\", sender_id, ignore.case = TRUE) |\n    grepl(\"suspicious\", sender_type, ignore.case = TRUE) |\n    grepl(\"suspicious\", recipient_id, ignore.case = TRUE) |\n    grepl(\"suspicious\", recipient_type, ignore.case = TRUE)\n  ) %>%\n  select(\n    sender_id, sender_name, sender_type,\n    recipient_id, recipient_name, recipient_type\n  )\n\n\n# ---- Step 7: View suspicious interactions ----\nunique_ids <- unique(c(suspicious_links$sender_id, suspicious_links$recipient_id))\nprint(unique_ids)\n\n```\n\n## The Code\n\n``` r\n# Extract Nadia Conti's 3-hop ego network\n#| code-fold: true\n#| code-summary: \"Show the code\"\n\n# ---- Step 1: Create igraph from edge list ----\ng <- graph_from_data_frame(\n  d = mc3_edges_final %>% select(from = from_id, to = to_id),\n  vertices = mc3_nodes_final %>% select(id) %>% distinct() %>% rename(name = id),\n  directed = TRUE\n)\n\n# ---- Step 2: Extract 3-hop ego network for Nadia Conti ----\nego_graph <- make_ego_graph(g, order = 3, nodes = \"Nadia Conti\", mode = \"all\")[[1]]\nnode_ids <- V(ego_graph)$name\nedge_df <- as_data_frame(ego_graph, what = \"edges\")\n\n# ---- Step 3: Enrich ego nodes with labels and metadata ----\nnadia_ego_nodes_3hop <- mc3_nodes_final %>%\n  filter(id %in% node_ids) %>%\n  mutate(\n    label = ifelse(is.na(name), id, name),\n    tooltip_extra = case_when(\n      type == \"Event\" & sub_type == \"Communication\" ~ content,\n      type == \"Event\" & sub_type == \"Monitoring\" ~ findings,\n      type == \"Event\" & sub_type == \"VesselMovement\" ~ destination,\n      type == \"Event\" & sub_type == \"Assessment\" ~ results,\n      type == \"Relationship\" & sub_type == \"Coordinates\" ~ coordination_type,\n      type == \"Relationship\" & sub_type == \"Operates\" ~ operational_role,\n      type == \"Relationship\" & sub_type == \"Jurisdiction\" ~ jurisdiction_type,\n      TRUE ~ NA_character_\n    )\n  )\n\n# ---- Step 4: Enrich edges with sender/recipient names and types ----\nnadia_ego_edges_3hop <- edge_df %>%\n  left_join(nadia_ego_nodes_3hop %>% select(id, sender_name = label, sender_sub_type = sub_type), by = c(\"from\" = \"id\")) %>%\n  left_join(nadia_ego_nodes_3hop %>% select(id, recipient_name = label, recipient_sub_type = sub_type), by = c(\"to\" = \"id\"))\n\n# ---- Step 5: Create detailed communication dataframe ----\nnadia_ego_comm_df_3hop <- edge_df %>%\n  left_join(\n    nadia_ego_nodes_3hop %>%\n      select(id, name, sub_type),\n    by = c(\"from\" = \"id\")\n  ) %>%\n  rename(\n    sender_id = from,\n    sender_name = name,\n    sender_type = sub_type\n  ) %>%\n  left_join(\n    nadia_ego_nodes_3hop %>%\n      select(id, name, sub_type, content, findings, destination, results,\n             coordination_type, operational_role, jurisdiction_type, timestamp),\n    by = c(\"to\" = \"id\")\n  ) %>%\n  rename(\n    recipient_id = to,\n    recipient_name = name,\n    recipient_type = sub_type\n  ) %>%\n  mutate(\n    details = coalesce(content, findings, destination, results,\n                       coordination_type, operational_role, jurisdiction_type),\n    timestamp = suppressWarnings(ymd_hms(timestamp))\n  ) %>%\n  select(\n    sender_id, sender_name, sender_type,\n    recipient_id, recipient_name, recipient_type,\n    timestamp, details\n  )\n\n# ---- Step 6: Filter for 'suspicious' in any relevant field ----\nsuspicious_links <- nadia_ego_comm_df_3hop %>%\n  filter(\n    grepl(\"suspicious\", sender_id, ignore.case = TRUE) |\n    grepl(\"suspicious\", sender_type, ignore.case = TRUE) |\n    grepl(\"suspicious\", recipient_id, ignore.case = TRUE) |\n    grepl(\"suspicious\", recipient_type, ignore.case = TRUE)\n  ) %>%\n  select(\n    sender_id, sender_name, sender_type,\n    recipient_id, recipient_name, recipient_type\n  )\n\n\n# ---- Step 7: View suspicious interactions ----\nunique_ids <- unique(c(suspicious_links$sender_id, suspicious_links$recipient_id))\nprint(unique_ids)\n```\n:::\n\n-   Elise, EcoVigil, Elise, Davis, Liam, Mako, Neptune, Sam, Remora, Rodriguez, Sailor Shifts Team, Sentinel, The Accountant, Oceanus City Council, V. Miesel Shipping possibly found something suspicious or were involved in something suspicious.\n\n### 9.4.2 Plotted Timeline (3-hop)- Only suspicious communications\n\nThese are the suspicious communications extracted from 9.4.1.\n\n```{r}\n#| code-fold: true\n#| code-summary: \"Show the code\"\n\n# ---- Step 1: Define fixed suspicious Event_Communication IDs ----\nevent_ids_to_extract <- c(\n  \"Event_Communication_222\", \"Event_Communication_270\",\n  \"Event_Communication_272\", \"Event_Communication_370\",\n  \"Event_Communication_485\", \"Event_Communication_535\",\n  \"Event_Communication_565\", \"Event_Communication_574\",\n  \"Event_Communication_601\", \"Event_Communication_612\",\n  \"Event_Communication_639\", \"Event_Communication_677\",\n  \"Event_Communication_724\", \"Event_Communication_726\",\n  \"Event_Communication_753\", \"Event_Communication_761\",\n  \"Event_Communication_833\", \"Event_Communication_916\",\n  \"Event_Communication_951\"\n)\n\n# ---- Step 2: Match to master communication events ----\nmatched_comms_df <- other_communications_df %>%\n  filter(event_id %in% event_ids_to_extract)\n\n# ---- Step 3: Prepare data for plotting ----\nmatched_comms_df_for_plot <- matched_comms_df %>%\n  mutate(\n    timestamp = as.POSIXct(timestamp),\n    comm_date = as.Date(timestamp),\n    comm_time_of_day = hms::as_hms(format(timestamp, \"%H:%M:%S\")),\n    sender_sub_type = factor(sender_sub_type, levels = c(\"Person\", \"Vessel\", \"Organization\", \"Location\")),\n    communicating_pair_sorted = paste(pmin(sender_name, recipient_name), pmax(sender_name, recipient_name), sep = \" & \")\n  )\n\n# ---- Step 4: Add tooltip labels ----\nplot_data <- matched_comms_df_for_plot %>%\n  mutate(\n    wrapped_content = str_wrap(content, width = 50),\n    tooltip_text = paste0(\n      \"<b>Date:</b> \", comm_date, \"<br>\",\n      \"<b>Time:</b> \", format(comm_time_of_day, \"%H:%M:%S\"), \"<br>\",\n      \"<b>Event ID:</b> \", event_id, \"<br><br>\",\n      \"<b>From:</b> \", sender_name, \"<br>\",\n      \"<b>To:</b> \", recipient_name, \"<br><br>\",\n      \"<b>Content:</b><br>\", wrapped_content\n    )\n  )\n\n# ---- Step 5: Generate timeline plot ----\np <- ggplot(plot_data, aes(x = comm_date, y = comm_time_of_day)) +\n  geom_point(aes(\n    color = sender_name,\n    shape = sender_sub_type,\n    text = tooltip_text\n  ), show.legend = c(color = TRUE, shape = FALSE), size = 2, alpha = 0.7) +\n\n  scale_shape_manual(values = c(\n    \"Person\" = 16,\n    \"Vessel\" = 17,\n    \"Organization\" = 15,\n    \"Location\" = 18\n  )) +\n\n  scale_y_time(\n    limits = hms::as_hms(c(\"08:00:00\", \"14:00:00\")),\n    breaks = hms::as_hms(c(\"08:00:00\", \"09:00:00\", \"10:00:00\", \"11:00:00\", \"12:00:00\", \"13:00:00\", \"14:00:00\")),\n    labels = c(\"08:00\", \"09:00\", \"10:00\", \"11:00\", \"12:00\", \"13:00\", \"14:00\")\n  ) +\n\n  scale_x_date(\n    date_breaks = \"1 day\",\n    date_labels = \"%d %b\"\n  ) +\n\n  facet_wrap(~ sender_sub_type, ncol = 1, scales = \"fixed\") +\n\n  labs(\n    title = \"Suspicious Communications Timeline (Nadia's 3-hop Ego Network)\",\n    x = \"Date\",\n    y = \"Time of Day\",\n    color = \"Sender\"\n  ) +\n\n  theme_grey() +\n  theme(\n    axis.text.y = element_text(size = 6),\n    axis.title.y = element_text(size = 7),\n    axis.text.x = element_text(size = 6, angle = 45, hjust = 1),\n    axis.title.x = element_text(margin = margin(t = 10), size = 7),\n    panel.spacing = unit(0.5, \"lines\"),\n    strip.text = element_text(size = 8, face = \"bold\"),\n    legend.position = \"bottom\",\n    legend.text = element_text(size = 6),\n    legend.title = element_text(size = 7)\n  )\n\n# ---- Step 6: Convert to interactive plot ----\nggplotly(p, tooltip = \"text\")\n\n```\n\n### Plotted Timeline (3-hop)- Full communications\n\n```{r}\n#| code-fold: true\n#| code-summary: \"Show the code\"\n\n# ---- Step 1: Extract Communication Event IDs from Nadia's 3-hop ego network ----\nevent_ids_to_extract <- nadia_ego_comm_df_3hop %>%\n  filter(str_starts(sender_id, \"Event_Communication_\")) %>%\n  pull(sender_id) %>%\n  unique()\n\n# ---- Step 2: Match to master communication events ----\nmatched_comms_df <- other_communications_df %>%\n  filter(event_id %in% event_ids_to_extract)\n\n# ---- Step 3: Prepare data for plotting ----\nmatched_comms_df_for_plot <- matched_comms_df %>%\n  mutate(\n    timestamp = as.POSIXct(timestamp),\n    comm_date = as.Date(timestamp),\n    comm_time_of_day = hms::as_hms(format(timestamp, \"%H:%M:%S\")),\n    sender_sub_type = factor(sender_sub_type, levels = c(\"Person\", \"Vessel\", \"Organization\", \"Location\")),\n    communicating_pair_sorted = paste(pmin(sender_name, recipient_name), pmax(sender_name, recipient_name), sep = \" & \")\n  )\n\n# ---- Step 4: Add tooltip labels ----\nplot_data <- matched_comms_df_for_plot %>%\n  mutate(\n    wrapped_content = str_wrap(content, width = 50),\n    tooltip_text = paste0(\n      \"<b>Date:</b> \", comm_date, \"<br>\",\n      \"<b>Time:</b> \", format(comm_time_of_day, \"%H:%M:%S\"), \"<br>\",\n      \"<b>Event ID:</b> \", event_id, \"<br><br>\",\n      \"<b>From:</b> \", sender_name, \"<br>\",\n      \"<b>To:</b> \", recipient_name, \"<br><br>\",\n      \"<b>Content:</b><br>\", wrapped_content\n    )\n  )\n\n# ---- Step 5: Generate timeline plot ----\np <- ggplot(plot_data, aes(x = comm_date, y = comm_time_of_day)) +\n  geom_point(aes(\n    color = sender_name,\n    shape = sender_sub_type,\n    text = tooltip_text\n  ), show.legend = c(color = TRUE, shape = FALSE), size = 2, alpha = 0.7) +\n\n  scale_shape_manual(values = c(\n    \"Person\" = 16,\n    \"Vessel\" = 17,\n    \"Organization\" = 15,\n    \"Location\" = 18\n  )) +\n\n  scale_y_time(\n    limits = hms::as_hms(c(\"08:00:00\", \"14:00:00\")),\n    breaks = hms::as_hms(c(\"08:00:00\", \"09:00:00\", \"10:00:00\", \"11:00:00\", \"12:00:00\", \"13:00:00\", \"14:00:00\")),\n    labels = c(\"08:00\", \"09:00\", \"10:00\", \"11:00\", \"12:00\", \"13:00\", \"14:00\")\n  ) +\n\n  scale_x_date(\n    date_breaks = \"1 day\",\n    date_labels = \"%d %b\"\n  ) +\n\n  facet_wrap(~ sender_sub_type, ncol = 1, scales = \"fixed\") +\n\n  labs(\n    title = \"Nadia's 3-hop Communications Timeline (Sender Perspective)\",\n    x = \"Date\",\n    y = \"Time of Day\",\n    color = \"Sender\"\n  ) +\n\n  theme_grey() +\n  theme(\n    axis.text.y = element_text(size = 6),\n    axis.title.y = element_text(size = 7),\n    axis.text.x = element_text(size = 6, angle = 45, hjust = 1),\n    axis.title.x = element_text(margin = margin(t = 10), size = 7),\n    panel.spacing = unit(0.5, \"lines\"),\n    strip.text = element_text(size = 8, face = \"bold\"),\n    legend.position = \"bottom\",\n    legend.text = element_text(size = 6),\n    legend.title = element_text(size = 7)\n  )\n\n# ---- Step 6: Convert to interactive plot ----\nggplotly(p, tooltip = \"text\")\n\n```\n\n## **9.5 Discussion/Interpretation (1 & 3 hop data):**\n\nThere were certain questions we posted to ourselves and came out with the answers.\n\n### 9.5.1 The Community and Ego Network:\n\n#### Question and Answer Analysis\n\n+--------------------------------------------------------------------------------------------------------------------------------------------------------------+---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+\n| Question                                                                                                                                                     | Answer                                                                                                                                                                                                  |\n+:=============================================================================================================================================================+:========================================================================================================================================================================================================+\n| Who were Nadia’s direct communication contacts (1-hop degree centrality)? Are any of them known to be suspicious or involved in illicit activities?          | From the thicker width in the Ego network, it appeared that Nadia often communicated with **Liam**, **Elise**, and **Davis**.                                                                           |\n|                                                                                                                                                              |                                                                                                                                                                                                         |\n|                                                                                                                                                              | Liam appeared to be The **Middleman** within Nadia’s direct community from the Louvain Community Network.                                                                                               |\n|                                                                                                                                                              |                                                                                                                                                                                                         |\n|                                                                                                                                                              | From the filtered table on suspicious relationships, **Elise**, **Liam**, **EcoVigil**, **Sentinel**, **Oceanus City Council**, and **V. Miesel Shipping** were noted to have suspicious relationships. |\n|                                                                                                                                                              |                                                                                                                                                                                                         |\n|                                                                                                                                                              | Their conversations were the area of focus to uncover their roles, relationships and identities.                                                                                                        |\n+--------------------------------------------------------------------------------------------------------------------------------------------------------------+---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+\n| Were there any other ‘Event’ or ‘Relationship’ nodes directly connected to Nadia in this communication network that hinted at suspicious people/ activities? | Based on information from question 2, **Rodriguez** was previously involved in **mining activities** that affected the environment. ‘**Mining**’ as a topic and his conversations would be tracked.     |\n+--------------------------------------------------------------------------------------------------------------------------------------------------------------+---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+\n\n### 9.5.2 The Communication Timeline and Content:\n\nIn the `nadia_full_communications_timeline` table, the actual content of her direct two-way communications were investigated over the course of 9 days. There were certain suspicious entities, keywords, coded language, or unusual topics detected that were suspicious. We have tabled out the segmented suspicious and non-suspicious entities for investigation and elimination.\n\n::: panel-tabset\n### Not in the Network but Mentioned in the Content\n\n+-----------------+------------------------+---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+---------------+\n| Entity          | Form of Subject Matter | Rationale                                                                                                                                                                                         | Event ID      |\n+=================+========================+===================================================================================================================================================================================================+===============+\n| Nemo Reef       | Location               | Likely conservation area which was picked by the characters for illicit activities.                                                                                                               | 331, 943      |\n+-----------------+------------------------+---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+---------------+\n| Permit #CR-7844 | Item                   | Likely a permit to show tourism activity as a cover for suspicious activities. Rodriguez is likely linked to vessels Mako, Neptune, and Remora operating under this permit with a tourism facade. | 582, 847, 805 |\n+-----------------+------------------------+---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+---------------+\n| EcoVigil        | Vessel                 | EcoVigil will likely affect Nadia's operations when they use their ROV. Nadia recommended to V. Miesel to accelerate the planned operation. They were likely working for different sides.         | 753, 847      |\n+-----------------+------------------------+---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+---------------+\n\n### Suspicious Entity\n\n+--------------------------------------+--------------+-----------+-------------------------------------------------------------------------------------------------------------------------------------------------+--------------------+\n| Suspicious Entity                    | Sub Type     | Community | Rationale                                                                                                                                       | Event ID           |\n+======================================+==============+===========+=================================================================================================================================================+====================+\n| Haacklee Harbor                      | Location     | 2         | Nadia's communication to Haacklee Harbor is suspicious when she wanted the documents destroyed and the special corridor to Nemo Reef cancelled. | 331                |\n+--------------------------------------+--------------+-----------+-------------------------------------------------------------------------------------------------------------------------------------------------+--------------------+\n| Liam aka The Middleman               | Person       | 2         | Nadia wanted him to double his usual fee to ensure Harbor Master remains cooperative. Identity revealed through:                                | 529, 795, 847      |\n+--------------------------------------+--------------+-----------+-------------------------------------------------------------------------------------------------------------------------------------------------+--------------------+\n| Davis                                | Person       | 1         | Nadia told him to create a clean paper trail. She will provide permits.                                                                         | 521                |\n+--------------------------------------+--------------+-----------+-------------------------------------------------------------------------------------------------------------------------------------------------+--------------------+\n| Elise aka Mrs. Money                 | Person       | 1         | Nadia warned Elise that conservation vessels might complicate their operation. Identity revealed through:                                       | 708, 528, 538, 677 |\n+--------------------------------------+--------------+-----------+-------------------------------------------------------------------------------------------------------------------------------------------------+--------------------+\n| Rodriguez aka Small Fry              | Person       | 1         | Linked to Mako, which is operating under a permit with a tourism facade.                                                                        | 805                |\n+--------------------------------------+--------------+-----------+-------------------------------------------------------------------------------------------------------------------------------------------------+--------------------+\n| Remora                               | Vessel       | 1         | Remora reported a tourism facade to Nadia and planned underwater lighting placements in Nemo Reef while monitoring conservation vessels.        | 943                |\n+--------------------------------------+--------------+-----------+-------------------------------------------------------------------------------------------------------------------------------------------------+--------------------+\n| Neptune                              | Vessel       | 1         | Nadia told Neptune to stay under the radar.                                                                                                     | 538                |\n+--------------------------------------+--------------+-----------+-------------------------------------------------------------------------------------------------------------------------------------------------+--------------------+\n| V. Miesel HQ                         | Organisation | 1         | Organisation was aware of the suspicious permit and The Middleman.                                                                              | 846, 847           |\n+--------------------------------------+--------------+-----------+-------------------------------------------------------------------------------------------------------------------------------------------------+--------------------+\n| Sailor Shifts Team aka Glitters Team | Organisation | 1         | Nadia provided crew members for the setup related to the permit.                                                                                | 520                |\n+--------------------------------------+--------------+-----------+-------------------------------------------------------------------------------------------------------------------------------------------------+--------------------+\n\n### Non Suspicious Entity\n\n+-----------------------+--------------+-----------+--------------------------------------------------------------------------------------------------------------------------+----------+\n| Non Suspicious Entity | Sub Type     | Community | Rationale                                                                                                                | Event ID |\n+=======================+==============+===========+==========================================================================================================================+==========+\n| Oceanus City Council  | Organisation | 2         | Oceanus City Council as a whole is not suspicious as an organisation as Liam stated this organisation suspected nothing. | 535      |\n+-----------------------+--------------+-----------+--------------------------------------------------------------------------------------------------------------------------+----------+\n| Sentinel              | Vessel       | 2         | Sentinel Vessel suspected ulterior motives as the water quality was fine.                                                | 677      |\n+-----------------------+--------------+-----------+--------------------------------------------------------------------------------------------------------------------------+----------+\n| Marlin                | Vessel       | 2         | Marlin inquired about unusual vessel routes near eastern shoals, Nadia and Davis might need to address this.             | 584      |\n+-----------------------+--------------+-----------+--------------------------------------------------------------------------------------------------------------------------+----------+\n:::\n\n## **9.6 Querying Keywords**\n\nBased on our knowledge, we decided to connect to external information. We used knowledge from Nadia's current network and communication with keyword search of our queries.\n\n### 9.6.1 Plotted Timeline (Word Query: Permit related)\n\n```{r}\n#| code-fold: true\n#| code-summary: \"Show the code\"\n\n# -- Step 1: Define keywords\nkeywords <- c(\"permit\", \"1045\", \"7844\")\npattern <- paste0(\"\\\\b(\", paste(keywords, collapse = \"|\"), \")\\\\b\")\n\n# -- Step 2: Filter messages with keyword match (case-insensitive)\nkeyword_matches_df <- other_communications_df %>%\n  mutate(content_lower = tolower(content)) %>%\n  filter(str_detect(content_lower, pattern))\n\n# -- Step 3: Extract and annotate keyword matches\nplot_data <- keyword_matches_df %>%\n  mutate(\n    matched_keywords = str_extract_all(content_lower, pattern),\n    timestamp = suppressWarnings(as.POSIXct(timestamp)),\n    comm_date = as.Date(timestamp),\n    comm_time_of_day = suppressWarnings(hms::as_hms(format(timestamp, \"%H:%M:%S\"))),\n    wrapped_content = str_wrap(content, width = 50)\n  ) %>%\n  unnest(matched_keywords) %>%\n  mutate(\n    matched_keywords = recode(matched_keywords,\n      \"permit\" = \"Permit\",\n      \"1045\" = \"# 1045\",\n      \"7844\" = \"# 7844\"\n    ),\n    tooltip_text = paste0(\n      \"<b>Date:</b> \", comm_date,\n      \"<br><b>Time:</b> \", format(comm_time_of_day, \"%H:%M:%S\"),\n      \"<br><b>Event ID:</b> \", event_id,\n      \"<br><b>Content:</b><br>\", wrapped_content\n    )\n  )\n\n# -- Step 4: Plot timeline\np <- ggplot(plot_data, aes(x = comm_date, y = comm_time_of_day)) +\n  geom_point(aes(\n    color = matched_keywords,\n    shape = sender_sub_type,\n    text = tooltip_text,\n    group = matched_keywords\n  ), size = 2.5, alpha = 0.7, show.legend = TRUE) +\n  scale_shape_manual(values = c(\n    \"Person\" = 16,\n    \"Vessel\" = 17,\n    \"Organization\" = 15,\n    \"Location\" = 18\n  )) +\n  facet_wrap(~ matched_keywords, ncol = 1, scales = \"fixed\") +\n  scale_y_time(\n    limits = hms::as_hms(c(\"08:00:00\", \"13:00:00\")),\n    breaks = hms::as_hms(c(\"08:00:00\", \"09:00:00\", \"10:00:00\", \"11:00:00\", \"12:00:00\", \"13:00:00\")),\n    labels = c(\"08:00\", \"09:00\", \"10:00\", \"11:00\", \"12:00\", \"13:00\")\n  ) +\n  scale_x_date(date_breaks = \"1 day\", date_labels = \"%d %b\") +\n  labs(\n    title = \"Interactive Timeline: Keyword Mentions by Day and Time\",\n    x = \"Date\",\n    y = \"Time of Day\",\n    shape = \"Sender Type\",\n    color = \"Keyword\"\n  ) +\n  theme_grey() +\n  theme(\n    axis.text.y = element_text(size = 6),\n    axis.title.y = element_text(size = 7),\n    axis.ticks.y = element_line(),\n    axis.text.x = element_text(size = 6, angle = 45, hjust = 1),\n    axis.title.x = element_text(margin = margin(t = 10), size = 7),\n    panel.spacing = unit(0.5, \"lines\"),\n    strip.text = element_text(size = 8, face = \"bold\"),\n    legend.position = \"bottom\",\n    legend.text = element_text(size = 6),\n    legend.title = element_blank()\n  )\n\n# -- Step 5: Convert to plotly\nggplotly(p, tooltip = \"text\")\n\n\n```\n\n### 9.6.1.1 Findings in sequential order:\n\n-   There were overlaps as the blue permit also included the red NR-1045 permit and green CR-7844 permit.\n\n```{r}\n#| code-fold: true\n#| code-summary: \"Show the code\"\n\nlibrary(reactable)\nlibrary(dplyr)\nlibrary(stringr)\nlibrary(readr) # Used for read_lines\n\n# 1. Prepare data from the text provided\ndata_text <- \"\nDate & Time | Event Description\n------------|---------------------------------------------------------------------------------------------------------------\n2 Oct (12:16pm) | Rodriguez was from the Sailor Shifts Team.\n5 Oct (10:54am) | Jensen from City Council approved Nemo Reef permit.\n6 Oct (9:57am) | Remora told Sailor Shifts Team that Nadia got Commissioner Torres to sign off the permit.\n6 Oct (10:45am) | Mako acknowledged NR-1045 permit to Nemo Reef.\n6 Oct (12:33pm) | Mako was lead vessel to Neptune and Remora as authorised by V. Miesel Shipping.\n7 Oct (9:40am) | Mako was operating under permit NR-1045 for conservation research.\n8 Oct (10:24am) | Mako was operating under V. Miesel's special marine research permit CR-7844 approved by Oceanus City Council.\n8 Oct (10:30am) | Mako informed Remora that both of them were operating under permit CR-7844 and have a 5 day deadline.\n8 Oct (10:40am) | Remora was approved by Paackland Harbor to operate with extended hours under permit NR-1045.\n9 Oct (11:53am) | Mako requesed for additional crew from v Miesel Shipping for the 24hr operations over next 5 days.\n11 Oct (6:00am) | Nemo Reef closure mandated by Oceanus City Council.\n11 Oct (8:57am) | All research permits must be submitted within 72 hours.\n11 Oct (10:05am) | V. Miesel Shipping informed Remora that 30% of her crew to be reassigned to Neptune.\n12 Oct (10:01am) | Davis as Captain oversaw crew reallocation.\n12 Oct (11:19am) | Nadia secured documentation for CR-7844.\n12 Oct (12:52pm) | Harbor closure for 3 days from 13 Oct 06:00.\n\"\n\n# Parse the data into a data frame\n# Use read_lines to handle the multi-line string\ndata_lines <- read_lines(data_text)\n\n# Remove the header separator line and any empty lines\ndata_lines <- data_lines[!grepl(\"^---|===\", data_lines) & data_lines != \"\"]\n\n# The first non-separator line is the header\ncol_names_raw <- str_split(data_lines[1], \"\\\\|\")[[1]]\ncol_names <- str_trim(col_names_raw)\n\n# The rest are data rows\ndata_content <- data_lines[-1]\n\n# Create data frame by splitting lines and putting into a tibble\ndf <- tibble(line = data_content) %>%\n  mutate(\n    `Date & Time` = str_trim(str_extract(line, \"^[^|]+\")),\n    `Event Description` = str_trim(str_extract(line, \"(?<=\\\\|).+$\"))\n  ) %>%\n  select(`Date & Time`, `Event Description`) # Ensure correct column order and names\n\n# 2. Create the reactable table with desired features\n\nreactable(\n  df,\n  filterable = TRUE, # Enable column-specific filters (from the tutorial)\n  searchable = TRUE, # Enable global search box (from the tutorial)\n  paginationType = \"numbers\", # Display page numbers (corrected from \"pages\")\n  defaultPageSize = 5, # Show 5 rows per page\n  showPageSizeOptions = TRUE, # Allow users to change page size\n  pageSizeOptions = c(5, 10, 15, 20, 50), # Options for page sizes\n  striped = TRUE, # Add alternating row colors (from the tutorial)\n  highlight = TRUE, # Highlight row on hover (from the tutorial)\n  columns = list(\n    `Date & Time` = colDef(\n      name = \"Date & Time\",\n      minWidth = 120, # Adjust width to fit content\n      align = \"left\"\n    ),\n    `Event Description` = colDef(\n      name = \"Event Description\",\n      minWidth = 500, # Ensure enough width for event descriptions\n      align = \"left\"\n    )\n  ),\n  # Apply a custom theme for better aesthetics (inspired by the tutorial)\n  theme = reactableTheme(\n    borderColor = \"#dfe2e5\",\n    stripedColor = \"#f6f8fa\",\n    highlightColor = \"#f0f5f9\",\n    cellPadding = \"8px 12px\",\n    style = list(fontFamily = \"Verdana, Geneva, sans-serif\", fontSize = \"14px\"),\n    headerStyle = list(\n      \"&.rt-th:hover\" = list(backgroundColor = \"#e0e6eb\"),\n      fontSize = \"15px\",\n      fontWeight = 600,\n      color = \"#333\", # Darker header text for contrast\n      background = \"#f7f7f7\" # Slightly grey background for header\n    ),\n    rowSelectedStyle = list(backgroundColor = \"#e6f2ff\", \"&:hover\" = list(backgroundColor = \"#e6f2ff\")),\n    # Styles for search/filter inputs (from tutorial's theme example)\n    searchInputStyle = list(width = \"100%\", margin = \"5px 0\", padding = \"5px\"),\n    filterInputStyle = list(width = \"100%\", margin = \"2px 0\", padding = \"4px\")\n  )\n)\n```\n\n-   Since there were little communications on 13 Oct, we looked into other word queries.\n\n-   Using information obtained from question 2 and 4, we had in mind certain keywords to query for.\n\n### 9.6.2 Plotted Timeline (Word Query: Music Video Related)\n\n```{r}\n#| code-fold: true\n#| code-summary: \"Show the code\"\nlibrary(dplyr)\nlibrary(stringr)\nlibrary(ggplot2)\nlibrary(plotly)\nlibrary(hms)\nlibrary(tidyr)\n\n# -- Step 1: Define keywords\nkeywords <- c(\"mine\", \"mining\", \"music video\", \"lighting\", \"reef operation\")\npattern <- paste0(\"\\\\b(\", paste(keywords, collapse = \"|\"), \")\\\\b\")\n\n# -- Step 2: Filter messages\nsearch_target_content <- tolower(other_communications_df$content)\n\nkeyword_matches_df <- other_communications_df %>%\n  filter(str_detect(search_target_content, pattern))\n\n# -- Step 3: Extract keywords\nplot_data <- keyword_matches_df %>%\n  mutate(matched_keywords = str_extract_all(tolower(content), pattern)) %>%\n  unnest(matched_keywords) %>%\n  mutate(matched_keywords = str_to_title(matched_keywords)) %>%\n  arrange(matched_keywords, timestamp) %>%\n  mutate(\n    timestamp = as.POSIXct(timestamp),\n    comm_date = as.Date(timestamp),\n    comm_time_of_day = hms::as_hms(format(timestamp, \"%H:%M:%S\")),\n    wrapped_content = str_wrap(content, width = 50),\n    tooltip_text = paste0(\n      \"<b>Date:</b> \", comm_date,\n      \"<br><b>Time:</b> \", comm_time_of_day,\n      \"<br><b>Event ID:</b> \", event_id,\n      \"<br><b>From:</b> \", sender_name,\n      \"<br><b>To:</b> \", recipient_name,\n      \"<br><b>Content:</b><br>\", wrapped_content\n    )\n  )\n\n# -- Step 4: Plot\np <- ggplot(plot_data, aes(x = comm_date, y = comm_time_of_day)) +\n  geom_point(aes(\n    color = matched_keywords,\n    shape = sender_sub_type,\n    text = tooltip_text,\n    group = matched_keywords  # ensures matched_keywords is in layer\n  ), size = 2.5, alpha = 0.7, show.legend = TRUE) +\n  scale_shape_manual(values = c(\n    \"Person\" = 16,\n    \"Vessel\" = 17,\n    \"Organization\" = 15,\n    \"Location\" = 18\n  )) +\n  facet_wrap(~ matched_keywords, ncol = 1, scales = \"fixed\") +\n  scale_y_time(\n    limits = hms::as_hms(c(\"08:00:00\", \"13:00:00\")),\n    breaks = hms::as_hms(c(\"08:00:00\", \"09:00:00\", \"10:00:00\", \"11:00:00\", \"12:00:00\", \"13:00:00\")),\n    labels = c(\"08:00\", \"09:00\", \"10:00\", \"11:00\", \"12:00\", \"13:00\")\n  ) +\n  scale_x_date(date_breaks = \"1 day\", date_labels = \"%d %b\") +\n  labs(\n    title = \"Interactive Timeline: Keyword Mentions by Day and Time\",\n    x = \"Date\",\n    y = \"Time of Day\",\n    shape = \"Sender Type\",\n    color = \"Keyword\"\n  ) +\n  theme_grey() +\n  theme(\n    axis.text.y = element_text(size = 6),\n    axis.title.y = element_text(size = 7),\n    axis.ticks.y = element_line(),\n    axis.text.x = element_text(size = 6, angle = 45, hjust = 1),\n    axis.title.x = element_text(margin = margin(t = 10), size = 7),\n    panel.spacing = unit(0.5, \"lines\"),  # Applies to both x and y spacing\n    strip.text = element_text(size = 8, face = \"bold\"),\n    legend.position = \"bottom\",\n    legend.text = element_text(size = 6),\n    legend.title = element_blank()\n  )\n\n# -- Step 5: Convert to plotly\nggplotly(p, tooltip = \"text\")\n```\n\n### 9.6.2.1 Findings through Questions & Answers:\n\n#### **Question and Answer Analysis**\n\n+------------------------------------------------------------------------------------------------------------------------------+------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+\n| **Question**                                                                                                                 | **Answer**                                                                                                                                                                                                                                                                                                                               |\n+==============================================================================================================================+==========================================================================================================================================================================================================================================================================================================================================+\n| Which vessel was the suspicious permit #CR-7844 prepared for?                                                                | From question 2 and 4, we know this is V. Miesel's Marine Research Permit, and prepared for Mako (lead vessel), Neptune, and Remora.                                                                                                                                                                                                     |\n|                                                                                                                              |                                                                                                                                                                                                                                                                                                                                          |\n| (See 9.6.1.1)                                                                                                                |                                                                                                                                                                                                                                                                                                                                          |\n+------------------------------------------------------------------------------------------------------------------------------+------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+\n| What suspicious activity was performed at Nemo Reef? Which day was it?                                                       | 14 Oct 2040 for a music video production.                                                                                                                                                                                                                                                                                                |\n|                                                                                                                              |                                                                                                                                                                                                                                                                                                                                          |\n| (See 9.6.2)                                                                                                                  |                                                                                                                                                                                                                                                                                                                                          |\n+------------------------------------------------------------------------------------------------------------------------------+------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+\n| Why is underwater lighting placement needed at Nemo Reef?                                                                    | For a music video production.                                                                                                                                                                                                                                                                                                            |\n|                                                                                                                              |                                                                                                                                                                                                                                                                                                                                          |\n| (See 9.6.2)                                                                                                                  |                                                                                                                                                                                                                                                                                                                                          |\n+------------------------------------------------------------------------------------------------------------------------------+------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+\n| What were the expedited approvals and secretive logistics?                                                                   | Permits for Nemo Reef through NR-1045 and CR-788 were expedited. The secretive logistics were the crates and equipment on the vessels for the music video production.                                                                                                                                                                    |\n|                                                                                                                              |                                                                                                                                                                                                                                                                                                                                          |\n| (See 9.6.1 and 9.6.2)                                                                                                        |                                                                                                                                                                                                                                                                                                                                          |\n+------------------------------------------------------------------------------------------------------------------------------+------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+\n| Who were the high-level Oceanus officials, Sailor Shift’s team, local influential families, and local conservationist group? | **Oceanus Officials**: Commissioner Blake, Commissioner Torres, Council Knowles, The Middleman, Jensen, Liam Thorne                                                                                                                                                                                                                      |\n|                                                                                                                              |                                                                                                                                                                                                                                                                                                                                          |\n| (Various Ids)                                                                                                                | **Sailor Shift’s Team**: Boss, Council Knowles, Davis, Glitters Team, Liam Thorne, Mako, Mrs. Money, Nadia, Neptune, Remora, Rodriguez, Sam, Samantha Blake, Small Fry, The Accountant, The Intern, The Middleman                                                                                                                        |\n|                                                                                                                              |                                                                                                                                                                                                                                                                                                                                          |\n|                                                                                                                              | **Local Influential Families**: Council Knowles, V. Miesel Shipping                                                                                                                                                                                                                                                                      |\n|                                                                                                                              |                                                                                                                                                                                                                                                                                                                                          |\n|                                                                                                                              | **Local Conservationist Group**: Defender, EcoVigil, Green Guardians, Horizon, Kelly, Reef Guardians, Seawatch, Sentinel, The Lookout                                                                                                                                                                                                    |\n+------------------------------------------------------------------------------------------------------------------------------+------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+\n| Was the music video production activity legal?                                                                               | There was no environmental damage or mining involved in the music production. However, an environmental assessment was not conducted prior. Clepper may assess that his suspicions about Nadia Conti's illicit activity may not be straightforward and could depend on whether an assessment was mandatory before commercial activities. |\n|                                                                                                                              |                                                                                                                                                                                                                                                                                                                                          |\n| (Id 979)                                                                                                                     |                                                                                                                                                                                                                                                                                                                                          |\n+------------------------------------------------------------------------------------------------------------------------------+------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+\n\n# **10) Recreation of Story-Line**\n\nHere we attempted to summarise the story-line.\n\n```{r}\n#| code-fold: true\n#| code-summary: \"Show the code\"\n# --- Step 0: Define Event Data for Annotations ---\nevent_dates <- as.Date(c(\"2040-10-01\", \"2040-10-03\", \"2040-10-04\", \"2040-10-05\",\n                         \"2040-10-06\", \"2040-10-08\", \"2040-10-09\", \"2040-10-11\",\n                         \"2040-10-12\", \"2040-10-14\"))\n\nevent_labels_full <- c(\n  \"The Middleman told The Boss (Nadia) about a potential loophole in Nemo Reef protection zone\",\n  \"Tourism vessels were offering authorised access. Their violations were addressed at City Council meeting\",\n  \"Nadia told Mako to abort Nemo Reef mission as conservation vessels were close\",\n  \"News of Nadia assisting to get permit for Nemo Reef signed by Jensen from City Council on 4/10 spreaded\",\n  \"V. Miesel Shipping HQ told Neptune that Mako is lead vessel\",\n  \"Neptune told Mako they were under special marine research permit CR-7844\",\n  \"Neptune's underwater concrete forms in fragile crates discovered\",\n  \"37 'authorised maintenance vessels' documented despite Nemo Reef closure\",\n  \"Crew reallocated from Remona to Neptune overseen by Captain Davis\",\n  \"Music video production after Nemo Reef equipment transfer\"\n)\n\nevent_labels_short <- c(\n  \"Loophole\", \"Tourism\", \"Mako\", \"Permit\\nResults\", \"#NR-1045\",\n  \"#CR-7844\", \"Underwater\\nStructure\", \"37 Vessels\", \"Shifted Crew\", \"MV\\nProduction\"\n)\n\n# --- Step 1: Calculate Daily Message Frequencies ---\nfreq_df <- other_communications_df %>%\n  mutate(comm_date = as.Date(timestamp)) %>%\n  count(comm_date, name = \"message_count\") %>%\n  # Complete the date range to include all days, filling missing counts with 0\n  complete(comm_date = seq(min(comm_date), max(comm_date), by = \"day\"),\n           fill = list(message_count = 0))\n\n# --- Step 2: Build Event Annotation Table ---\nevent_df <- tibble(\n  date = event_dates,\n  label = gsub(\"\\n\", \"<br>\", event_labels_short), # Replace \\n with <br> for HTML tooltips\n  tooltip_raw = str_wrap(event_labels_full, width = 40) # Wrap long text for tooltips\n)\n\ncore_events <- event_df %>%\n  left_join(freq_df, by = c(\"date\" = \"comm_date\")) %>%\n  group_by(date) %>%\n  mutate(\n    offset = row_number(), # For stacking multiple events on the same day\n    # Adjust value for arrow positioning relative to message count\n    value = as.numeric(message_count) + 0.5 * offset,\n    date_jitter = date + (offset - 1) * 0.1 # Slight horizontal jitter if multiple events\n  ) %>%\n  ungroup() %>%\n  mutate(\n    # Create rich HTML tooltip content for Plotly\n    tooltip = paste0(\n      \"📅 <b>Date:</b> \", date,\n      \"<br>✉️ <b>Messages:</b> \", message_count,\n      \"<br>📝 <b>Core Event:</b> \", tooltip_raw\n    )\n  )\n\n# --- Step 3: Create the ggplot2 Plot ---\np <- ggplot(freq_df, aes(x = comm_date, y = message_count)) +\n  # Line plot for message frequency\n  geom_line(color = \"navyblue\") +\n  # Segments (arrows) pointing from the line to the event annotations\n  geom_segment(\n    data = core_events,\n    aes(x = date, xend = date, y = value - 1, yend = value + 0.5), # Adjust yend for arrow tip\n    arrow = arrow(length = unit(0.15, \"inches\")), color = \"grey40\"\n  ) +\n  # Points for the events (these will have the interactive tooltips)\n  geom_point(\n    data = core_events,\n    aes(x = date, y = value + 0.5, text = tooltip), # 'text' aesthetic is key for Plotly tooltips\n    color = \"firebrick\", size = 3\n  ) +\n  # Text labels for the short event names\n  geom_text(\n    data = core_events,\n    aes(x = date, y = value + 2, label = label), # Position text above the point/arrow\n    color = \"black\", fontface = \"bold\", size = 2.5, vjust = 0\n  ) +\n  # X-axis scale for dates\n  scale_x_date(date_breaks = \"1 day\", date_labels = \"%b %d\") +\n  # Labels and titles\n  labs(\n    title = \"Message Frequency Over Time\",\n    x = \"Date\", y = \"Message Count\"\n  ) +\n  # Ensure annotations are not clipped by plot limits\n  coord_cartesian(clip = \"off\") +\n  # Minimal theme for a clean look\n  theme_grey(base_size = 10) +\n  # Further theme adjustments\n  theme(\n    axis.text.x = element_text(angle = 45, hjust = 1),\n    plot.title = element_text(face=\"bold\"),\n    plot.margin = margin(30, 30, 10, 10), # Adjust plot margins if needed\n  )\n\n# --- Step 4: Convert to Interactive Plotly Object ---\n# The 'tooltip = \"text\"' argument tells Plotly to use the 'text' aesthetic\n# for the hover information, which we created as 'tooltip' in core_events.\np_interactive <- ggplotly(p, tooltip = \"text\")\n\n# --- Step 5: Display the Interactive Plot ---\np_interactive\n```\n\nHover over the red points to see the details. Here, we provided a high level summary on the core event on the preparation and production of the music video Nadia was involved in for a period of 2 weeks, and also provided a snippet to the sub-event of the tourism vessels breaching protocols earlier in the week.\n\n# **11) References**\n\n-   Datastorm (2021) [visNetwork](https://datastorm-open.github.io/visNetwork/)\n\n-   Dr. Kam Tin Seong (2025) [Lesson 9: Visualising and Analysis Network Data](https://isss608-ay2024-25apr.netlify.app/outline/lesson09_outline)\n\n-   R-Graph (2025) [Reactable](https://r-graph-gallery.com/package/reactable.html)\n"},"formats":{"html":{"identifier":{"display-name":"HTML","target-format":"html","base-format":"html"},"execute":{"fig-width":7,"fig-height":5,"fig-format":"retina","fig-dpi":96,"df-print":"default","error":false,"eval":true,"cache":null,"freeze":false,"echo":true,"output":true,"warning":false,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":null,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"ipynb-shell-interactivity":null,"plotly-connected":true,"engine":"knitr"},"render":{"keep-tex":false,"keep-typ":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"html","fig-align":"default","fig-pos":null,"fig-env":null,"code-fold":true,"code-overflow":"scroll","code-link":false,"code-line-numbers":false,"code-tools":false,"tbl-colwidths":"auto","merge-includes":true,"inline-includes":false,"preserve-yaml":false,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-min-runs":1,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":false,"link-external-newwindow":false,"self-contained-math":false,"format-resources":[],"notebook-links":true},"pandoc":{"standalone":true,"wrap":"none","default-image-extension":"png","to":"html","toc":true,"toc-depth":2,"css":["ex03-style.css"],"output-file":"Prototype.html"},"language":{"toc-title-document":"Table of contents","toc-title-website":"On this page","related-formats-title":"Other Formats","related-notebooks-title":"Notebooks","source-notebooks-prefix":"Source","other-links-title":"Other Links","code-links-title":"Code Links","launch-dev-container-title":"Launch Dev Container","launch-binder-title":"Launch Binder","article-notebook-label":"Article Notebook","notebook-preview-download":"Download Notebook","notebook-preview-download-src":"Download Source","notebook-preview-back":"Back to Article","manuscript-meca-bundle":"MECA Bundle","section-title-abstract":"Abstract","section-title-appendices":"Appendices","section-title-footnotes":"Footnotes","section-title-references":"References","section-title-reuse":"Reuse","section-title-copyright":"Copyright","section-title-citation":"Citation","appendix-attribution-cite-as":"For attribution, please cite this work as:","appendix-attribution-bibtex":"BibTeX citation:","appendix-view-license":"View License","title-block-author-single":"Author","title-block-author-plural":"Authors","title-block-affiliation-single":"Affiliation","title-block-affiliation-plural":"Affiliations","title-block-published":"Published","title-block-modified":"Modified","title-block-keywords":"Keywords","callout-tip-title":"Tip","callout-note-title":"Note","callout-warning-title":"Warning","callout-important-title":"Important","callout-caution-title":"Caution","code-summary":"Code","code-tools-menu-caption":"Code","code-tools-show-all-code":"Show All Code","code-tools-hide-all-code":"Hide All Code","code-tools-view-source":"View Source","code-tools-source-code":"Source Code","tools-share":"Share","tools-download":"Download","code-line":"Line","code-lines":"Lines","copy-button-tooltip":"Copy to Clipboard","copy-button-tooltip-success":"Copied!","repo-action-links-edit":"Edit this page","repo-action-links-source":"View source","repo-action-links-issue":"Report an issue","back-to-top":"Back to top","search-no-results-text":"No results","search-matching-documents-text":"matching documents","search-copy-link-title":"Copy link to search","search-hide-matches-text":"Hide additional matches","search-more-match-text":"more match in this document","search-more-matches-text":"more matches in this document","search-clear-button-title":"Clear","search-text-placeholder":"","search-detached-cancel-button-title":"Cancel","search-submit-button-title":"Submit","search-label":"Search","toggle-section":"Toggle section","toggle-sidebar":"Toggle sidebar navigation","toggle-dark-mode":"Toggle dark mode","toggle-reader-mode":"Toggle reader mode","toggle-navigation":"Toggle navigation","crossref-fig-title":"Figure","crossref-tbl-title":"Table","crossref-lst-title":"Listing","crossref-thm-title":"Theorem","crossref-lem-title":"Lemma","crossref-cor-title":"Corollary","crossref-prp-title":"Proposition","crossref-cnj-title":"Conjecture","crossref-def-title":"Definition","crossref-exm-title":"Example","crossref-exr-title":"Exercise","crossref-ch-prefix":"Chapter","crossref-apx-prefix":"Appendix","crossref-sec-prefix":"Section","crossref-eq-prefix":"Equation","crossref-lof-title":"List of Figures","crossref-lot-title":"List of Tables","crossref-lol-title":"List of Listings","environment-proof-title":"Proof","environment-remark-title":"Remark","environment-solution-title":"Solution","listing-page-order-by":"Order By","listing-page-order-by-default":"Default","listing-page-order-by-date-asc":"Oldest","listing-page-order-by-date-desc":"Newest","listing-page-order-by-number-desc":"High to Low","listing-page-order-by-number-asc":"Low to High","listing-page-field-date":"Date","listing-page-field-title":"Title","listing-page-field-description":"Description","listing-page-field-author":"Author","listing-page-field-filename":"File Name","listing-page-field-filemodified":"Modified","listing-page-field-subtitle":"Subtitle","listing-page-field-readingtime":"Reading Time","listing-page-field-wordcount":"Word Count","listing-page-field-categories":"Categories","listing-page-minutes-compact":"{0} min","listing-page-category-all":"All","listing-page-no-matches":"No matching items","listing-page-words":"{0} words","listing-page-filter":"Filter","draft":"Draft"},"metadata":{"lang":"en","fig-responsive":true,"quarto-version":"1.7.24","editor":"visual","theme":"journal","code-summary":"Show the code","title":"Prototype","page-layout":"full"},"extensions":{"book":{"multiFile":true}}}},"projectFormats":["html"]}